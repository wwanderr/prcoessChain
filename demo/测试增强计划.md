# 测试增强计划 - 生产级测试用例设计

## 目标

为所有测试文件添加**复杂场景**和**边界条件**测试，确保代码在真实生产环境中的稳定性。

---

## 测试文件分析

### 1. CoreLogicTest.java
**当前覆盖**：基础核心逻辑（8个测试）
- 单/多 traceId
- 根节点识别
- Explore 节点创建
- 断链处理

**需要增强的场景**：
1. **极端数据量**
   - 超大规模节点（1000+节点）
   - 超深层级（100+层）
   - 超宽分支（100+子节点）

2. **异常数据**
   - 循环引用（A→B→C→A）
   - 自引用（A→A）
   - 孤立节点（没有任何连接）
   - 重复的 processGuid

3. **边界条件**
   - 空字符串 processGuid
   - null 值混合
   - 特殊字符（Unicode、emoji）
   - 超长字符串（10000+字符）

4. **并发场景**
   - 同一 traceId 多次构建
   - 多线程同时构建不同 traceId

### 2. DataStructureOptimizationTest.java
**当前覆盖**：数据结构优化功能（9个测试）
- ChainBuilderNode 字段提取
- NodeIndex 索引功能
- 性能测试

**需要增强的场景**：
1. **索引边界测试**
   - 大量节点的索引性能（10000+节点）
   - 频繁更新索引的性能
   - 索引一致性验证

2. **内存压力测试**
   - 大数据集的内存占用
   - 内存泄漏检测
   - GC 压力测试

3. **并发索引测试**
   - 多线程同时查询索引
   - 并发更新索引

### 3. SpringBootProcessChainTest.java
**当前覆盖**：集成测试（15个测试）
- 各种 traceId 组合
- 树状结构
- 裁剪功能

**需要增强的场景**：
1. **真实攻击链模拟**
   - 勒索软件攻击链（多阶段）
   - APT 攻击链（长期潜伏）
   - 横向移动攻击链（多主机）

2. **混合场景**
   - 多种日志类型混合
   - 多种告警等级混合
   - 多主机多 traceId 混合

3. **异常恢复**
   - 部分数据缺失
   - 数据损坏
   - 时间戳异常

### 4. ProcessChainMergeTest.java
**当前覆盖**：进程链合并逻辑
- 网端端侧合并
- Bridge 边处理

**需要增强的场景**：
1. **复杂合并**
   - 多对多合并（多个网端对多个端侧）
   - 嵌套合并（合并后再合并）
   - 冲突解决（相同节点不同数据）

2. **边界合并**
   - 空链合并
   - 单节点合并
   - 超大链合并（1000+节点）

### 5. ProcessChainPrunerTest.java
**当前覆盖**：节点裁剪逻辑
- 智能裁剪
- 关键节点保护

**需要增强的场景**：
1. **裁剪策略验证**
   - 极端裁剪（保留1%节点）
   - 无需裁剪（节点数刚好）
   - 裁剪后完整性验证

2. **性能裁剪**
   - 超大图裁剪性能（10000+节点）
   - 裁剪算法复杂度验证

### 6. ProcessChainIntegrationTest.java
**当前覆盖**：端到端集成测试

**需要增强的场景**：
1. **完整攻击场景**
   - 从入侵到横向移动到数据窃取
   - 多阶段攻击链
   - 多受害者场景

2. **系统压力测试**
   - 高并发请求
   - 大数据量处理
   - 长时间运行稳定性

---

## 测试用例设计原则

### 1. 真实性原则
- 基于真实攻击场景设计
- 使用真实的进程名、路径
- 模拟真实的时间间隔

### 2. 全面性原则
- 覆盖所有代码分支
- 包含正常和异常路径
- 测试所有边界条件

### 3. 可维护性原则
- 测试用例独立
- 清晰的测试意图
- 详细的注释说明

### 4. 性能原则
- 包含性能基准测试
- 监控资源使用
- 设置合理的超时

---

## 具体测试用例设计

### CoreLogicTest 新增测试（10个）

#### 1. 极端数据量测试
```java
@Test
public void test09_ExtremeScale_1000Nodes() {
    // 1000个节点的线性链
    // 验证：深度限制、性能、内存
}

@Test
public void test10_ExtremeWidth_100Children() {
    // 1个根节点，100个直接子节点
    // 验证：广度处理、性能
}
```

#### 2. 异常数据测试
```java
@Test
public void test11_CircularReference_DetectAndHandle() {
    // A→B→C→A 循环引用
    // 验证：环检测、不死循环
}

@Test
public void test12_SelfReference_NodePointsToItself() {
    // A→A 自引用
    // 验证：自引用处理
}

@Test
public void test13_OrphanNodes_NoConnections() {
    // 多个孤立节点
    // 验证：孤立节点处理
}

@Test
public void test14_DuplicateProcessGuid() {
    // 相同 processGuid 的多条日志
    // 验证：去重、合并
}
```

#### 3. 边界条件测试
```java
@Test
public void test15_EmptyString_ProcessGuid() {
    // processGuid 为空字符串
    // 验证：空值处理
}

@Test
public void test16_SpecialCharacters_Unicode() {
    // processGuid 包含 Unicode、emoji
    // 验证：特殊字符处理
}

@Test
public void test17_ExtremelyLongString_10000Chars() {
    // processGuid 长度 10000+
    // 验证：长字符串处理
}
```

#### 4. 并发测试
```java
@Test
public void test18_Concurrent_SameTraceId() {
    // 多线程同时构建同一 traceId
    // 验证：线程安全
}
```

### DataStructureOptimizationTest 新增测试（8个）

#### 1. 索引性能测试
```java
@Test
public void test10_IndexPerformance_10000Nodes() {
    // 10000个节点的索引性能
    // 验证：O(1) 查询时间
}

@Test
public void test11_FrequentUpdate_IndexConsistency() {
    // 频繁更新节点，验证索引一致性
}
```

#### 2. 内存测试
```java
@Test
public void test12_MemoryUsage_LargeDataset() {
    // 大数据集内存占用
    // 验证：内存在可接受范围
}

@Test
public void test13_MemoryLeak_RepeatedBuild() {
    // 重复构建，检测内存泄漏
}
```

#### 3. 并发测试
```java
@Test
public void test14_ConcurrentQuery_NodeIndex() {
    // 多线程并发查询索引
    // 验证：线程安全、性能
}

@Test
public void test15_ConcurrentUpdate_NodeIndex() {
    // 多线程并发更新索引
    // 验证：数据一致性
}
```

#### 4. 边界测试
```java
@Test
public void test16_EmptyIndex_Operations() {
    // 空索引的各种操作
}

@Test
public void test17_SingleNode_AllOperations() {
    // 单节点的所有操作
}
```

### SpringBootProcessChainTest 新增测试（12个）

#### 1. 真实攻击链模拟
```java
@Test
public void test16_RealAttack_RansomwareChain() {
    // 勒索软件攻击链
    // powershell → vssadmin → bcdedit → 加密文件
}

@Test
public void test17_RealAttack_APTChain() {
    // APT 攻击链
    // 初始入侵 → 权限提升 → 横向移动 → 数据窃取
}

@Test
public void test18_RealAttack_LateralMovement() {
    // 横向移动攻击
    // Host1 → Host2 → Host3
}
```

#### 2. 混合场景
```java
@Test
public void test19_Mixed_AllLogTypes() {
    // process + file + network + domain + registry
}

@Test
public void test20_Mixed_AllSeverities() {
    // 高中低危告警混合
}

@Test
public void test21_Mixed_MultiHostMultiTrace() {
    // 多主机多 traceId 复杂场景
}
```

#### 3. 异常恢复
```java
@Test
public void test22_PartialData_MissingLogs() {
    // 部分日志缺失
}

@Test
public void test23_CorruptedData_InvalidFields() {
    // 数据字段损坏
}

@Test
public void test24_TimeAnomaly_FutureTimestamp() {
    // 时间戳异常（未来时间）
}
```

#### 4. 性能测试
```java
@Test
public void test25_Performance_100Alarms() {
    // 100个告警的处理性能
}

@Test
public void test26_Performance_1000Logs() {
    // 1000条日志的处理性能
}

@Test
public void test27_Performance_ComplexGraph() {
    // 复杂图结构的处理性能
}
```

### ProcessChainMergeTest 新增测试（8个）

#### 1. 复杂合并
```java
@Test
public void testMerge_ManyToMany() {
    // 多个网端对多个端侧
}

@Test
public void testMerge_Nested() {
    // 嵌套合并（合并后再合并）
}

@Test
public void testMerge_ConflictResolution() {
    // 相同节点不同数据的冲突解决
}
```

#### 2. 边界合并
```java
@Test
public void testMerge_EmptyChains() {
    // 空链合并
}

@Test
public void testMerge_SingleNode() {
    // 单节点合并
}

@Test
public void testMerge_HugeChain_1000Nodes() {
    // 超大链合并
}
```

#### 3. 异常合并
```java
@Test
public void testMerge_NoMatchingHost() {
    // 找不到匹配的主机
}

@Test
public void testMerge_DuplicateBridge() {
    // 重复的 bridge 边
}
```

### ProcessChainPrunerTest 新增测试（8个）

#### 1. 裁剪策略
```java
@Test
public void testPrune_Extreme_Keep1Percent() {
    // 极端裁剪，只保留1%
}

@Test
public void testPrune_NoNeed_ExactLimit() {
    // 节点数刚好等于限制
}

@Test
public void testPrune_Integrity_PathComplete() {
    // 裁剪后路径完整性验证
}
```

#### 2. 性能裁剪
```java
@Test
public void testPrune_Performance_10000Nodes() {
    // 10000节点的裁剪性能
}

@Test
public void testPrune_Complexity_WorstCase() {
    // 最坏情况复杂度验证
}
```

#### 3. 特殊场景
```java
@Test
public void testPrune_AllCritical() {
    // 所有节点都是关键节点
}

@Test
public void testPrune_NoCritical() {
    // 没有关键节点
}

@Test
public void testPrune_DisconnectedGraph() {
    // 断开的图结构
}
```

### ProcessChainIntegrationTest 新增测试（10个）

#### 1. 完整攻击场景
```java
@Test
public void testIntegration_FullAttackChain() {
    // 入侵 → 横向移动 → 数据窃取
}

@Test
public void testIntegration_MultiStageAttack() {
    // 多阶段攻击链
}

@Test
public void testIntegration_MultiVictim() {
    // 多受害者场景
}
```

#### 2. 系统压力测试
```java
@Test
public void testIntegration_HighConcurrency_100Requests() {
    // 100个并发请求
}

@Test
public void testIntegration_LargeData_10000Records() {
    // 10000条记录处理
}

@Test
public void testIntegration_LongRunning_1Hour() {
    // 长时间运行稳定性（1小时）
}
```

#### 3. 端到端场景
```java
@Test
public void testIntegration_E2E_RealESQuery() {
    // 真实 ES 查询（需要 Mock ES）
}

@Test
public void testIntegration_E2E_FullPipeline() {
    // 完整流程：查询 → 构建 → 合并 → 裁剪
}

@Test
public void testIntegration_E2E_ErrorRecovery() {
    // 错误恢复机制
}

@Test
public void testIntegration_E2E_DataValidation() {
    // 数据验证完整性
}
```

---

## 测试数据设计

### 1. 真实进程名
```
- powershell.exe
- cmd.exe
- wmic.exe
- vssadmin.exe
- bcdedit.exe
- reg.exe
- net.exe
- certutil.exe
- rundll32.exe
- regsvr32.exe
```

### 2. 真实攻击路径
```
C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
C:\Windows\System32\cmd.exe
C:\Windows\System32\wbem\wmic.exe
C:\ProgramData\malware\payload.exe
C:\Users\Public\Downloads\dropper.exe
```

### 3. 真实攻击命令
```
powershell.exe -enc <base64>
wmic process call create "cmd.exe"
vssadmin delete shadows /all /quiet
bcdedit /set {default} recoveryenabled no
reg add HKLM\Software\Microsoft\Windows\CurrentVersion\Run
```

---

## 实施计划

### 阶段1：核心测试增强（优先级：高）
- CoreLogicTest: 10个新测试
- DataStructureOptimizationTest: 8个新测试
- **预计时间**：2-3小时

### 阶段2：集成测试增强（优先级：高）
- SpringBootProcessChainTest: 12个新测试
- ProcessChainIntegrationTest: 10个新测试
- **预计时间**：3-4小时

### 阶段3：专项测试增强（优先级：中）
- ProcessChainMergeTest: 8个新测试
- ProcessChainPrunerTest: 8个新测试
- **预计时间**：2-3小时

### 总计
- **新增测试用例**：56个
- **总测试用例**：原有 + 56 = 100+个
- **预计总时间**：7-10小时

---

## 成功标准

1. **覆盖率**：代码覆盖率 > 90%
2. **稳定性**：所有测试通过率 100%
3. **性能**：所有性能测试在预期范围内
4. **可维护性**：测试代码清晰、注释完整

---

**创建时间**：2025-10-25  
**创建人员**：AI Assistant  
**状态**：📋 待实施

