# 进程链生成系统 - 详细说明文档

## 文档版本
版本：1.0.0  
更新时间：2025-10-21  
适用版本：Process Chain Generator v1.0.0

---

## 目录

1. [项目概述](#1-项目概述)
2. [系统架构](#2-系统架构)
3. [核心概念](#3-核心概念)
4. [数据模型详解](#4-数据模型详解)
5. [核心类详解](#5-核心类详解)
6. [函数详解](#6-函数详解)
7. [业务流程](#7-业务流程)
8. [配置说明](#8-配置说明)
9. [API 接口](#9-api-接口)
10. [使用示例](#10-使用示例)

---

## 1. 项目概述

### 1.1 项目简介

**进程链生成系统（Process Chain Generator）** 是一个基于 Spring Boot 的安全事件分析系统，用于从 Elasticsearch 中查询告警和日志数据，并构建完整的进程调用链路图。

### 1.2 核心功能

1. **进程链构建**：根据 traceId 向上追溯进程的父子关系，构建完整的进程树
2. **告警关联**：将告警信息关联到对应的进程节点
3. **实体转换**：将日志转换为不同类型的实体（进程、文件、网络、域名、注册表）
4. **根节点识别**：自动识别进程链的根节点（processGuid == traceId）
5. **断链处理**：检测并标记进程链中的断点，插入 Explore 节点
6. **网侧端侧合并**：将网络侧的攻击链路与端侧的进程链合并
7. **告警选举**：根据威胁等级和网端关联选择最佳告警

### 1.3 技术栈

- **后端框架**：Spring Boot 2.7.18
- **数据存储**：Elasticsearch 7.17.15
- **构建工具**：Maven 3.x
- **Java 版本**：JDK 1.8
- **日志框架**：SLF4J + Logback
- **代码简化**：Lombok

---

## 2. 系统架构

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                    REST API Layer                        │
│              (ProcessChainController)                    │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                   Service Layer                          │
│           (ProcessChainServiceImpl)                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │告警选举      │  │进程链构建    │  │网侧端侧合并  │  │
│  │AlarmElection │  │ChainBuilder  │  │MergeChain    │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│              Data Access Layer                           │
│         (OptimizedESQueryService)                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │批量查询告警  │  │批量查询日志  │  │字段过滤优化  │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                  Elasticsearch                           │
│           alarm_index  |  log_index                      │
└─────────────────────────────────────────────────────────┘
```

### 2.2 包结构

```
com.security.processchain
├── config/                     # 配置类
│   ├── ElasticsearchConfig     # ES 客户端配置
│   └── ProcessChainConfig      # 进程链业务配置
├── constants/                  # 常量定义
│   └── ProcessChainConstants   # 业务常量（日志类型、时间窗口等）
├── controller/                 # REST 控制器
│   └── ProcessChainController  # 进程链 API 接口
├── model/                      # 数据模型
│   ├── IpMappingRelation       # IP 映射关系
│   ├── ProcessEdge             # 进程链边
│   ├── ProcessNode             # 进程链节点
│   ├── RawAlarm                # 原始告警数据
│   └── RawLog                  # 原始日志数据
├── service/                    # 业务服务
│   ├── impl/
│   │   └── ProcessChainServiceImpl  # 进程链服务实现
│   ├── ProcessChainBuilder     # 进程链构建器
│   ├── IncidentConverters      # 数据转换器
│   ├── OptimizedESQueryService # ES 查询服务
│   ├── ESQueryService          # ES 查询接口
│   ├── NodeMapper              # 节点映射接口
│   ├── EdgeMapper              # 边映射接口
│   ├── IncidentProcessChain    # 事件进程链
│   ├── ChainNode               # 进程链节点详情
│   ├── StoryNode               # 故事线节点详情
│   ├── AlarmNodeInfo           # 告警节点信息
│   ├── ProcessEntity           # 进程实体
│   ├── FileEntity              # 文件实体
│   ├── NetworkEntity           # 网络实体
│   ├── DomainEntity            # 域名实体
│   ├── RegistryEntity          # 注册表实体
│   ├── NodeType                # 节点类型枚举
│   └── ThreatSeverity          # 威胁等级枚举
└── util/                       # 工具类
    ├── AlarmElectionUtil       # 告警选举工具
    ├── DataConverter           # 数据转换工具
    ├── Pair                    # 键值对工具
    └── TimeUtil                # 时间工具
```

---

## 3. 核心概念

### 3.1 进程链（Process Chain）

进程链是指通过父子进程关系连接起来的一系列进程节点。每个进程都有一个唯一的 `processGuid` 和一个 `parentProcessGuid`，通过这两个字段可以追溯进程的创建关系。

**示例**：
```
explorer.exe (根节点)
    └─> cmd.exe
        └─> powershell.exe
            └─> malware.exe (告警节点)
```

### 3.2 traceId

`traceId` 是事件追踪的核心标识符，通常等于告警节点的 `processGuid`。系统通过 `traceId` 查询所有相关的日志，并构建完整的进程链。

### 3.3 根节点（Root Node）

根节点是进程链的起点，满足条件：**processGuid == traceId**

特点：
- 没有父进程在日志中（或父进程不重要）
- 是整个攻击链路的起始点
- `ChainNode.isRoot = true`

### 3.4 断链（Broken Chain）

当进程的父节点在原始日志中不存在时，发生断链。系统会：
1. 标记该节点为断裂节点（`ChainNode.isBroken = true`）
2. 在该节点前插入一个 Explore 节点，表示需要进一步探索

### 3.5 网侧和端侧

- **端侧（Endpoint）**：安装了 EDR 的主机，能够收集详细的进程、文件、网络等日志
- **网侧（Network）**：网络设备（如防火墙、IDS）收集的网络流量和攻击行为数据

### 3.6 实体类型

系统支持 6 种实体类型：

1. **PROCESS**：进程节点（进程创建事件）
2. **FILE**：文件节点（文件创建、修改、删除）
3. **NETWORK**：网络节点（网络连接）
4. **DOMAIN**：域名节点（域名解析、访问）
5. **REGISTRY**：注册表节点（注册表修改）
6. **EXPLORE**：探索节点（断链占位符）

---

## 4. 数据模型详解

### 4.1 RawAlarm（原始告警）

**位置**：`com.security.processchain.model.RawAlarm`

**作用**：表示从 Elasticsearch 告警索引中查询出的原始告警数据。

**核心字段**：
```java
- eventId: String           // 告警事件ID（唯一标识）
- traceId: String           // 追踪ID（用于关联日志）
- hostAddress: String       // 主机IP地址
- processGuid: String       // 进程GUID
- parentProcessGuid: String // 父进程GUID
- alarmName: String         // 告警名称
- threatSeverity: String    // 威胁等级（高/中/低）
- startTime: String         // 告警开始时间
- endTime: String           // 告警结束时间
- alarmSource: String       // 告警来源
- logType: String           // 日志类型
- otherFields: Map          // 其他扩展字段
```

### 4.2 RawLog（原始日志）

**位置**：`com.security.processchain.model.RawLog`

**作用**：表示从 Elasticsearch 日志索引中查询出的原始日志数据。

**核心字段**：
```java
// 基础字段
- eventId: String
- traceId: String
- hostAddress: String
- processGuid: String
- parentProcessGuid: String
- logType: String           // 日志类型（process/file/network/domain/registry）
- startTime: String

// 进程相关字段
- eventType: String         // 事件类型（processCreate等）
- processName: String       // 进程名
- processId: String         // 进程ID
- image: String             // 进程映像路径
- commandLine: String       // 命令行参数
- processUserName: String   // 进程用户
- opType: String            // 操作类型

// 文件相关字段
- fileName: String          // 文件名
- filePath: String          // 文件路径
- fileMd5: String          // 文件MD5
- fileSize: String         // 文件大小
- fileType: String         // 文件类型
- targetFilename: String   // 目标文件名

// 网络相关字段
- transProtocol: String    // 传输协议
- srcAddress: String       // 源IP地址
- srcPort: String          // 源端口
- destAddress: String      // 目标IP地址
- destPort: String         // 目标端口
- initiated: String        // 是否主动发起

// 域名相关字段
- requestDomain: String    // 请求的域名
- queryResults: String     // 查询结果

// 注册表相关字段
- targetObject: String     // 注册表键路径
- regValue: String         // 注册表值

- otherFields: Map         // 其他扩展字段
```

### 4.3 ProcessNode（进程节点）

**位置**：`com.security.processchain.model.ProcessNode`

**作用**：最终返回给前端的进程链节点，可以是进程链节点或故事线节点。

**核心字段**：
```java
- nodeId: String            // 节点ID（进程GUID 或 故事节点ID）
- logType: NodeType         // 节点类型（PROCESS/FILE/NETWORK/DOMAIN/REGISTRY/EXPLORE）
- nodeThreatSeverity: ThreatSeverity  // 节点威胁等级
- isChainNode: Boolean      // 是否是进程链节点（true）或故事线节点（false）
- chainNode: ChainNode      // 进程链节点详情（当 isChainNode=true）
- storyNode: StoryNode      // 故事线节点详情（当 isChainNode=false）
```

### 4.4 ChainNode（进程链节点详情）

**位置**：`com.security.processchain.service.ChainNode`

**作用**：进程链节点的详细信息，包含告警、进程实体和其他实体。

**核心字段**：
```java
- isRoot: Boolean           // 是否是根节点
- isBroken: Boolean         // 是否是断裂节点
- isAlarm: Boolean          // 是否有告警
- alarmNodeInfo: AlarmNodeInfo      // 告警信息
- processEntity: ProcessEntity      // 进程实体（所有节点都有）
- entity: Object            // 其他实体（FileEntity/NetworkEntity/DomainEntity/RegistryEntity）
```

### 4.5 StoryNode（故事线节点详情）

**位置**：`com.security.processchain.service.StoryNode`

**作用**：网络侧的故事线节点，表示攻击者、受害者、服务器等角色。

**核心字段**：
```java
- type: String              // 节点类型（victim/attacker/server）
- other: Map<String, Object>  // 其他属性（ip, port, name 等）
```

### 4.6 ProcessEdge（进程链边）

**位置**：`com.security.processchain.model.ProcessEdge`

**作用**：表示进程链中两个节点之间的连接关系。

**核心字段**：
```java
- source: String            // 源节点ID
- target: String            // 目标节点ID
- val: String               // 边的标签/权重（可选）
```

### 4.7 实体类

#### 4.7.1 ProcessEntity（进程实体）
```java
- opType: String            // 操作类型
- localtime: String         // 本地时间
- processId: String         // 进程ID
- image: String             // 进程映像路径
- commandline: String       // 命令行
- processUserName: String   // 进程用户
- processName: String       // 进程名
```

#### 4.7.2 FileEntity（文件实体）
```java
- filePath: String          // 文件路径
- targetFilename: String    // 目标文件名
- fileSize: String          // 文件大小
- fileMd5: String          // 文件MD5
- fileType: String         // 文件类型
- fileName: String         // 文件名
```

#### 4.7.3 NetworkEntity（网络实体）
```java
- transProtocol: String    // 传输协议
- srcAddress: String       // 源IP
- srcPort: Integer         // 源端口
- destAddress: String      // 目标IP
- destPort: Integer        // 目标端口
- initiated: Boolean       // 是否主动发起
```

#### 4.7.4 DomainEntity（域名实体）
```java
- requestDomain: String    // 请求域名
- queryResults: String     // 查询结果（解析出的IP列表）
```

#### 4.7.5 RegistryEntity（注册表实体）
```java
- targetObject: String     // 注册表键路径
- regValue: String         // 注册表值
```

---

## 5. 核心类详解

### 5.1 ProcessChainServiceImpl

**位置**：`com.security.processchain.service.impl.ProcessChainServiceImpl`

**作用**：进程链服务的主实现类，负责协调整个进程链生成流程。

**核心职责**：
1. 批量查询告警数据
2. 告警选举（选择最佳 traceId）
3. 批量查询日志数据
4. 调用 ProcessChainBuilder 构建进程链
5. 构建 IP -> rootNodeId 映射
6. 合并网侧和端侧进程链

**依赖**：
- `OptimizedESQueryService`：ES 查询服务

---

### 5.2 ProcessChainBuilder

**位置**：`com.security.processchain.service.ProcessChainBuilder`

**作用**：进程链构建的核心类，负责从原始数据构建进程树结构。

**核心职责**：
1. 向上追溯进程父子关系
2. 识别根节点（processGuid == traceId）
3. 检测并标记断链节点
4. 插入 Explore 节点
5. 关联告警信息到节点
6. 转换为最终的 IncidentProcessChain

**内部类**：
- `ProcessChainResult`：构建结果容器
- `ChainBuilderNode`：构建器内部节点
- `ChainBuilderEdge`：构建器内部边

---

### 5.3 IncidentConverters

**位置**：`com.security.processchain.service.IncidentConverters`

**作用**：数据转换器，负责将内部构建数据转换为最终的业务模型。

**核心职责**：
1. 节点转换（Builder节点 -> ProcessNode）
2. 边转换（Builder边 -> ProcessEdge）
3. 实体转换（RawLog -> Entity）
4. 类型映射（logType -> NodeType）
5. 威胁等级映射（String -> ThreatSeverity）

**静态实例**：
- `NODE_MAPPER`：节点映射器
- `EDGE_MAPPER`：边映射器

---

### 5.4 OptimizedESQueryService

**位置**：`com.security.processchain.service.OptimizedESQueryService`

**作用**：优化的 ES 查询服务，使用批量查询和字段过滤提升性能。

**核心职责**：
1. 批量查询多个 IP 的告警
2. 批量查询多个 traceId 的日志
3. 使用 MultiSearchRequest 减少查询次数
4. 使用 fetchSource 过滤字段，减少数据传输
5. 使用 filter 查询上下文提升性能

---

### 5.5 ProcessChainController

**位置**：`com.security.processchain.controller.ProcessChainController`

**作用**：REST API 控制器，提供 HTTP 接口。

**核心接口**：
1. `/api/processchain/generate`：单个 IP 进程链生成
2. `/api/processchain/batch-generate`：批量进程链生成
3. `/api/processchain/merge-chain`：网侧端侧合并
4. `/api/processchain/health`：健康检查

---

## 6. 函数详解

### 6.1 ProcessChainServiceImpl 函数详解

#### 6.1.1 generateProcessChains
```java
public IncidentProcessChain generateProcessChains(
    IpMappingRelation ipMappingRelation,
    Pair<List<ProcessNode>, List<ProcessEdge>> networkChain)
```

**作用**：批量生成进程链，支持网侧端侧合并。

**参数**：
- `ipMappingRelation`：IP 映射关系，包含要查询的 IP 列表和网端关联信息
- `networkChain`：网侧进程链数据（可为 null），包含网侧节点和边

**返回**：合并后的完整进程链

**执行流程**：
1. **阶段1：选择告警**
   - 批量查询所有 IP 的告警数据
   - 对每个 IP 调用 `selectAlarm` 选择最佳 traceId
   - 收集所有选中的告警

2. **阶段2：批量查询日志**
   - 根据 host -> traceId 映射批量查询日志
   - 使用 MultiSearchRequest 提升性能

3. **阶段3：构建端侧进程链**
   - 调用 `ProcessChainBuilder.buildIncidentChain`
   - 传入所有告警和日志

4. **阶段4：构建 IP -> rootNodeId 映射**
   - 遍历生成的节点，找到所有根节点
   - 通过告警或 traceId 反查根节点对应的 IP
   - 存入映射表，用于后续桥接

5. **阶段5：合并网侧和端侧**
   - 如果没有网侧数据，直接返回端侧链
   - 否则调用 `mergeNetworkAndEndpointChain` 合并

**日志示例**：
```
【进程链生成】-> ========================================
【进程链生成】-> 开始批量生成进程链，IP数量: 3, 网端关联数: 1
【进程链生成】-> 批量告警查询完成，耗时: 150ms
【进程链生成】-> 选中 2 个告警: traceId=xxx, eventId=yyy
【进程链生成】-> 批量日志查询完成: 日志总数=156
【进程链生成】-> 根节点映射: IP=10.50.86.171, rootNodeId=ROOT_171_A1B2C3
【进程链生成】-> 端侧进程链生成完成
【进程链生成】-> ========================================
```

---

#### 6.1.2 selectAlarm
```java
private List<RawAlarm> selectAlarm(
    List<RawAlarm> alarms, 
    String associatedEventId, 
    boolean hasAssociation)
```

**作用**：从多个告警中选择最佳的 traceId，并返回该 traceId 对应的所有告警。

**参数**：
- `alarms`：该 IP 的所有告警列表
- `associatedEventId`：网端关联的告警 ID（可为 null）
- `hasAssociation`：是否有网端关联

**返回**：选中的 traceId 对应的所有告警列表

**选择策略**：
1. **优先级1：网端关联**
   - 如果 `hasAssociation = true` 且提供了 `associatedEventId`
   - 查找 eventId 匹配的告警，使用其 traceId

2. **优先级2：选举算法**
   - 如果没有网端关联或关联失败
   - 按 traceId 分组告警
   - 调用 `AlarmElectionUtil.electAlarm` 选举最佳 traceId
   - 选举规则：威胁等级高优先，同等级选告警数量多的

**示例**：
```java
// 场景1：有网端关联
输入：alarms=[{eventId:"E1", traceId:"T1"}, {eventId:"E2", traceId:"T2"}]
      associatedEventId="E1", hasAssociation=true
输出：[{eventId:"E1", traceId:"T1"}]  // 返回 T1 的所有告警

// 场景2：无网端关联，选举
输入：alarms=[{traceId:"T1", severity:"HIGH"}, {traceId:"T2", severity:"LOW"}]
      associatedEventId=null, hasAssociation=false
输出：T1 的所有告警  // HIGH > LOW
```

---

#### 6.1.3 isRootNode
```java
private boolean isRootNode(ProcessNode node)
```

**作用**：判断节点是否是根节点。

**参数**：
- `node`：要判断的节点

**返回**：`true` 如果是根节点，否则 `false`

**判断条件**：
```java
node.isChainNode == true 
AND node.chainNode != null 
AND node.chainNode.isRoot == true
```

---

#### 6.1.4 findIpForRootNode
```java
private String findIpForRootNode(
    ProcessNode rootNode, 
    Map<String, String> hostToTraceId,
    List<RawAlarm> allAlarms)
```

**作用**：查找根节点对应的 IP 地址。

**参数**：
- `rootNode`：根节点
- `hostToTraceId`：host 到 traceId 的映射
- `allAlarms`：所有告警列表

**返回**：根节点对应的 IP 地址，找不到返回 null

**查找策略**：
1. **方法1：通过告警匹配**
   - 遍历所有告警，查找 `processGuid == rootNodeId` 的告警
   - 返回告警的 `hostAddress`

2. **方法2：通过 traceId 反查**
   - 如果根节点的 `nodeId == traceId`（根节点特性）
   - 在 `hostToTraceId` 映射中反查对应的 IP

**示例**：
```java
// 方法1：通过告警
rootNodeId = "ROOT_171_A1B2C3"
allAlarms 中找到 alarm.processGuid == "ROOT_171_A1B2C3"
返回 alarm.hostAddress = "10.50.86.171"

// 方法2：通过 traceId
rootNodeId = "TRACE_123" (等于 traceId)
hostToTraceId = {"10.50.86.171" -> "TRACE_123"}
返回 "10.50.86.171"
```

---

#### 6.1.5 mergeNetworkAndEndpointChain
```java
private IncidentProcessChain mergeNetworkAndEndpointChain(
    Pair<List<ProcessNode>, List<ProcessEdge>> networkChain,
    IncidentProcessChain endpointChain,
    Map<String, String> ipToRootNodeIdMap)
```

**作用**：合并网侧和端侧进程链。

**参数**：
- `networkChain`：网侧进程链（节点和边）
- `endpointChain`：端侧进程链
- `ipToRootNodeIdMap`：IP 到端侧根节点 ID 的映射

**返回**：合并后的完整进程链

**执行流程**：
1. 创建新的进程链容器
2. 添加网侧节点（storyNode）
3. 添加端侧节点（chainNode）
4. 添加网侧边
5. 添加端侧边
6. **关键步骤**：调用 `createBridgeEdges` 创建桥接边
7. 设置基本信息（traceId, hostAddress, threatSeverity）

---

#### 6.1.6 createBridgeEdges
```java
private List<ProcessEdge> createBridgeEdges(
    List<ProcessNode> networkNodes,
    Map<String, String> ipToRootNodeIdMap)
```

**作用**：创建网侧到端侧的桥接边，连接 victim 节点和对应的端侧根节点。

**参数**：
- `networkNodes`：网侧节点列表
- `ipToRootNodeIdMap`：IP 到端侧根节点 ID 的映射

**返回**：桥接边列表

**执行流程**：
1. 遍历网侧节点
2. 筛选条件：
   - `isChainNode == false`（故事节点）
   - `storyNode != null`
   - `storyNode.type == "victim"`（受害者节点）
3. 从 `storyNode.other.ip` 提取 IP
4. 在 `ipToRootNodeIdMap` 中查找对应的根节点 ID
5. 如果找到，创建桥接边：
   ```java
   source = victim.nodeId
   target = rootNodeId
   val = ""
   ```

**示例**：
```
网侧 victim 节点：
  nodeId = "victim" 或 "10.50.86.171"
  storyNode.other.ip = "10.50.86.171"

映射表：
  ipToRootNodeIdMap = {"10.50.86.171" -> "ROOT_171_A1B2C3"}

创建桥接边：
  {source: "victim", target: "ROOT_171_A1B2C3", val: ""}
```

---

#### 6.1.7 extractIpFromStoryNode
```java
private String extractIpFromStoryNode(StoryNode storyNode)
```

**作用**：从故事节点中提取 IP 地址。

**参数**：
- `storyNode`：故事节点

**返回**：IP 地址，找不到返回 null

**提取逻辑**：
```java
从 storyNode.other.get("ip") 获取
trim() 去除空格
```

**统一说明**：
- 无论 `nodeId` 是 "victim" 还是 IP 地址
- 统一从 `storyNode.other.ip` 获取 IP
- 这样保证了数据来源的一致性

---

### 6.2 ProcessChainBuilder 函数详解

#### 6.2.1 buildIncidentChain
```java
public IncidentProcessChain buildIncidentChain(
    List<RawAlarm> alarms, 
    List<RawLog> logs,
    String traceId, 
    String associatedEventId,
    NodeMapper nodeMapper, 
    EdgeMapper edgeMapper)
```

**作用**：直接构建最终的 IncidentProcessChain，一步到位。

**参数**：
- `alarms`：告警列表
- `logs`：日志列表
- `traceId`：追踪 ID
- `associatedEventId`：关联事件 ID
- `nodeMapper`：节点映射器
- `edgeMapper`：边映射器

**返回**：完整的 IncidentProcessChain

**执行流程**：
1. 调用 `buildProcessChain` 构建内部结果
2. 转换节点：
   - 遍历内部节点
   - 使用 `nodeMapper` 转换为 ProcessNode
   - 设置 `isRoot` 和 `isBroken` 标志
3. 转换边：
   - 遍历内部边
   - 使用 `edgeMapper` 转换为 ProcessEdge
4. 添加 Explore 节点（如果有断链）
5. 设置基本信息
6. 返回最终结果

---

#### 6.2.2 buildProcessChain
```java
private ProcessChainResult buildProcessChain(
    List<RawAlarm> alarms, 
    List<RawLog> logs,
    String traceId, 
    String associatedEventId)
```

**作用**：构建进程链的核心方法，生成内部结果。

**参数**：
- `alarms`：告警列表
- `logs`：日志列表
- `traceId`：追踪 ID
- `associatedEventId`：关联事件 ID

**返回**：ProcessChainResult（内部结果）

**执行流程**：
1. **数据预处理**
   - 按 processGuid 分组日志
   - 按 processGuid 分组告警

2. **创建告警节点**
   - 遍历所有告警
   - 为每个 processGuid 创建节点
   - 关联告警信息到节点

3. **向上追溯**
   - 从告警节点开始
   - 调用 `traverseUpward` 递归追溯父节点
   - 构建完整的进程树

4. **补充非进程节点**
   - 添加文件、网络、域名、注册表节点

5. **返回结果**
   - 包含所有节点、边、根节点集合、断链节点集合

---

#### 6.2.3 traverseUpward
```java
private void traverseUpward(
    String currentProcessGuid,
    Map<String, List<RawLog>> logsByProcessGuid,
    String traceId,
    int depth)
```

**作用**：递归向上追溯进程的父子关系，构建进程树。

**参数**：
- `currentProcessGuid`：当前进程 GUID
- `logsByProcessGuid`：按 processGuid 分组的日志
- `traceId`：追踪 ID
- `depth`：当前递归深度

**执行流程**：
1. **深度检查**
   ```java
   if (depth > MAX_DEPTH) {
       log.warn("达到最大深度，停止追溯");
       return;
   }
   ```

2. **循环检测**
   ```java
   if (visitedNodesInPath.contains(currentProcessGuid)) {
       log.warn("检测到循环引用，停止追溯");
       return;
   }
   ```

3. **根节点检测**
   ```java
   if (currentProcessGuid.equals(traceId)) {
       foundRootNode = true;
       rootNodes.add(currentProcessGuid);
       log.info("找到根节点: processGuid={}", currentProcessGuid);
       return;
   }
   ```

4. **获取父进程 GUID**
   ```java
   String parentProcessGuid = currentNode.getParentProcessGuid();
   ```

5. **断链检测**
   ```java
   if (!logsByProcessGuid.containsKey(parentProcessGuid)) {
       brokenNodes.add(currentProcessGuid);
       log.warn("断链检测: 父节点 {} 不存在", parentProcessGuid);
       return;
   }
   ```

6. **创建父节点**
   - 如果父节点未访问，创建节点
   - 添加边：parent -> current

7. **递归追溯**
   ```java
   traverseUpward(parentProcessGuid, logsByProcessGuid, traceId, depth + 1);
   ```

**重要逻辑**：
- 使用 `visitedNodesInPath` 防止循环
- 找到根节点后立即返回
- 检测断链后立即返回（不再向上）
- 深度优先遍历（DFS）

---

#### 6.2.4 addExploreNodesForBrokenChains
```java
private void addExploreNodesForBrokenChains(
    List<ProcessNode> nodes,
    List<ProcessEdge> edges,
    Set<String> brokenNodeGuids,
    Set<String> rootNodeGuids)
```

**作用**：为断链节点添加 Explore 节点。

**参数**：
- `nodes`：节点列表
- `edges`：边列表
- `brokenNodeGuids`：断链节点 GUID 集合
- `rootNodeGuids`：根节点 GUID 集合

**执行流程**：
1. 遍历断链节点
2. 跳过已经是根节点的断链（不需要 Explore）
3. 为每个断链节点创建 Explore 节点：
   ```java
   nodeId = "EXPLORE_" + brokenNodeGuid
   logType = EXPLORE
   isChainNode = true
   chainNode.isRoot = false
   ```
4. 创建边：Explore -> 断链节点
5. 将 Explore 节点插入到节点列表开头

**示例**：
```
原结构：
  (断链) ProcessA -> ProcessB

添加后：
  EXPLORE_A -> ProcessA -> ProcessB
```

---

#### 6.2.5 pruneNodes
```java
private void pruneNodes()
```

**作用**：当节点数量超过 `MAX_NODE_COUNT` 限制时，裁剪低优先级节点。

**执行流程**：
1. 调用 `calculateNodeScores()` 计算所有节点的重要性分数
2. 按分数从高到低排序
3. 保留前 `MAX_NODE_COUNT` 个节点
4. 移除低分节点
5. 清理无效的边（source 或 target 被移除的边）

**触发条件**：
```java
if (nodeMap.size() > MAX_NODE_COUNT) {
    log.warn("节点数量({})超过限制({}),开始裁剪...", nodeMap.size(), MAX_NODE_COUNT);
    pruneNodes();
}
```

**裁剪策略**：
- 优先保留网端关联成功的告警节点
- 优先保留高危告警节点及其相关节点
- 保留根节点和关键中间节点
- 最后考虑低危和非告警节点

---

#### 6.2.6 calculateNodeScores
```java
private Map<String, Integer> calculateNodeScores()
```

**作用**：计算每个节点的重要性分数，用于进程链裁剪时的节点优先级排序。

**返回**：`Map<processGuid, score>`，分数越高表示节点越重要。

**评分规则详解**：

##### 1. 网端关联成功的告警节点：+1000分 ⭐⭐⭐

**条件**：
- 节点是告警节点（`node.getIsAlarm() == true`）
- 且告警的 `eventId` 在 `associatedEventIds` 集合中

**代码**：
```java
if (node.getIsAlarm()) {
    for (RawAlarm alarm : node.getAlarms()) {
        if (associatedEventIds.contains(alarm.getEventId())) {
            score += 1000;
            break;
        }
    }
}
```

**说明**：这是最高优先级，表示该节点是网侧和端侧成功关联的关键节点，在攻击链路分析中至关重要。

---

##### 2. 告警节点（按威胁等级）：+20 ~ +100分 ⭐⭐⭐

**条件**：节点是告警节点（`node.getIsAlarm() == true`）

**分值**：根据威胁等级不同

| 威胁等级 | 判断条件 | 分值 | 说明 |
|---------|---------|------|------|
| **高危 (HIGH)** | `isHighSeverity(severity)` | **+100分** | 严重威胁，必须重点关注 |
| **中危 (MEDIUM)** | `isMediumSeverity(severity)` | **+50分** | 中等威胁，需要关注 |
| **低危 (LOW)** | 其他情况 | **+20分** | 低等威胁，较低优先级 |

**代码**：
```java
if (node.getIsAlarm()) {
    for (RawAlarm alarm : node.getAlarms()) {
        String severity = alarm.getThreatSeverity();
        if (isHighSeverity(severity)) {
            score += 100; // 高危: +100分
        } else if (isMediumSeverity(severity)) {
            score += 50;  // 中危: +50分
        } else {
            score += 20;  // 低危: +20分
        }
    }
}
```

**说明**：
- 一个节点可能有多个告警，每个告警都会累加分数
- 高危告警通常代表严重的安全事件，如恶意进程、命令执行、勒索软件等

---

##### 3. 根节点：+80分 ⭐⭐

**条件**：`rootNodes.contains(processGuid)`

**代码**：
```java
if (rootNodes.contains(processGuid)) {
    score += 80;
}
```

**说明**：
- 根节点是进程链的起点（`processGuid == traceId`）
- 在攻击链分析中，根节点通常代表攻击的初始入口或最顶层进程
- 具有很高的分析价值

---

##### 4. 节点连接数（度中心性）：+2/连接，最多+30分 ⭐⭐

**条件**：统计该节点在边中出现的次数（作为 source 或 target）

**代码**：
```java
int connectionCount = 0;
for (ChainBuilderEdge edge : edges) {
    if (edge.getSource().equals(processGuid) || edge.getTarget().equals(processGuid)) {
        connectionCount++;
    }
}
score += Math.min(connectionCount * 2, 30); // 最多+30分
```

**分值计算表**：

| 连接数 | 计算 | 实际分值 | 节点类型 |
|--------|------|---------|---------|
| 1条边 | 1 × 2 | +2分 | 叶子节点 |
| 5条边 | 5 × 2 | +10分 | 一般节点 |
| 10条边 | 10 × 2 | +20分 | 重要节点 |
| 15条边 | 15 × 2 | +30分（上限） | 核心节点 |
| 20条边+ | 20 × 2 | +30分（上限） | 超级节点 |

**说明**：
- 连接数多的节点通常是关键的中间节点
- 可能是父进程启动了多个子进程，或者进程进行了多次操作
- 设置上限避免某些系统进程（如 svchost.exe）权重过高

---

##### 5. 有日志数据的节点：+10分 ⭐

**条件**：`!node.getLogs().isEmpty()`

**代码**：
```java
if (!node.getLogs().isEmpty()) {
    score += 10;
}
```

**说明**：
- 有日志数据表示节点有实际的操作记录
- 比只有告警信息的节点更有分析价值
- 日志包含详细的进程、文件、网络等信息

---

##### 6. process 类型的节点：+5分 ⭐

**条件**：节点的日志中包含 `logType == "process"` 的记录

**代码**：
```java
boolean hasProcessLog = false;
for (RawLog log : node.getLogs()) {
    if ("process".equalsIgnoreCase(log.getLogType())) {
        hasProcessLog = true;
        break;
    }
}
if (hasProcessLog) {
    score += 5;
}
```

**说明**：
- process 类型是进程链的核心节点类型
- 优先级高于 file、network、domain、registry 等其他类型
- 进程节点能展示完整的进程树结构

---

#### 评分规则优先级总结

| 优先级 | 评分项 | 条件 | 分值 | 适用场景 |
|--------|--------|------|------|---------|
| 🥇 **1** | 网端关联告警 | 告警节点 + eventId 在 associatedEventIds | **+1000** | 网侧端侧关联的关键节点 |
| 🥈 **2** | 高危告警 | 告警节点 + severity=HIGH | **+100** | 严重安全威胁 |
| 🥈 **2** | 根节点 | processGuid 在 rootNodes | **+80** | 进程链起点/攻击入口 |
| 🥉 **3** | 中危告警 | 告警节点 + severity=MEDIUM | **+50** | 中等安全威胁 |
| 4 | 节点连接数 | 边中出现次数 | **+2/连接，最多+30** | 关键中间节点/核心节点 |
| 5 | 低危告警 | 告警节点 + severity=LOW | **+20** | 低等安全威胁 |
| 6 | 有日志数据 | logs 列表不为空 | **+10** | 有实际操作记录 |
| 7 | process 类型 | logType=process | **+5** | 进程类型节点 |

---

#### 实际评分示例

##### 示例1：网端关联的高危告警根节点

```java
ChainBuilderNode node = new ChainBuilderNode();
node.setProcessGuid("ROOT-123");

// 添加高危告警（网端关联）
RawAlarm alarm = new RawAlarm();
alarm.setEventId("EVENT-001");  // 在 associatedEventIds 中
alarm.setThreatSeverity("HIGH");
node.addAlarm(alarm);

// 添加进程日志
node.addLog(new RawLog() {{ setLogType("process"); }});

// 假设：该节点是根节点且有5个连接
```

**评分计算**：
```
网端关联告警:    +1000
高危告警:        +100
根节点:          +80
节点连接数(5):   +10  (5 × 2)
有日志数据:      +10
process类型:     +5
─────────────────────
总分:            1205分  ✅ 最高优先级保留
```

---

##### 示例2：普通进程节点（非告警）

```java
ChainBuilderNode node = new ChainBuilderNode();
node.setProcessGuid("NORMAL-456");

// 只有日志，没有告警
node.addLog(new RawLog() {{ setLogType("process"); }});

// 假设：该节点有2个连接
```

**评分计算**：
```
网端关联告警:    0      (不是告警节点)
告警等级:        0      (不是告警节点)
根节点:          0      (不是根节点)
节点连接数(2):   +4     (2 × 2)
有日志数据:      +10
process类型:     +5
─────────────────────
总分:            19分   ⚠️ 可能被裁剪
```

---

##### 示例3：中危告警节点（非根节点）

```java
ChainBuilderNode node = new ChainBuilderNode();
node.setProcessGuid("MEDIUM-789");

// 添加中危告警（非网端关联）
RawAlarm alarm = new RawAlarm();
alarm.setEventId("EVENT-002");  // 不在 associatedEventIds 中
alarm.setThreatSeverity("MEDIUM");
node.addAlarm(alarm);

// 添加文件日志
node.addLog(new RawLog() {{ setLogType("file"); }});

// 假设：该节点有10个连接
```

**评分计算**：
```
网端关联告警:    0      (eventId 不在关联列表中)
中危告警:        +50
根节点:          0      (不是根节点)
节点连接数(10):  +20    (10 × 2)
有日志数据:      +10
process类型:     0      (是 file 类型)
─────────────────────
总分:            80分   ✅ 可能保留
```

---

#### 分数区间参考

| 分数区间 | 节点类型 | 保留概率 | 典型场景 |
|---------|---------|---------|---------|
| **1000+** | 网端关联告警节点 | ✅✅✅ 100% 保留 | 关联成功的高危攻击节点 |
| **150-300** | 高危告警 + 根节点 + 多连接 | ✅✅ 极大概率保留 | 高危攻击入口 + 核心节点 |
| **80-150** | 根节点 + 中危告警 | ✅ 大概率保留 | 进程树根节点、中危事件 |
| **50-80** | 中危告警 或 低危告警 + 多连接 | ⚠️ 可能保留 | 中等威胁或重要中间节点 |
| **20-50** | 低危告警 或 普通节点 + 多连接 | ⚠️ 看节点总数 | 低危事件或一般中间节点 |
| **0-20** | 普通日志节点 | ❌ 优先被裁剪 | 叶子节点、辅助节点 |

---

#### 裁剪后的影响

**保留的节点**：
- 所有网端关联的告警节点 ✅
- 所有高危告警节点 ✅
- 所有根节点 ✅
- 关键的中间节点（连接数多） ✅
- 部分中低危告警节点 ⚠️

**可能被移除的节点**：
- 叶子节点（连接数为1）❌
- 非告警的普通日志节点 ❌
- 低危告警且连接数少的节点 ❌
- 辅助性的文件、注册表节点 ❌

**边的处理**：
- 如果边的 source 或 target 被移除，该边也会被删除
- 确保最终图结构的完整性和一致性

---

### 6.3 IncidentConverters 函数详解

#### 6.3.1 NODE_MAPPER
```java
public static final NodeMapper NODE_MAPPER = builderNode -> { ... }
```

**作用**：将内部的 ChainBuilderNode 转换为最终的 ProcessNode。

**转换逻辑**：

1. **创建 ProcessNode**
   ```java
   ProcessNode finalNode = new ProcessNode();
   finalNode.setNodeId(builderNode.getProcessGuid());
   finalNode.setIsChainNode(true);
   ```

2. **创建 ChainNode**
   ```java
   ChainNode chainNode = new ChainNode();
   ```

3. **设置告警信息**
   ```java
   if (builderNode.getAlarms() != null && !builderNode.getAlarms().isEmpty()) {
       chainNode.setIsAlarm(true);
       RawAlarm latestAlarm = getLatestAlarm(alarms);
       chainNode.setAlarmNodeInfo(convertToAlarmNodeInfo(latestAlarm));
       finalNode.setNodeThreatSeverity(mapToThreatSeverity(...));
   }
   ```

4. **设置日志实体**
   ```java
   RawLog latestLog = getLatestLog(logs);
   finalNode.setLogType(mapToNodeType(latestLog.getLogType()));
   
   // 设置其他实体
   Object entity = convertToEntity(latestLog, latestLog.getLogType());
   chainNode.setEntity(entity);
   
   // 设置进程实体
   chainNode.setProcessEntity(convertToProcessEntity(latestLog, entity));
   ```

5. **组装返回**
   ```java
   finalNode.setChainNode(chainNode);
   finalNode.setStoryNode(null);
   return finalNode;
   ```

**重要说明**：
- `isRoot` 和 `isBroken` 在 `buildIncidentChain` 中设置，不在这里设置
- 所有类型的节点都会尝试设置 `processEntity`
- `entity` 根据 `logType` 设置为不同类型

---

#### 6.3.2 convertToProcessEntity
```java
private static ProcessEntity convertToProcessEntity(RawLog log, Object entity)
```

**作用**：将原始日志转换为 ProcessEntity。

**参数**：
- `log`：原始日志
- `entity`：对应类型的实体（FileEntity/NetworkEntity 等）

**返回**：ProcessEntity 或 null

**转换条件**：

**情况1：进程节点** (`logType = process`)
```java
条件：
  log.logType == "process" 
  AND log.eventType == "processCreate"
  AND (log.processName != null OR log.image != null)

结果：构建 ProcessEntity
```

**情况2：其他节点** (`logType = file/network/domain/registry`)
```java
条件：
  entity != null  // 对应类型的实体能构建
  AND (log.processName != null OR log.image != null)

结果：构建 ProcessEntity
```

**核心思想**：
- 进程节点：严格检查 `eventType = processCreate`
- 其他节点：只要对应实体能构建，就构建 ProcessEntity
- 因为所有操作（文件、网络、域名、注册表）都是由进程发起的

**示例**：
```java
// 情况1：进程节点
log.logType = "process"
log.eventType = "processCreate"
log.processName = "cmd.exe"
entity = null
→ 返回 ProcessEntity{processName: "cmd.exe", ...}

// 情况2：文件节点
log.logType = "file"
log.processName = "powershell.exe"
entity = FileEntity{fileName: "malware.exe"}  // 不为 null
→ 返回 ProcessEntity{processName: "powershell.exe", ...}
→ 表示是 powershell.exe 创建的文件

// 情况3：文件节点但不满足条件
log.logType = "file"
log.opType = "read"  // 不是 create/write/delete
entity = null  // FileEntity 构建失败
→ 返回 null
→ 不创建 ProcessEntity
```

---

#### 6.3.3 convertToEntity
```java
private static Object convertToEntity(RawLog log, String logType)
```

**作用**：根据 logType 将日志转换为对应类型的实体。

**参数**：
- `log`：原始日志
- `logType`：日志类型

**返回**：具体类型的实体或 null

**转换规则**：
```java
switch (logType.toLowerCase()) {
    case "file":
        return convertToFileEntity(log);      // 文件实体
    case "network":
        return convertToNetworkEntity(log);   // 网络实体
    case "domain":
        return convertToDomainEntity(log);    // 域名实体
    case "registry":
        return convertToRegistryEntity(log);  // 注册表实体
    case "process":
        return null;  // 进程节点的 entity 为 null
    default:
        return null;
}
```

---

#### 6.3.4 convertToFileEntity
```java
private static FileEntity convertToFileEntity(RawLog log)
```

**作用**：将日志转换为文件实体。

**非null条件**：
```java
log.logType == "file"
AND log.opType in ["create", "write", "delete"]
```

**字段映射**：
```java
FileEntity entity = new FileEntity();
entity.setFilePath(log.getFilePath());
entity.setTargetFilename(log.getTargetFilename());
entity.setFileSize(log.getFileSize());
entity.setFileMd5(log.getFileMd5());
entity.setFileType(log.getFileType());
entity.setFileName(log.getFileName());
```

**不满足条件时**：返回 null

---

#### 6.3.5 convertToNetworkEntity
```java
private static NetworkEntity convertToNetworkEntity(RawLog log)
```

**作用**：将日志转换为网络实体。

**非null条件**：
```java
log.logType == "network"
AND log.opType == "connect"
```

**字段映射**：
```java
NetworkEntity entity = new NetworkEntity();
entity.setTransProtocol(log.getTransProtocol());
entity.setSrcAddress(log.getSrcAddress());
entity.setSrcPort(parseSrcPort(log.getSrcPort()));
entity.setDestAddress(log.getDestAddress());
entity.setDestPort(parseDestPort(log.getDestPort()));
entity.setInitiated(parseInitiated(log.getInitiated()));
```

---

#### 6.3.6 convertToDomainEntity
```java
private static DomainEntity convertToDomainEntity(RawLog log)
```

**作用**：将日志转换为域名实体。

**非null条件**：
```java
log.logType == "domain"
AND log.opType == "connect"
```

**字段映射**：
```java
DomainEntity entity = new DomainEntity();
entity.setRequestDomain(log.getRequestDomain());
entity.setQueryResults(log.getQueryResults());
```

---

#### 6.3.7 convertToRegistryEntity
```java
private static RegistryEntity convertToRegistryEntity(RawLog log)
```

**作用**：将日志转换为注册表实体。

**非null条件**：
```java
log.logType == "registry"
AND log.opType == "setValue"
```

**字段映射**：
```java
RegistryEntity entity = new RegistryEntity();
entity.setTargetObject(log.getTargetObject());
entity.setRegValue(log.getRegValue());
```

---

#### 6.3.8 mapToNodeType
```java
public static NodeType mapToNodeType(String logType)
```

**作用**：将字符串类型映射为 NodeType 枚举。

**映射规则**：
```java
"process"  -> NodeType.PROCESS
"file"     -> NodeType.FILE
"network"  -> NodeType.NETWORK
"domain"   -> NodeType.DOMAIN
"registry" -> NodeType.REGISTRY
其他       -> NodeType.UNKNOWN
```

---

#### 6.3.9 mapToThreatSeverity
```java
public static ThreatSeverity mapToThreatSeverity(String severity)
```

**作用**：将字符串威胁等级映射为 ThreatSeverity 枚举。

**映射规则**（支持中英文）：
```java
"高" / "HIGH"   -> ThreatSeverity.HIGH
"中" / "MEDIUM" -> ThreatSeverity.MEDIUM
"低" / "LOW"    -> ThreatSeverity.LOW
其他           -> ThreatSeverity.UNKNOWN
```

---

### 6.4 OptimizedESQueryService 函数详解

#### 6.4.1 batchQueryEDRAlarms
```java
public Map<String, List<RawAlarm>> batchQueryEDRAlarms(List<String> ips)
```

**作用**：批量查询多个 IP 的 EDR 告警数据。

**参数**：
- `ips`：IP 地址列表

**返回**：Map<IP, 告警列表>

**优化策略**：
1. **使用 MultiSearchRequest**
   ```java
   MultiSearchRequest multiRequest = new MultiSearchRequest();
   for (String ip : ips) {
       SearchRequest request = buildAlarmRequest(ip);
       multiRequest.add(request);
   }
   ```

2. **字段过滤**
   ```java
   searchSourceBuilder.fetchSource(ALARM_INCLUDES, null);
   ```
   只返回需要的字段，减少数据传输

3. **Filter 查询上下文**
   ```java
   BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()
       .filter(QueryBuilders.termQuery("hostAddress", ip))
       .filter(QueryBuilders.termQuery("alarmSource", "EDR"));
   ```
   使用 filter 而不是 must，利用缓存提升性能

**ALARM_INCLUDES 字段**：
```java
"eventId", "traceId", "hostAddress", "processGuid", 
"parentProcessGuid", "alarmName", "threatSeverity", 
"startTime", "endTime", "alarmSource", "logType", "otherFields"
```

---

#### 6.4.2 batchQueryRawLogs
```java
public List<RawLog> batchQueryRawLogs(Map<String, String> hostToTraceId)
```

**作用**：批量查询多个 host-traceId 对的日志数据。

**参数**：
- `hostToTraceId`：Map<host, traceId>

**返回**：所有查询到的日志列表

**优化策略**：
1. **使用 MultiSearchRequest**
   - 为每个 host-traceId 对创建一个查询
   - 一次性发送所有查询

2. **字段过滤**
   ```java
   searchSourceBuilder.fetchSource(LOG_INCLUDES, null);
   ```

3. **Filter 查询**
   ```java
   BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()
       .filter(QueryBuilders.termQuery("hostAddress", host))
       .filter(QueryBuilders.termQuery("traceId", traceId))
       .filter(QueryBuilders.termsQuery("logType", logTypes));
   ```

**LOG_INCLUDES 字段**：
```java
"traceId", "hostAddress", "processGuid", "parentProcessGuid", 
"logType", "eventType", "opType", "startTime", "endTime", 
"processName", "processPath", "commandLine", "fileName", 
"filePath", "fileSize", "targetFilename", "fileMd5", "fileType",
"sourceIp", "sourcePort", "destIp", "destPort", "domainName",
"requestDomain", "queryResults", "targetObject", "regValue", "otherFields"
```

---

### 6.5 AlarmElectionUtil 函数详解

#### 6.5.1 electAlarm
```java
public static String electAlarm(Map<String, List<RawAlarm>> alarmGroups)
```

**作用**：从多个告警组中选举出最佳的 traceId。

**参数**：
- `alarmGroups`：Map<traceId, 告警列表>

**返回**：最佳的 traceId

**选举规则**：
1. **优先级1：威胁等级**
   - HIGH > MEDIUM > LOW > UNKNOWN
   - 选择威胁等级最高的组

2. **优先级2：告警数量**
   - 在同等级的组中，选择告警数量最多的
   - 数量多说明该 traceId 的活动更频繁

**示例**：
```java
输入：
  alarmGroups = {
    "T1" -> [HIGH, HIGH, MEDIUM],    // 3个告警，最高HIGH
    "T2" -> [MEDIUM, MEDIUM, LOW],   // 3个告警，最高MEDIUM
    "T3" -> [HIGH, MEDIUM]           // 2个告警，最高HIGH
  }

选举过程：
  1. 最高等级是 HIGH，筛选出 T1 和 T3
  2. T1 有 3 个告警，T3 有 2 个告警
  3. 选择 T1（数量多）

输出："T1"
```

---

## 7. 业务流程

### 7.1 单个 IP 进程链生成流程

```
开始
  │
  ▼
查询告警
  │
  ▼
选择最佳 traceId（网端关联 或 选举算法）
  │
  ▼
查询日志（根据 traceId、host、时间窗口）
  │
  ▼
构建进程链
  ├─> 创建告警节点
  ├─> 向上追溯父进程
  ├─> 识别根节点和断链
  └─> 补充非进程节点
  │
  ▼
转换数据模型
  ├─> 节点转换
  ├─> 边转换
  ├─> 实体转换
  └─> 添加 Explore 节点
  │
  ▼
返回 IncidentProcessChain
  │
  ▼
结束
```

### 7.2 批量 IP 进程链生成流程

```
开始
  │
  ▼
批量查询所有 IP 的告警
  │
  ▼
for each IP:
  └─> 选择最佳 traceId
  └─> 收集所有选中的告警
  │
  ▼
构建 host -> traceId 映射
  │
  ▼
批量查询所有日志
  │
  ▼
构建端侧进程链
  │
  ▼
构建 IP -> rootNodeId 映射
  ├─> 遍历生成的节点
  ├─> 识别根节点
  └─> 通过告警反查 IP
  │
  ▼
如果有网侧数据？
  │
  ├─> 是：合并网侧和端侧
  │   ├─> 添加网侧节点和边
  │   ├─> 添加端侧节点和边
  │   ├─> 识别 victim 节点
  │   ├─> 提取 victim IP
  │   ├─> 查找对应的根节点
  │   └─> 创建桥接边
  │
  └─> 否：直接返回端侧链
  │
  ▼
返回合并后的 IncidentProcessChain
  │
  ▼
结束
```

### 7.3 向上追溯流程

```
traverseUpward(currentGuid, depth)
  │
  ▼
检查深度和循环
  │
  ▼
currentGuid == traceId？
  │
  ├─> 是：标记为根节点，返回
  │
  └─> 否：继续
      │
      ▼
获取父进程 GUID
      │
      ▼
父进程存在于日志中？
      │
      ├─> 否：标记为断链节点，返回
      │
      └─> 是：继续
          │
          ▼
创建父节点（如果未创建）
          │
          ▼
添加边：parent -> current
          │
          ▼
递归：traverseUpward(parentGuid, depth+1)
```

### 7.4 实体转换流程

```
convertToProcessEntity(log, entity)
  │
  ▼
检查是否有进程信息（processName 或 image）
  │
  ├─> 否：返回 null
  │
  └─> 是：继续
      │
      ▼
logType == "process"？
      │
      ├─> 是：检查 eventType == "processCreate"
      │   ├─> 是：构建 ProcessEntity
      │   └─> 否：返回 null
      │
      └─> 否：检查 entity != null
          ├─> 是：构建 ProcessEntity
          └─> 否：返回 null
```

---

## 8. 配置说明

### 8.1 application.yml

```yaml
# 服务器配置
server:
  port: 8080                              # 服务端口

# Spring Boot 配置
spring:
  application:
    name: process-chain-generator         # 应用名称

# Elasticsearch 配置
elasticsearch:
  hosts: localhost:9200                   # ES 集群地址
  username:                               # ES 用户名（可选）
  password:                               # ES 密码（可选）
  connection-timeout: 5000                # 连接超时（毫秒）
  socket-timeout: 60000                   # Socket 超时（毫秒）
  connection-request-timeout: 5000        # 连接请求超时（毫秒）
  max-retry-timeout: 60000                # 最大重试超时（毫秒）

# 进程链配置
process-chain:
  alarm-index: alarm_index                # 告警索引名
  log-index: log_index                    # 日志索引名
  max-traversal-depth: 50                 # 最大遍历深度
  max-node-count: 400                     # 最大节点数
  batch-query-size: 100                   # 批量查询大小
  max-query-size: 10000                   # ES 查询最大返回数

# 日志配置
logging:
  level:
    com.security.processchain: INFO       # 业务日志级别
    org.elasticsearch: WARN               # ES 客户端日志级别
  pattern:
    console: '%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{50} - %msg%n'
```

### 8.2 配置说明

#### Elasticsearch 配置

| 参数 | 说明 | 默认值 | 建议 |
|------|------|--------|------|
| hosts | ES 集群地址 | localhost:9200 | 生产环境配置多个节点 |
| username | 认证用户名 | 空 | 启用认证时必填 |
| password | 认证密码 | 空 | 启用认证时必填 |
| connection-timeout | 连接超时 | 5000ms | 根据网络情况调整 |
| socket-timeout | Socket 超时 | 60000ms | 大数据量查询时增大 |

#### 进程链配置

| 参数 | 说明 | 默认值 | 建议 |
|------|------|--------|------|
| alarm-index | 告警索引 | alarm_index | 根据实际索引名修改 |
| log-index | 日志索引 | log_index | 根据实际索引名修改 |
| max-traversal-depth | 最大遍历深度 | 50 | 防止深度过大导致栈溢出 |
| max-node-count | 最大节点数 | 400 | 防止节点过多占用内存 |
| max-query-size | ES 查询限制 | 10000 | 根据数据量调整 |

---

## 9. API 接口

### 9.1 单个 IP 进程链生成

**接口**：`GET /api/processchain/generate`

**参数**：
- `ip`（必填）：IP 地址
- `associatedEventId`（可选）：关联的告警事件 ID
- `hasAssociation`（可选）：是否有网端关联，默认 false

**请求示例**：
```
GET http://localhost:8080/api/processchain/generate?ip=10.50.86.197&associatedEventId=E123&hasAssociation=true
```

**响应示例**：
```json
{
  "traceId": "T123",
  "hostAddress": "10.50.86.197",
  "threatSeverity": "HIGH",
  "nodes": [
    {
      "nodeId": "GUID_123",
      "logType": "PROCESS",
      "nodeThreatSeverity": "HIGH",
      "isChainNode": true,
      "chainNode": {
        "isRoot": true,
        "isBroken": false,
        "isAlarm": true,
        "alarmNodeInfo": { ... },
        "processEntity": { ... },
        "entity": null
      },
      "storyNode": null
    }
  ],
  "edges": [
    {
      "source": "GUID_123",
      "target": "GUID_456",
      "val": ""
    }
  ]
}
```

---

### 9.2 批量进程链生成（仅端侧）

**接口**：`POST /api/processchain/batch-generate`

**请求体**：
```json
{
  "ipAndAssociation": {
    "10.50.86.171": {
      "hasAssociation": true,
      "associatedEventId": "E001",
      "logId": null
    },
    "10.50.86.52": {
      "hasAssociation": false,
      "associatedEventId": null,
      "logId": null
    }
  }
}
```

**响应**：与单个 IP 接口相同，但包含所有 IP 的合并进程链

---

### 9.3 网侧端侧合并

**接口**：`POST /api/processchain/merge-chain`

**请求体**：
```json
{
  "ipMappingRelation": {
    "ipAndAssociation": {
      "10.50.86.171": {
        "hasAssociation": true,
        "associatedEventId": "E001"
      }
    }
  },
  "networkNodes": [
    {
      "nodeId": "victim",
      "logType": "UNKNOWN",
      "isChainNode": false,
      "storyNode": {
        "type": "victim",
        "other": {
          "ip": "10.50.86.171",
          "port": "22",
          "isEdr": true
        }
      }
    },
    {
      "nodeId": "attacker",
      "logType": "UNKNOWN",
      "isChainNode": false,
      "storyNode": {
        "type": "attacker",
        "other": {
          "name": "攻击者",
          "ips": ["192.168.1.100"]
        }
      }
    }
  ],
  "networkEdges": [
    {
      "source": "attacker",
      "target": "victim",
      "val": "攻击"
    }
  ]
}
```

**响应**：合并后的完整进程链，包含：
- 网侧节点（victim, attacker）
- 端侧节点（进程链）
- 桥接边（victim -> 端侧根节点）

---

### 9.4 健康检查

**接口**：`GET /api/processchain/health`

**响应**：
```json
{
  "status": "UP",
  "service": "Process Chain Generator"
}
```

---

## 10. 使用示例

### 10.1 基础使用

```java
// 1. 单个 IP 进程链生成
String ip = "10.50.86.197";
String associatedEventId = "E123";
boolean hasAssociation = true;

IncidentProcessChain chain = processChainService.generateProcessChainForIp(
    ip, associatedEventId, hasAssociation
);

// 2. 访问结果
List<ProcessNode> nodes = chain.getNodes();
List<ProcessEdge> edges = chain.getEdges();

for (ProcessNode node : nodes) {
    if (node.getIsChainNode()) {
        ChainNode chainNode = node.getChainNode();
        if (chainNode.getIsAlarm()) {
            System.out.println("告警节点: " + node.getNodeId());
        }
        if (chainNode.getIsRoot()) {
            System.out.println("根节点: " + node.getNodeId());
        }
    }
}
```

### 10.2 批量使用

```java
// 构建 IP 映射关系
IpMappingRelation ipMapping = new IpMappingRelation();
Map<String, IpMappingRelation.IpAssociationInfo> map = new HashMap<>();

// 添加第一个 IP（有网端关联）
IpMappingRelation.IpAssociationInfo info1 = new IpMappingRelation.IpAssociationInfo();
info1.setHasAssociation(true);
info1.setAssociatedEventId("E001");
map.put("10.50.86.171", info1);

// 添加第二个 IP（无网端关联）
IpMappingRelation.IpAssociationInfo info2 = new IpMappingRelation.IpAssociationInfo();
info2.setHasAssociation(false);
map.put("10.50.86.52", info2);

ipMapping.setIpAndAssociation(map);

// 生成批量进程链
IncidentProcessChain chain = processChainService.generateProcessChains(
    ipMapping, 
    null  // 不合并网侧数据
);
```

### 10.3 网侧端侧合并

```java
// 1. 准备网侧数据
List<ProcessNode> networkNodes = new ArrayList<>();
List<ProcessEdge> networkEdges = new ArrayList<>();

// 添加 victim 节点
ProcessNode victimNode = new ProcessNode();
victimNode.setNodeId("victim");
victimNode.setIsChainNode(false);

StoryNode storyNode = new StoryNode();
storyNode.setType("victim");
Map<String, Object> other = new HashMap<>();
other.put("ip", "10.50.86.171");
other.put("port", "22");
other.put("isEdr", true);
storyNode.setOther(other);

victimNode.setStoryNode(storyNode);
networkNodes.add(victimNode);

// 2. 准备端侧数据
IpMappingRelation ipMapping = new IpMappingRelation();
// ... 设置 IP 映射 ...

// 3. 合并
Pair<List<ProcessNode>, List<ProcessEdge>> networkChain = 
    Pair.of(networkNodes, networkEdges);

IncidentProcessChain mergedChain = processChainService.generateProcessChains(
    ipMapping, 
    networkChain
);

// 4. 验证桥接边
for (ProcessEdge edge : mergedChain.getEdges()) {
    if ("victim".equals(edge.getSource())) {
        System.out.println("桥接边: victim -> " + edge.getTarget());
    }
}
```

---

## 附录

### A. 常见问题

**Q1: 为什么有时候找不到根节点？**

A: 根节点的判断条件是 `processGuid == traceId`。如果日志中没有 processGuid 等于 traceId 的记录，就找不到根节点。这可能是因为：
- 根进程的日志已经过期被删除
- 根进程在 EDR 安装前就已经存在
- 日志收集不完整

解决方案：系统会自动检测断链并插入 Explore 节点。

**Q2: 断链是什么意思？**

A: 断链指当前进程的父进程在原始日志中不存在。系统会：
1. 标记该节点为断裂节点（`isBroken = true`）
2. 在该节点前插入 Explore 节点
3. 停止向上追溯

**Q3: 为什么文件节点也有 ProcessEntity？**

A: 因为文件操作（创建、修改、删除）都是由进程发起的。ProcessEntity 记录了发起操作的进程信息，这样可以知道：
- 是哪个进程创建的文件
- 是哪个进程发起的网络连接
- 是哪个进程修改的注册表

这对安全分析非常重要。

---

## 结语

本文档详细介绍了进程链生成系统的设计、实现和使用方法。通过阅读本文档，您应该能够：

1. 理解系统的整体架构和核心概念
2. 掌握每个核心类和函数的作用
3. 了解数据流转和业务流程
4. 正确配置和使用系统

如有疑问，请参考源代码中的详细注释，或联系开发团队。


