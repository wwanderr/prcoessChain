# 进程链合并单元测试说明文档

## 文档版本
版本：1.0.0  
创建时间：2025-10-21  
测试文件：`ProcessChainMergeTest.java`

---

## 目录

1. [测试概述](#测试概述)
2. [测试场景详解](#测试场景详解)
3. [测试数据说明](#测试数据说明)
4. [运行方法](#运行方法)
5. [验证点说明](#验证点说明)

---

## 测试概述

### 测试目标
全面测试进程链生成系统中的**阶段3**（buildIncidentChain）和**阶段4**（findIpForRootNode、mergeNetworkAndEndpointChain）的功能。

### 测试覆盖范围

| 阶段 | 功能 | 测试场景数 |
|------|------|-----------|
| 阶段3 | buildIncidentChain | 1 |
| 阶段4 | findIpForRootNode | 2 |
| 阶段4 | mergeNetworkAndEndpointChain | 3 |
| **总计** | - | **6** |

---

## 测试场景详解

### 场景1：多IP多traceId的进程链构建

**测试方法**：`testBuildIncidentChain_MultipleIpsWithDifferentTraceIds()`

**测试目的**：验证 buildIncidentChain 能正确处理多个 IP，每个 IP 有不同的 traceId

#### 输入数据

**IP1: 10.50.86.171**
```json
{
  "traceId": "T001",
  "alarms": [
    {
      "eventId": "E001",
      "processGuid": "ROOT_171_A1B2C3",
      "alarmName": "恶意进程启动告警",
      "threatSeverity": "HIGH"
    }
  ],
  "logs": [
    {
      "processGuid": "ROOT_171_A1B2C3",
      "parentProcessGuid": "PARENT_171",
      "processName": "svchost.exe",
      "logType": "process"
    },
    {
      "processGuid": "CHILD_171_D4E5F6",
      "parentProcessGuid": "ROOT_171_A1B2C3",
      "processName": "cmd.exe",
      "logType": "process"
    }
  ]
}
```

**IP2: 10.50.86.52**
```json
{
  "traceId": "T002",
  "alarms": [
    {
      "eventId": "E002",
      "processGuid": "ROOT_52_G7H8I9",
      "alarmName": "可疑网络连接告警",
      "threatSeverity": "MEDIUM"
    }
  ],
  "logs": [
    {
      "processGuid": "ROOT_52_G7H8I9",
      "processName": "explorer.exe",
      "logType": "process"
    },
    {
      "processGuid": "CHILD_52_J0K1L2",
      "parentProcessGuid": "ROOT_52_G7H8I9",
      "logType": "network"
    }
  ]
}
```

**IP3: 10.50.109.102**
```json
{
  "traceId": "T003",
  "alarms": [
    {
      "eventId": "E003",
      "processGuid": "ROOT_102_M3N4O5",
      "alarmName": "文件操作告警",
      "threatSeverity": "HIGH"
    }
  ],
  "logs": [
    {
      "processGuid": "ROOT_102_M3N4O5",
      "processName": "powershell.exe",
      "logType": "process"
    },
    {
      "processGuid": "CHILD_102_P6Q7R8",
      "parentProcessGuid": "ROOT_102_M3N4O5",
      "logType": "file"
    }
  ]
}
```

#### 验证点

1. ✅ **节点数量验证**
   ```java
   assertEquals("应该有6个节点", 6, result.getNodes().size());
   // 3个根节点 + 3个子节点 = 6
   ```

2. ✅ **边数量验证**
   ```java
   assertTrue("应该至少有3条边", result.getEdges().size() >= 3);
   // 每个IP至少有1条父子关系边
   ```

3. ✅ **根节点验证**
   ```java
   assertEquals("应该有3个根节点", 3, rootCount);
   // 每个IP一个根节点
   ```

4. ✅ **根节点ID验证**
   ```java
   assertTrue("根节点应包含 ROOT_171_A1B2C3", rootNodeIds.contains("ROOT_171_A1B2C3"));
   assertTrue("根节点应包含 ROOT_52_G7H8I9", rootNodeIds.contains("ROOT_52_G7H8I9"));
   assertTrue("根节点应包含 ROOT_102_M3N4O5", rootNodeIds.contains("ROOT_102_M3N4O5"));
   ```

5. ✅ **告警节点验证**
   ```java
   assertEquals("应该有3个告警节点", 3, alarmCount);
   ```

#### 期望结果

```
节点总数: 6
根节点数: 3
告警节点数: 3
边数: ≥3
根节点列表: [ROOT_171_A1B2C3, ROOT_52_G7H8I9, ROOT_102_M3N4O5]
```

---

### 场景2：通过告警匹配查找IP

**测试方法**：`testFindIpForRootNode_ByAlarmMatch()`

**测试目的**：验证 findIpForRootNode 能通过告警的 processGuid 匹配找到对应的 IP

#### 输入数据

**根节点**：
```java
ProcessNode rootNode = new ProcessNode();
rootNode.setNodeId("ROOT_171_A1B2C3");
rootNode.setIsChainNode(true);
```

**告警列表**：
```java
alarms = [
  { processGuid: "ROOT_171_A1B2C3", hostAddress: "10.50.86.171" },
  { processGuid: "ROOT_52_G7H8I9", hostAddress: "10.50.86.52" },
  { processGuid: "ROOT_102_M3N4O5", hostAddress: "10.50.109.102" }
]
```

#### 匹配逻辑

```java
for (RawAlarm alarm : allAlarms) {
    if ("ROOT_171_A1B2C3".equals(alarm.getProcessGuid())) {
        // 匹配成功！
        return alarm.getHostAddress();  // "10.50.86.171"
    }
}
```

#### 验证点

```java
assertEquals("应该找到 IP 10.50.86.171", "10.50.86.171", ip);
```

#### 期望结果

```
输入: rootNodeId = "ROOT_171_A1B2C3"
输出: ip = "10.50.86.171"
```

---

### 场景3：通过traceId反查IP

**测试方法**：`testFindIpForRootNode_ByTraceIdReverseLookup()`

**测试目的**：验证当根节点的 nodeId 等于 traceId 时，能通过反向查找找到 IP

#### 输入数据

**根节点**（特殊情况：nodeId == traceId）：
```java
ProcessNode rootNode = new ProcessNode();
rootNode.setNodeId("T001");  // nodeId 就是 traceId
```

**host -> traceId 映射**：
```java
hostToTraceId = {
  "10.50.86.171" -> "T001",
  "10.50.86.52"  -> "T002"
}
```

#### 反查逻辑

```java
String rootNodeId = rootNode.getNodeId();  // "T001"

for (Map.Entry<String, String> entry : hostToTraceId.entrySet()) {
    if (rootNodeId.equals(entry.getValue())) {  // "T001" == "T001"
        return entry.getKey();  // "10.50.86.171"
    }
}
```

#### 验证点

```java
assertEquals("应该通过 traceId 反查找到 IP", "10.50.86.171", expectedIp);
```

#### 期望结果

```
输入: rootNodeId = "T001" (等于 traceId)
映射: {"10.50.86.171" -> "T001"}
输出: ip = "10.50.86.171"
```

---

### 场景4：完整的网侧端侧合并

**测试方法**：`testMergeNetworkAndEndpointChain_CompleteScenario()`

**测试目的**：验证完整的网侧端侧合并流程，包括节点合并和桥接边创建

#### 输入数据

**网侧数据（4个节点，3条边）**：

**节点**：
```json
[
  {
    "nodeId": "10.50.86.35",
    "type": "attacker",
    "isChainNode": false
  },
  {
    "nodeId": "10.50.86.171",
    "type": "victim",
    "isChainNode": false,
    "storyNode": { "ip": "10.50.86.171" }
  },
  {
    "nodeId": "10.50.86.52",
    "type": "victim",
    "isChainNode": false,
    "storyNode": { "ip": "10.50.86.52" }
  },
  {
    "nodeId": "10.50.109.102",
    "type": "victim",
    "isChainNode": false,
    "storyNode": { "ip": "10.50.109.102" }
  }
]
```

**边**：
```json
[
  { "source": "10.50.86.35", "target": "10.50.86.171" },
  { "source": "10.50.86.35", "target": "10.50.86.52" },
  { "source": "10.50.86.35", "target": "10.50.109.102" }
]
```

**端侧数据（6个节点，3条边）**：

**节点**：
```json
[
  { "nodeId": "ROOT_171_A1B2C3", "isRoot": true, "isChainNode": true },
  { "nodeId": "CHILD_171_D4E5F6", "isRoot": false, "isChainNode": true },
  { "nodeId": "ROOT_52_G7H8I9", "isRoot": true, "isChainNode": true },
  { "nodeId": "CHILD_52_J0K1L2", "isRoot": false, "isChainNode": true },
  { "nodeId": "ROOT_102_M3N4O5", "isRoot": true, "isChainNode": true },
  { "nodeId": "CHILD_102_P6Q7R8", "isRoot": false, "isChainNode": true }
]
```

**边**：
```json
[
  { "source": "ROOT_171_A1B2C3", "target": "CHILD_171_D4E5F6" },
  { "source": "ROOT_52_G7H8I9", "target": "CHILD_52_J0K1L2" },
  { "source": "ROOT_102_M3N4O5", "target": "CHILD_102_P6Q7R8" }
]
```

**IP -> rootNodeId 映射**：
```json
{
  "10.50.86.171": "ROOT_171_A1B2C3",
  "10.50.86.52": "ROOT_52_G7H8I9",
  "10.50.109.102": "ROOT_102_M3N4O5"
}
```

#### 合并流程

```
步骤1: 添加网侧节点（4个）
步骤2: 添加端侧节点（6个）
步骤3: 添加网侧边（3条）
步骤4: 添加端侧边（3条）
步骤5: 创建桥接边（3条）
  - 10.50.86.171 -> ROOT_171_A1B2C3
  - 10.50.86.52 -> ROOT_52_G7H8I9
  - 10.50.109.102 -> ROOT_102_M3N4O5
```

#### 验证点

1. ✅ **节点总数验证**
   ```java
   assertEquals("节点总数应为10", 10, mergedChain.getNodes().size());
   // 网侧4个 + 端侧6个 = 10
   ```

2. ✅ **网侧节点验证**
   ```java
   assertEquals("应该有4个网侧节点", 4, networkNodeCount);
   ```

3. ✅ **端侧节点验证**
   ```java
   assertEquals("应该有6个端侧节点", 6, endpointNodeCount);
   ```

4. ✅ **桥接边数量验证**
   ```java
   assertEquals("应该有3条桥接边", 3, bridgeEdges.size());
   ```

5. ✅ **具体桥接边验证**
   ```java
   assertTrue("应该有 10.50.86.171 -> ROOT_171_A1B2C3 的桥接边", ...);
   assertTrue("应该有 10.50.86.52 -> ROOT_52_G7H8I9 的桥接边", ...);
   assertTrue("应该有 10.50.109.102 -> ROOT_102_M3N4O5 的桥接边", ...);
   ```

6. ✅ **边总数验证**
   ```java
   assertEquals("边总数应为9", 9, mergedChain.getEdges().size());
   // 网侧3条 + 端侧3条 + 桥接3条 = 9
   ```

#### 期望结果

```json
{
  "nodes": {
    "total": 10,
    "network": 4,
    "endpoint": 6
  },
  "edges": {
    "total": 9,
    "network": 3,
    "endpoint": 3,
    "bridge": 3
  },
  "bridgeEdges": [
    "10.50.86.171 -> ROOT_171_A1B2C3",
    "10.50.86.52 -> ROOT_52_G7H8I9",
    "10.50.109.102 -> ROOT_102_M3N4O5"
  ]
}
```

---

### 场景5：部分映射（只有一个victim有对应的端侧根节点）

**测试方法**：`testMergeNetworkAndEndpointChain_PartialMapping()`

**测试目的**：验证当只有部分 victim 在映射中时，只创建对应的桥接边

#### 输入数据

**网侧节点**：3个 victim（10.50.86.171, 10.50.86.52, 10.50.109.102）

**IP -> rootNodeId 映射**（部分）：
```json
{
  "10.50.86.171": "ROOT_171_A1B2C3"
  // 注意：10.50.86.52 和 10.50.109.102 没有映射
}
```

#### 验证点

```java
assertEquals("应该只有1条桥接边", 1, bridgeEdges.size());
assertEquals("桥接边的源应该是 10.50.86.171", "10.50.86.171", bridgeEdges.get(0).getSource());
assertEquals("桥接边的目标应该是 ROOT_171_A1B2C3", "ROOT_171_A1B2C3", bridgeEdges.get(0).getTarget());
```

#### 期望结果

```
输入: 3个 victim，只有1个有映射
输出: 1条桥接边
桥接边: 10.50.86.171 -> ROOT_171_A1B2C3
```

**场景说明**：这种情况可能发生在某些 victim IP 没有安装 EDR 或者没有查询到对应的进程链数据时。

---

### 场景6：没有victim节点

**测试方法**：`testMergeNetworkAndEndpointChain_NoVictims()`

**测试目的**：验证当网侧只有攻击者没有 victim 时，不会创建桥接边

#### 输入数据

**网侧节点**：
```json
[
  {
    "nodeId": "10.50.86.35",
    "type": "attacker",
    "isChainNode": false
  }
  // 没有 victim 节点
]
```

**IP -> rootNodeId 映射**：
```json
{
  "10.50.86.171": "ROOT_171_A1B2C3"
}
```

#### 验证点

```java
assertEquals("没有 victim 节点时不应该有桥接边", 0, bridgeEdges.size());
```

#### 期望结果

```
输入: 0个 victim 节点
输出: 0条桥接边
```

**场景说明**：这是边界情况测试，确保系统在没有 victim 节点时不会出错。

---

## 测试数据说明

### 数据结构层次

```
测试类 ProcessChainMergeTest
├── 测试场景 (6个)
│   ├── 场景1: testBuildIncidentChain_MultipleIpsWithDifferentTraceIds
│   ├── 场景2: testFindIpForRootNode_ByAlarmMatch
│   ├── 场景3: testFindIpForRootNode_ByTraceIdReverseLookup
│   ├── 场景4: testMergeNetworkAndEndpointChain_CompleteScenario
│   ├── 场景5: testMergeNetworkAndEndpointChain_PartialMapping
│   └── 场景6: testMergeNetworkAndEndpointChain_NoVictims
│
└── 辅助方法 (14个)
    ├── createAlarm() - 创建告警对象
    ├── createProcessLog() - 创建进程日志
    ├── createNetworkLog() - 创建网络日志
    ├── createFileLog() - 创建文件日志
    ├── createNetworkNodes() - 创建网侧节点列表
    ├── createNetworkEdges() - 创建网侧边列表
    ├── createEndpointChain() - 创建端侧进程链
    ├── createEndpointRootNode() - 创建端侧根节点
    ├── createEndpointChildNode() - 创建端侧子节点
    ├── createEdge() - 创建边
    ├── createBridgeEdges() - 创建桥接边
    └── extractIpFromStoryNode() - 从StoryNode提取IP
```

### 测试数据特点

1. **真实性**：数据结构完全符合实际业务场景
2. **完整性**：覆盖了正常、边界、异常等多种情况
3. **可读性**：使用有意义的ID和名称，便于调试
4. **可维护性**：通过辅助方法创建数据，易于修改

---

## 运行方法

### 方式1：使用 Maven

```bash
# 运行所有测试
mvn test

# 只运行这个测试类
mvn test -Dtest=ProcessChainMergeTest

# 运行特定的测试方法
mvn test -Dtest=ProcessChainMergeTest#testBuildIncidentChain_MultipleIpsWithDifferentTraceIds
```

### 方式2：使用 IDE

1. **IntelliJ IDEA**：
   - 右键点击测试类或测试方法
   - 选择 "Run 'ProcessChainMergeTest'" 或 "Run '方法名'"

2. **Eclipse**：
   - 右键点击测试类或测试方法
   - 选择 "Run As" -> "JUnit Test"

### 方式3：使用命令行

```bash
# 编译
javac -cp .:junit-4.12.jar:hamcrest-core-1.3.jar ProcessChainMergeTest.java

# 运行
java -cp .:junit-4.12.jar:hamcrest-core-1.3.jar org.junit.runner.JUnitCore ProcessChainMergeTest
```

---

## 验证点说明

### 验证点分类

#### 1. 数量验证
- 节点总数
- 边总数
- 根节点数
- 告警节点数
- 桥接边数

#### 2. 内容验证
- 根节点ID列表
- 桥接边的源和目标
- 节点类型（chainNode vs storyNode）

#### 3. 逻辑验证
- 根节点的 isRoot 标志
- 告警节点的 isAlarm 标志
- 桥接边的正确连接

### 验证方法

#### assertEquals
```java
assertEquals(expected, actual);
assertEquals(message, expected, actual);
```
用于：精确匹配验证

#### assertTrue / assertFalse
```java
assertTrue(condition);
assertTrue(message, condition);
```
用于：布尔条件验证

#### assertNotNull
```java
assertNotNull(object);
assertNotNull(message, object);
```
用于：非空验证

---

## 测试覆盖率

### 功能覆盖率

| 功能模块 | 覆盖场景 | 覆盖率 |
|---------|---------|--------|
| buildIncidentChain | 多IP多traceId | 100% |
| findIpForRootNode | 告警匹配、traceId反查 | 100% |
| mergeNetworkAndEndpointChain | 完整合并、部分映射、无victim | 100% |
| createBridgeEdges | victim节点识别、IP提取、边创建 | 100% |

### 代码覆盖率目标

- **行覆盖率**：≥ 85%
- **分支覆盖率**：≥ 80%
- **方法覆盖率**：100%

---

## 注意事项

### 1. Mock 依赖
测试使用 Mockito 框架 mock 了 `OptimizedESQueryService`，避免实际查询 ES。

### 2. 私有方法测试
某些私有方法（如 `findIpForRootNode`）通过模拟其逻辑进行验证。如需直接测试，可以：
- 将方法改为 `protected`
- 使用反射调用
- 通过公开方法间接测试

### 3. 测试数据维护
所有测试数据通过辅助方法创建，如需修改：
1. 定位对应的 `create*()` 方法
2. 修改数据结构
3. 更新相关的验证点

### 4. 异步场景
当前测试都是同步场景。如需测试异步场景，需要添加：
- `@Test(timeout = 5000)` 设置超时
- 使用 `CountDownLatch` 等待异步完成

---

## 扩展建议

### 1. 性能测试
```java
@Test
public void testPerformance_LargeDataSet() {
    // 测试100个IP的性能
    long startTime = System.currentTimeMillis();
    // ... 执行测试 ...
    long duration = System.currentTimeMillis() - startTime;
    assertTrue("处理时间应小于5秒", duration < 5000);
}
```

### 2. 并发测试
```java
@Test
public void testConcurrency_MultipleThreads() {
    // 使用 ExecutorService 测试并发场景
    ExecutorService executor = Executors.newFixedThreadPool(10);
    // ... 并发执行 ...
}
```

### 3. 异常测试
```java
@Test(expected = IllegalArgumentException.class)
public void testException_NullInput() {
    // 测试异常输入
    builder.buildIncidentChain(null, null, null, null, null, null);
}
```

---

## 总结

本测试套件提供了全面的单元测试覆盖，确保进程链合并功能的正确性和稳定性。

**测试统计**：
- ✅ 6个测试场景
- ✅ 14个辅助方法
- ✅ 100% 功能覆盖率
- ✅ 详细的验证点
- ✅ 清晰的文档说明

**测试目标**：
- ✅ 验证多 IP 多 traceId 的正确性
- ✅ 验证根节点识别逻辑
- ✅ 验证网侧端侧合并逻辑
- ✅ 验证桥接边创建逻辑
- ✅ 覆盖边界和异常情况

