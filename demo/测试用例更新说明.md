# 测试用例更新说明

## 📋 更新概述

为了验证**多 traceId 独立 EXPLORE 节点**的功能，已更新和新增测试用例。

---

## 🔧 修改的测试用例

### 1. testSingleTraceId_NoRootNode_WithBrokenChain()

**修改内容**:
```java
// 旧断言
assertEquals("EXPLORE_ROOT", rootNode.getNodeId(), "应该创建 EXPLORE_ROOT 虚拟根节点");

// 新断言
assertEquals("EXPLORE_ROOT_" + traceId, rootNode.getNodeId(), 
            "应该创建独立的 EXPLORE_ROOT_" + traceId + " 虚拟根节点");
```

**原因**: EXPLORE 节点现在使用 `EXPLORE_ROOT_{traceId}` 格式

### 2. testMultipleBrokenChains_NoRootNode()

**修改内容**:
```java
// 旧断言
assertEquals("EXPLORE_ROOT", rootNode.getNodeId(), "应该创建唯一的 EXPLORE_ROOT");

// 新断言
assertEquals("EXPLORE_ROOT_" + traceId, rootNode.getNodeId(), 
            "应该创建独立的 EXPLORE_ROOT_" + traceId);

// 验证边时也需要使用新的节点ID
String exploreNodeId = "EXPLORE_ROOT_" + traceId;
long exploreEdges = result.getEdges().stream()
    .filter(edge -> exploreNodeId.equals(edge.getSource()))
    .count();
```

**原因**: 同上

---

## ✨ 新增的测试用例

### 测试7: testMultipleTraceIds_AllWithoutRootNodes()

**测试目标**: 验证多个 traceId 都没有真实根节点时，每个 traceId 都有独立的 EXPLORE 节点

**测试数据**:
```
traceIds: [T001, T002, T003]
所有 traceId 都没有真实根节点（断链）
```

**验证点**:
1. ✅ 创建3个独立的 EXPLORE 节点
2. ✅ 节点ID分别为: `EXPLORE_ROOT_T001`, `EXPLORE_ROOT_T002`, `EXPLORE_ROOT_T003`
3. ✅ 每个节点都是根节点 (`isRoot = true`)
4. ✅ `traceIdToRootNodeMap` 正确映射:
   - `T001 -> EXPLORE_ROOT_T001`
   - `T002 -> EXPLORE_ROOT_T002`
   - `T003 -> EXPLORE_ROOT_T003`

**关键代码**:
```java
// 验证根节点数量
assertEquals(3, rootCount, "应该有3个独立的 EXPLORE 根节点");

// 验证每个 traceId 都有独立的 EXPLORE 节点
assertTrue(rootNodeIds.contains("EXPLORE_ROOT_T001"), "应该包含 EXPLORE_ROOT_T001");
assertTrue(rootNodeIds.contains("EXPLORE_ROOT_T002"), "应该包含 EXPLORE_ROOT_T002");
assertTrue(rootNodeIds.contains("EXPLORE_ROOT_T003"), "应该包含 EXPLORE_ROOT_T003");

// 验证映射关系
assertEquals("EXPLORE_ROOT_T001", result.getTraceIdToRootNodeMap().get("T001"));
assertEquals("EXPLORE_ROOT_T002", result.getTraceIdToRootNodeMap().get("T002"));
assertEquals("EXPLORE_ROOT_T003", result.getTraceIdToRootNodeMap().get("T003"));
```

---

### 测试8: testMixedScenario_SomeWithRootNodes_SomeWithout()

**测试目标**: 验证混合场景 - 部分 traceId 有真实根节点，部分没有

**测试数据**:
```
T001: 有真实根节点
T002: 没有真实根节点（断链）
T003: 有真实根节点
```

**验证点**:
1. ✅ 总共3个根节点（2个真实 + 1个EXPLORE）
2. ✅ 真实根节点: `T001`, `T003`
3. ✅ EXPLORE 节点: `EXPLORE_ROOT_T002`
4. ✅ `traceIdToRootNodeMap` 正确映射:
   - `T001 -> T001` (真实根节点)
   - `T002 -> EXPLORE_ROOT_T002` (EXPLORE 节点)
   - `T003 -> T003` (真实根节点)

**关键代码**:
```java
// 验证根节点数量
assertEquals(3, rootCount, "应该有3个根节点（2个真实 + 1个EXPLORE）");

// 验证根节点ID
assertTrue(rootNodeIds.contains("T001"), "应该包含真实根节点 T001");
assertTrue(rootNodeIds.contains("T003"), "应该包含真实根节点 T003");
assertTrue(rootNodeIds.contains("EXPLORE_ROOT_T002"), "应该包含 EXPLORE_ROOT_T002");

// 验证映射关系
assertEquals("T001", result.getTraceIdToRootNodeMap().get("T001"));
assertEquals("EXPLORE_ROOT_T002", result.getTraceIdToRootNodeMap().get("T002"));
assertEquals("T003", result.getTraceIdToRootNodeMap().get("T003"));
```

---

## 📊 测试覆盖矩阵

| 测试用例 | 场景 | traceId数量 | 真实根节点 | EXPLORE节点 | 状态 |
|---------|------|------------|-----------|------------|------|
| testSingleTraceId_WithRootNode_NoBrokenChain | 单个traceId，有根节点 | 1 | 1 | 0 | ✅ 已更新 |
| testSingleTraceId_NoRootNode_WithBrokenChain | 单个traceId，无根节点 | 1 | 0 | 1 | ✅ 已更新 |
| testMultipleTraceIds_AllWithRootNodes | 多个traceId，都有根节点 | 3 | 3 | 0 | ✅ 保持不变 |
| testMultipleBrokenChains_NoRootNode | 单个traceId，多个断链 | 1 | 0 | 1 | ✅ 已更新 |
| testPruning_RootNodePreserved | 裁剪后根节点保留 | 1 | 1 | 0 | ✅ 保持不变 |
| testPruning_AssociatedNodePreserved | 网端关联节点保留 | 1 | 1 | 0 | ✅ 保持不变 |
| **testMultipleTraceIds_AllWithoutRootNodes** | **多个traceId，都无根节点** | **3** | **0** | **3** | **✅ 新增** |
| **testMixedScenario_SomeWithRootNodes_SomeWithout** | **混合场景** | **3** | **2** | **1** | **✅ 新增** |

---

## 🎯 测试重点

### 关键验证点

1. **独立性验证**
   - 每个 traceId 有独立的 EXPLORE 节点
   - 节点ID格式: `EXPLORE_ROOT_{traceId}`

2. **映射关系验证**
   - `traceIdToRootNodeMap` 正确记录映射
   - 真实根节点映射到自身
   - 无根节点的 traceId 映射到独立的 EXPLORE 节点

3. **根节点唯一性**
   - 每个 EXPLORE 节点都是独立的根节点
   - `isRoot = true`

4. **混合场景验证**
   - 真实根节点和 EXPLORE 节点可以共存
   - 不同类型的根节点不会相互干扰

---

## 🚀 运行测试

### 运行所有测试
```bash
mvn test -Dtest=ProcessChainIntegrationTest
```

### 运行特定测试
```bash
# 测试多个 traceId 都没有根节点
mvn test -Dtest=ProcessChainIntegrationTest#testMultipleTraceIds_AllWithoutRootNodes

# 测试混合场景
mvn test -Dtest=ProcessChainIntegrationTest#testMixedScenario_SomeWithRootNodes_SomeWithout
```

### 预期结果
```
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0
```

---

## 📝 测试日志示例

### 测试7日志
```
=== 测试: 多个 traceId 都没有真实根节点 ===
【进程链生成】-> 开始为 3 个没有真实根节点的 traceId 创建独立的 Explore 节点
【进程链生成】-> 创建独立 Explore 节点: traceId=T001 -> nodeId=EXPLORE_ROOT_T001
【进程链生成】-> 创建独立 Explore 节点: traceId=T002 -> nodeId=EXPLORE_ROOT_T002
【进程链生成】-> 创建独立 Explore 节点: traceId=T003 -> nodeId=EXPLORE_ROOT_T003
【进程链生成】-> Explore 节点创建完成: 共创建 3 个独立的虚拟根节点
✅ 测试通过：每个 traceId 都有独立的 EXPLORE 节点
```

### 测试8日志
```
=== 测试: 混合场景 - 部分有根节点，部分没有 ===
【进程链生成】-> 告警节点本身就是根节点: processGuid=T001
【进程链生成】-> 告警节点本身就是根节点: processGuid=T003
【进程链生成】-> 开始为 1 个没有真实根节点的 traceId 创建独立的 Explore 节点
【进程链生成】-> 创建独立 Explore 节点: traceId=T002 -> nodeId=EXPLORE_ROOT_T002
✅ 测试通过：混合场景正确处理，真实根节点和 EXPLORE 节点共存
```

---

## ✅ 验证清单

- [x] 修改现有测试用例以适配新的 EXPLORE 节点命名规则
- [x] 新增多 traceId 独立 EXPLORE 节点测试
- [x] 新增混合场景测试
- [x] 验证 `traceIdToRootNodeMap` 映射关系
- [x] 验证根节点独立性
- [x] 验证根节点唯一性
- [x] 所有测试编译通过
- [x] 测试覆盖关键场景

---

## 🎉 总结

通过这些测试用例的更新和新增，我们能够全面验证：

1. ✅ 每个 traceId 都有独立的 EXPLORE 节点
2. ✅ EXPLORE 节点命名规则正确 (`EXPLORE_ROOT_{traceId}`)
3. ✅ `traceIdToRootNodeMap` 映射关系正确
4. ✅ 真实根节点和 EXPLORE 节点可以共存
5. ✅ 不同 traceId 的进程链完全隔离

这些测试确保了多 traceId 独立 EXPLORE 节点功能的正确性和稳定性。

---

**更新时间**: 2025-10-25  
**测试文件**: `ProcessChainIntegrationTest.java`  
**新增测试**: 2个  
**修改测试**: 2个  
**总测试数**: 8个

