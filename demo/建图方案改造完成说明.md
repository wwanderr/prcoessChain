# 建图方案改造完成说明

## 改造完成时间
2025年11月19日

## 改造内容概述

本次改造将进程链构建从**递归遍历方案**升级为**建图方案**，同时实现了以下5个核心需求：

### ✅ 1. 无告警场景支持（ipToTraceIds + logs）
- **文件**：`IpMappingRelation.java`
- **新增字段**：`Map<String, String> ipToTraceIds`
- **使用字段**：`Map<String, String> logs` (ip -> eventId)
- **逻辑位置**：
  - `ProcessChainServiceImpl.java` 第97-121行（无告警检测）
  - `ProcessChainServiceImpl.java` 第195-201行（收集startLogEventIds）
  - `ProcessChainBuilder.java` 第150-177行（使用eventId确定起点）
- **功能流程**：
  1. 通过`ipToTraceIds`获取traceId → ES查询日志
  2. 通过`logs`获取eventId → 确定具体的起点日志
  3. 在图中找到eventId对应的节点 → 作为起点溯源

### ✅ 2. 多分支全树溯源
- **核心类**：`ProcessChainGraph.java` 的 `fullTreeTraversal()` 方法
- **算法**：
  1. 从起点向上BFS到root，记录路径
  2. 对路径上每个节点，向下BFS遍历所有子树
  3. 实现了"中间节点也进行双向溯源"的需求
- **应用场景**：所有告警和日志，统一使用全树遍历

### ✅ 3. 日志节点拆分
- **工具类**：`LogNodeSplitter.java`
- **拆分规则**：
  - **process日志** → 父进程节点 + 子进程节点
  - **file/domain/network/registry日志** → 父进程节点 + 子进程节点 + 实体节点
- **父进程虚拟节点**：当找不到真实父节点时，通过hash计算parentProcessGuid
- **节点合并**：虚拟节点会被真实节点自动替代

### ✅ 4. 实体过滤和去重
- **工具类**：`EntityFilterUtil.java`
- **过滤规则**：
  - **file**：保留3个，优先后缀（.exe .dll .bat等），告警节点优先
  - **domain**：保留5个，最新的
  - **network**：保留5个，最新的
  - **registry**：保留3个，最早的
- **去重规则**：
  - process: processGuid
  - file: fileMd5 + targetFilename
  - domain: requestDomain
  - network: destAddress
  - registry: targetObject

### ✅ 5. 性能优化：环检测
- **核心方法**：`ProcessChainGraph.detectCycles()`
- **算法**：DFS着色法（白→灰→黑）
- **处理**：检测到环后记录日志（可扩展为断环）

---

## 新增文件清单

| 文件名 | 位置 | 功能 | 代码行数 |
|--------|------|------|---------|
| `ProcessChainGraph.java` | `service/` | 图结构核心类（节点、边、索引、遍历、环检测） | ~650行 |
| `ProcessChainGraphBuilder.java` | `service/` | 图构建器（从原始数据构建图） | ~170行 |
| `LogNodeSplitter.java` | `util/` | 日志节点拆分工具 | ~400行 |
| `EntityFilterUtil.java` | `util/` | 实体过滤和去重工具 | ~450行 |

---

## 修改文件清单

| 文件名 | 修改内容 | 关键改动位置 |
|--------|---------|-------------|
| `IpMappingRelation.java` | 新增`ipToTraceIds`字段及getter/setter | 第34-40行、159-165行 |
| `ProcessChainBuilder.java` | 核心方法`buildProcessChain()`完全重构 | 第88-298行 |
| `ProcessChainServiceImpl.java` | 无告警场景处理逻辑 | 第97-121行 |

---

## 核心流程说明

### 新的构链流程（7个阶段）

```
阶段1: 建图（ProcessChainGraphBuilder）
   ├─ 添加告警节点
   ├─ 添加日志节点（带拆分）
   │  ├─ process日志：父+子
   │  └─ file/domain/network/registry：父+子+实体
   ├─ 处理虚拟父节点（与真实节点合并）
   ├─ 建立父子边
   └─ 图分析（根节点识别、环检测）

阶段2: 确定起点节点
   ├─ 有告警场景：告警节点为起点
   └─ 无告警场景：根节点为起点

阶段3: 子图提取（遍历）
   └─ 所有起点：fullTreeTraversal（全树遍历，保证连通性）

阶段4: 提取子图
   └─ 根据遍历结果提取相关子图

阶段5: 实体过滤
   └─ EntityFilterUtil.filterEntityNodesInGraph()

阶段6: 裁剪（如需要）
   └─ 节点数超过MAX_NODE_COUNT时触发

阶段7: 转换输出格式
   └─ ProcessChainGraph → ProcessChainResult
```

---

## 关键数据结构

### 1. ProcessChainGraph.GraphNode
```java
{
    String nodeId;                    // 节点ID（processGuid或实体ID）
    String parentProcessGuid;         // 父进程GUID
    String traceId;                   // 追踪ID
    String hostAddress;               // 主机地址
    List<RawAlarm> alarms;           // 关联的告警
    List<RawLog> logs;               // 关联的日志
    boolean isRoot;                  // 是否根节点
    boolean isBroken;                // 是否断链节点
    boolean isAlarm;                 // 是否告警节点
    boolean isVirtual;               // 是否虚拟节点
    String nodeType;                 // 节点类型
}
```

### 2. 实体节点ID规则
- **process节点**：使用 `processGuid`
- **file实体节点**：`processGuid + "_FILE_" + fileMd5 + "_" + targetFilename`
- **domain实体节点**：`processGuid + "_DOMAIN_" + requestDomain`
- **network实体节点**：`processGuid + "_NETWORK_" + destAddress + "_" + destPort`
- **registry实体节点**：`processGuid + "_REGISTRY_" + hashOf(targetObject)`

---

## 测试验证要点

### 1. 基本功能验证
- [ ] **有告警场景**：验证现有功能是否正常
- [ ] **无告警场景**：验证ipToTraceIds → 日志查询 → 溯源流程

### 2. 节点拆分验证
- [ ] **process日志**：验证是否拆分为父+子两个节点
- [ ] **domain日志**：验证是否拆分为父+子+实体三个节点
- [ ] **虚拟父节点**：验证hash计算和合并逻辑

### 3. 多分支全树验证
- [ ] **全树遍历**：验证是否遍历到所有连通分支
  - 测试场景：`root → a→b→c, b→d→f`，从c溯源，应得到完整树（包括d→f分支）
- [ ] **连通性**：验证只保留与告警/起点连通的节点，不相关的节点被过滤

### 4. 实体过滤验证
- [ ] **file过滤**：验证优先后缀和数量限制（3个）
- [ ] **domain/network过滤**：验证最新5个
- [ ] **registry过滤**：验证最早3个
- [ ] **告警节点优先**：验证告警实体不被过滤

### 5. 性能验证
- [ ] **大数据量**：测试10w条日志的处理时间
- [ ] **环检测**：验证环的识别和处理
- [ ] **内存占用**：监控大数据量下的内存使用

### 6. 边界情况
- [ ] 空告警+空日志
- [ ] 只有告警无日志
- [ ] 只有日志无告警
- [ ] 多IP场景
- [ ] 断链场景

---

## 性能预估

| 数据规模 | 预估耗时 | 说明 |
|---------|---------|------|
| 1000条日志 | < 100ms | 正常场景 |
| 10000条日志 | < 1s | 中等规模 |
| 100000条日志 | < 10s | 大规模（需监控） |

**关键优化点**：
1. ✅ 邻接表存储：O(V+E)空间，O(1)查询子节点
2. ✅ 索引结构：traceId、host快速定位
3. ✅ BFS遍历：避免递归栈溢出
4. ✅ 环检测：DFS着色法，O(V+E)复杂度

---

## 已知限制和TODO

### 当前版本未实现
1. **图裁剪**：节点数超限时，暂时只记录日志，未实现智能裁剪
2. **断环策略**：检测到环后，暂未实现自动断开
3. **增量更新**：暂不支持图的增量修改

### 后续优化建议
1. **裁剪策略**：
   - 保留告警节点及其链路
   - 裁剪低优先级实体节点
   - 裁剪过长的子树
2. **断环策略**：
   - 优先断开优先级低的边
   - 保留告警节点的环
3. **性能监控**：
   - 添加各阶段耗时统计
   - 添加内存使用监控

---

## 兼容性说明

### ✅ 向后兼容
- 外部接口（`IncidentProcessChain`）**未改变**
- `NodeMapper`和`EdgeMapper`**未改变**
- 现有测试用例**应全部通过**

### 内部重构
- `buildProcessChain()`方法内部逻辑完全重构
- 移除了递归遍历相关代码
- 新增了图构建相关类

---

## 回滚方案

如果出现问题需要回滚：

1. **Git回滚**：
   ```bash
   git checkout HEAD demo/src/main/java/com/security/processchain/service/ProcessChainBuilder.java
   git checkout HEAD demo/src/main/java/com/security/processchain/service/impl/ProcessChainServiceImpl.java
   git checkout HEAD demo/src/main/java/com/security/processchain/model/IpMappingRelation.java
   ```

2. **删除新增文件**：
   - `ProcessChainGraph.java`
   - `ProcessChainGraphBuilder.java`
   - `LogNodeSplitter.java`
   - `EntityFilterUtil.java`

---

## 快速验证脚本

建议使用现有测试数据进行快速验证：

```bash
# 场景1：有告警（webshell）
cd demo/dataSet/webshell文件上传/案例2/
cat test_data.txt

# 场景2：无告警（模拟ipToTraceIds）
# 需要构造测试数据，设置ipToTraceIds

# 场景3：挖矿（验证多分支）
cd demo/dataSet/矿池/案例2/
cat test_data.txt

# 场景4：命令执行（验证实体过滤）
cd demo/dataSet/命令执行/案例2/
cat test_data.txt
```

---

## 技术亮点

1. **图结构**：用邻接表实现，空间和时间复杂度都是O(V+E)
2. **节点拆分**：解耦了进程和实体，支持细粒度的分析
3. **多分支全树**：实现了"中间节点双向溯源"的复杂需求，保证所有连通关系
4. **统一遍历策略**：不区分告警级别，统一使用全树遍历，简化逻辑
5. **实体智能过滤**：多维度优先级（后缀、时间、告警）
6. **环检测**：DFS着色法，经典图算法
7. **虚拟节点合并**：自动识别和合并虚拟父节点

---

## 开发者备注

- **开发日期**：2025年11月19日
- **开发时长**：预估2天自测时间
- **代码规模**：新增约1670行，重构约200行
- **测试建议**：优先测试基本功能，再测试边界情况，最后进行性能测试

---

**祝测试顺利！** 🚀

有任何问题请随时反馈。

