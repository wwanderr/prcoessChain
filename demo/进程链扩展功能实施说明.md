# 进程链扩展功能实施说明

## 📋 功能概述

实现了从 `isRoot` 节点向上扩展溯源的功能，最多扩展2层父节点，并智能调整桥接点到最顶端节点。

## ✅ 已完成的修改

### 1. 修改 ChainNode.java

**文件**: `demo/src/main/java/com/security/processchain/service/ChainNode.java`

**新增字段**:
```java
/**
 * 是否是扩展节点（从逻辑根向上扩展出来的节点）
 * 用于前端区分显示样式
 */
private Boolean isExtensionNode;

/**
 * 扩展深度（从逻辑根开始，0=逻辑根本身，1=父节点，2=祖父节点）
 */
private Integer extensionDepth;
```

**用途**: 
- `isExtensionNode`: 标识节点是否是扩展出来的（前端可用不同颜色显示）
- `extensionDepth`: 标识扩展的层数

### 2. 创建 ProcessChainExtensionUtil.java

**文件**: `demo/src/main/java/com/security/processchain/util/ProcessChainExtensionUtil.java`

**核心功能**:
```java
public static Map<String, String> performExtension(
        Map<String, String> traceIdToRootMap,
        Map<String, String> hostToTraceId,
        List<ProcessNode> allNodes,
        List<ProcessEdge> allEdges,
        OptimizedESQueryService esQueryService,
        int maxDepth)
```

**关键特性**:
- 自动跳过 Explore 虚拟节点
- 自动跳过断链节点
- 从根节点向上查询最多2层父节点
- 自动更新 `isRoot` 标记到最顶端节点
- 返回更新后的桥接映射

**扩展流程**:
```
1. 检查是否需要跳过（Explore节点、断链节点）
2. 从原始根节点获取父节点GUID
3. 查询父节点日志（跨traceId查询）
4. 递归构建扩展链
5. 更新isRoot标记
6. 返回新的映射（traceId -> 最顶端节点ID）
```

### 3. 在 OptimizedESQueryService 中添加查询方法

**文件**: `demo/src/main/java/com/security/processchain/service/OptimizedESQueryService.java`

**新增方法**:
```java
public List<RawLog> queryLogsByProcessGuids(
        String hostAddress, 
        List<String> processGuids, 
        int maxLevels)
```

**功能**: 
- 根据 processGuid 查询日志，不限制 traceId
- 支持递归查询多层父节点
- 用于跨 traceId 扩展溯源

### 4. 修改 ProcessChainServiceImpl.java

**文件**: `demo/src/main/java/com/security/processchain/service/impl/ProcessChainServiceImpl.java`

**修改位置**: `mergeNetworkAndEndpointChain()` 方法

**新增代码** (第340-342行):
```java
// ========== 5. 扩展溯源（新增功能）==========
Map<String, String> finalRootMap = com.security.processchain.util.ProcessChainExtensionUtil.performExtension(
        traceIdToRootNodeMap, hostToTraceId, allNodes, allEdges, esQueryService, 2);
```

**修改说明**:
- 在桥接边创建之前调用扩展功能
- 使用更新后的 `finalRootMap` 创建桥接边
- **最小侵入**: 只增加了1行核心代码

### 5. 扩展 ProcessEntity.java

**文件**: `demo/src/main/java/com/security/processchain/service/ProcessEntity.java`

**新增字段**:
```java
private String processGuid;
private String parentProcessGuid;
```

**用途**: 支持扩展溯源功能，需要从 ProcessEntity 中获取父节点GUID

### 6. 创建测试文件

**文件**: `demo/src/test/java/com/security/processchain/ProcessChainExtensionTest.java`

**测试用例**:
1. ✅ 基本扩展功能 - 从根节点向上扩展2层
2. ✅ 无父节点情况 - 根节点无需扩展
3. ✅ 断链节点自动跳过
4. ✅ Explore虚拟节点自动跳过
5. ✅ 只扩展1层（父节点没有祖父节点）
6. ✅ ES查询返回空（无法扩展）
7. ✅ 多个traceId同时扩展

**运行测试**:
```bash
cd demo
mvn test -Dtest=ProcessChainExtensionTest
```

## 🎯 功能特点

### 1. 智能跳过策略

**自动跳过以下节点**:
- ✅ Explore 虚拟节点 (`nodeId.startsWith("EXPLORE_")`)
- ✅ 断链节点 (`isBroken=true`)

**原因**: 这些节点不需要向上扩展

### 2. 桥接点智能调整

**原逻辑**:
```
网侧 victim → 桥接边 → isRoot节点 (processGuid=traceId)
```

**新逻辑**:
```
网侧 victim → 桥接边 → 最顶端节点 (物理根)
                         ↓
                       父节点
                         ↓
                     isRoot节点 (processGuid=traceId)
```

**映射变化**:
```java
// 原映射
traceId=T001 -> rootNodeId=NODE_T001

// 扩展后
traceId=T001 -> rootNodeId=GRAND_PARENT  // 自动更新到最顶端
```

### 3. isRoot 语义变化

**扩展前**:
- `isRoot=true`: 表示 `processGuid == traceId` 的节点

**扩展后**:
- `isRoot=true`: 表示当前进程链的最顶层节点（展示用）
- 原逻辑根节点的 `isRoot` 会被改为 `false`

### 4. 扩展节点标记

**新增标记字段**:
```java
ChainNode {
    isExtensionNode: true    // 标识为扩展节点
    extensionDepth: 1        // 扩展深度（1=父节点，2=祖父节点）
}
```

**前端可以根据这些标记使用不同样式显示**:
```javascript
if (node.chainNode.isExtensionNode) {
    style = { border: '1px dashed gray', opacity: 0.7 };
}
```

## 📊 数据流程图

```
输入: traceIdToRootMap = {T001 -> ROOT_001}
  ↓
检查 ROOT_001 是否需要跳过？
  ├─ 是Explore节点? → 跳过
  ├─ 是断链节点? → 跳过
  └─ 否 → 继续
  ↓
获取 ROOT_001 的 parentProcessGuid
  ↓
调用 ES 查询父节点日志（跨traceId）
  ↓
找到 PARENT_001, GRAND_PARENT_001
  ↓
构建扩展链:
  GRAND_PARENT_001 (depth=2, isExtensionNode=true)
    ↓
  PARENT_001 (depth=1, isExtensionNode=true)
    ↓
  ROOT_001 (原根节点)
  ↓
更新 isRoot 标记:
  ROOT_001.isRoot = false
  GRAND_PARENT_001.isRoot = true
  ↓
返回: {T001 -> GRAND_PARENT_001}
  ↓
桥接边创建:
  victim → GRAND_PARENT_001
```

## 🔧 配置参数

扩展功能硬编码了以下参数：

```java
int maxDepth = 2;  // 最大扩展深度
```

**可以修改为配置化**:
```yaml
# application.yml
process-chain:
  extension:
    enabled: true       # 是否启用扩展
    max-depth: 2        # 最大扩展深度
    skip-broken: true   # 是否跳过断链
```

## ⚠️ 注意事项

### 1. 性能考虑

- 每个根节点会额外执行1-2次ES查询
- 如果有10个根节点，最多增加20次ES查询
- 建议在生产环境中监控查询性能

### 2. 语义变化

- `isRoot` 的含义从"逻辑根"变为"展示根"
- 原 `processGuid==traceId` 的节点 `isRoot` 会被改为 `false`
- 需要在文档中说明这个变化

### 3. 跨traceId问题

- 扩展节点的日志可能属于其他 traceId
- 例如: ROOT节点属于 T001，但父节点属于 T002
- 这是预期行为，用于展示完整的进程树

## 🧪 测试验证

### 运行所有测试

```bash
cd demo
mvn clean test
```

### 只运行扩展测试

```bash
cd demo
mvn test -Dtest=ProcessChainExtensionTest
```

### 预期结果

```
[INFO] Tests run: 7, Failures: 0, Errors: 0, Skipped: 0
```

## 📝 使用示例

### 场景1: 基本扩展

**原数据**:
```json
{
  "traceId": "T001",
  "nodes": [
    {"nodeId": "ROOT_T001", "isRoot": true, "parentGuid": "PARENT_001"}
  ]
}
```

**扩展后**:
```json
{
  "traceId": "T001",
  "nodes": [
    {"nodeId": "GRAND_PARENT", "isRoot": true, "isExtensionNode": true, "extensionDepth": 2},
    {"nodeId": "PARENT_001", "isRoot": false, "isExtensionNode": true, "extensionDepth": 1},
    {"nodeId": "ROOT_T001", "isRoot": false, "isExtensionNode": false}
  ],
  "edges": [
    {"source": "GRAND_PARENT", "target": "PARENT_001"},
    {"source": "PARENT_001", "target": "ROOT_T001"}
  ]
}
```

**桥接边**:
```json
{"source": "victim_ip", "target": "GRAND_PARENT"}  // 连接到最顶端
```

### 场景2: 断链节点跳过

**原数据**:
```json
{
  "nodeId": "BROKEN_001",
  "isRoot": true,
  "isBroken": true,
  "parentGuid": "MISSING"
}
```

**扩展后**:
```json
// 不扩展，保持原样
{
  "nodeId": "BROKEN_001",
  "isRoot": true,
  "isBroken": true
}
```

## 🚀 后续优化建议

### 1. 配置化

将硬编码参数移到配置文件：
```yaml
process-chain:
  extension:
    enabled: true
    max-depth: 2
    skip-broken-chains: true
    skip-explore-nodes: true
```

### 2. 缓存优化

对于频繁查询的父节点，可以添加缓存：
```java
@Cacheable("extension-logs")
public List<RawLog> queryLogsByProcessGuids(...)
```

### 3. 批量优化

如果有多个根节点，可以批量查询：
```java
// 收集所有需要查询的父节点GUID
List<String> allParentGuids = ...;
// 一次性查询所有父节点
List<RawLog> allLogs = esQueryService.queryLogsByProcessGuids(...);
```

### 4. 异步扩展

如果扩展查询耗时较长，可以改为异步：
```java
CompletableFuture<Map<String, String>> future = 
    CompletableFuture.supplyAsync(() -> 
        ProcessChainExtensionUtil.performExtension(...));
```

## ✅ 完成清单

- [x] 修改 ChainNode.java - 添加扩展字段
- [x] 创建 ProcessChainExtensionUtil.java - 扩展工具类
- [x] 扩展 ProcessEntity.java - 添加父节点GUID
- [x] 在 OptimizedESQueryService 中添加跨traceId查询方法
- [x] 修改 ProcessChainServiceImpl - 集成扩展逻辑
- [x] 创建测试文件 ProcessChainExtensionTest.java
- [x] 修复编译错误
- [x] 编写实施说明文档

## 📞 技术支持

如有问题，请参考：
1. 测试用例: `ProcessChainExtensionTest.java`
2. 核心工具类: `ProcessChainExtensionUtil.java`
3. 集成点: `ProcessChainServiceImpl.mergeNetworkAndEndpointChain()`

---

**实施完成时间**: 2025-10-27
**实施者**: AI Assistant
**版本**: v1.0.0


