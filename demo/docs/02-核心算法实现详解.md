# è¿›ç¨‹é“¾ç”Ÿæˆç³»ç»Ÿ - æ ¸å¿ƒç®—æ³•å®ç°è¯¦è§£

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0  
> **æœ€åæ›´æ–°**: 2025-12-08  
> **å‰ç½®é˜…è¯»**: [01-æ ¸å¿ƒæ¶æ„ä¸æ•°æ®æµç¨‹](./01-æ ¸å¿ƒæ¶æ„ä¸æ•°æ®æµç¨‹.md)

---

## ğŸ“‹ ç›®å½•

1. [å…¨æ ‘éå†ç®—æ³•](#1-å…¨æ ‘éå†ç®—æ³•)
2. [è™šæ‹Ÿçˆ¶èŠ‚ç‚¹æ‰¹é‡åˆ›å»ºç®—æ³•](#2-è™šæ‹Ÿçˆ¶èŠ‚ç‚¹æ‰¹é‡åˆ›å»ºç®—æ³•)
3. [å‘Šè­¦é€‰ä¸¾ç®—æ³•](#3-å‘Šè­¦é€‰ä¸¾ç®—æ³•)
4. [å¼ºåˆ¶è£å‰ªç®—æ³•](#4-å¼ºåˆ¶è£å‰ªç®—æ³•)
5. [å®ä½“æå–ç®—æ³•](#5-å®ä½“æå–ç®—æ³•)
6. [æ‰©å±•æº¯æºç®—æ³•](#6-æ‰©å±•æº¯æºç®—æ³•)
7. [è§’è‰²ä¿®æ­£ç®—æ³•](#7-è§’è‰²ä¿®æ­£ç®—æ³•)

---

## 1. å…¨æ ‘éå†ç®—æ³•

### 1.1 ç®—æ³•æ¦‚è¿°

**ç®—æ³•åç§°**: `fullTreeTraversal`

**æ‰€åœ¨ç±»**: `ProcessChainGraph.java`

**åŠŸèƒ½**: ä»ä»»æ„èµ·ç‚¹èŠ‚ç‚¹å‡ºå‘ï¼Œæ”¶é›†æ•´ä¸ªè¿é€šå­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹

**é€‚ç”¨åœºæ™¯**:
- å­å›¾æå–ï¼šä»å‘Šè­¦èŠ‚ç‚¹æå–ç›¸å…³çš„è¿›ç¨‹é“¾
- æ”¯æŒæ–­é“¾ï¼šå³ä½¿æ²¡æœ‰æ ¹èŠ‚ç‚¹ä¹Ÿèƒ½å·¥ä½œ
- åŒ…å«æ‰€æœ‰åˆ†æ”¯ï¼šå…„å¼ŸèŠ‚ç‚¹ã€ä¾„èŠ‚ç‚¹ç­‰

### 1.2 ç®—æ³•åŸç†

**æ ¸å¿ƒæ€æƒ³**: ä¸¤é˜¶æ®µéå†

```
é˜¶æ®µ1: å‘ä¸Šéå†ï¼ˆTraverse Upwardï¼‰
  ä»èµ·ç‚¹å‘ä¸Šè¿½æº¯åˆ°æ ¹èŠ‚ç‚¹ï¼ˆæˆ–æœ€é¡¶ç«¯èŠ‚ç‚¹ï¼‰
  è®°å½•æ‰€æœ‰è®¿é—®è¿‡çš„èŠ‚ç‚¹
  è®°å½•æ‰€æœ‰åˆ°è¾¾çš„é¡¶ç«¯èŠ‚ç‚¹
  
é˜¶æ®µ2: å‘ä¸‹éå†ï¼ˆTraverse Downwardï¼‰
  ä»æ‰€æœ‰é¡¶ç«¯èŠ‚ç‚¹å‡ºå‘
  å‘ä¸‹éå†åˆ°æ‰€æœ‰å¶èŠ‚ç‚¹
  æ”¶é›†æ•´ä¸ªè¿é€šå­å›¾
```

**ä¸ºä»€ä¹ˆéœ€è¦ä¸¤é˜¶æ®µ?**

```
å•çº¯å‘ä¸Šéå†çš„é—®é¢˜:
         ROOT
          |
        NODE_A
       /     \
    NODE_B   NODE_C
      |        |
  NODE_D    NODE_E âš ï¸ (èµ·ç‚¹)
      |
  NODE_F

å¦‚æœåªå‘ä¸Šéå†:
  æ”¶é›†: {NODE_E, NODE_C, NODE_A, ROOT}
  é—æ¼: {NODE_B, NODE_D, NODE_F}  âŒ

ä¸¤é˜¶æ®µéå†:
  é˜¶æ®µ1: NODE_E â†’ NODE_C â†’ NODE_A â†’ ROOT
  é˜¶æ®µ2: ä»ROOTå‘ä¸‹éå†æ•´æ£µæ ‘
  æ”¶é›†: {ROOT, NODE_A, NODE_B, NODE_C, NODE_D, NODE_E, NODE_F}  âœ…
```

### 1.3 ç®—æ³•å®ç°

#### æ ¸å¿ƒæ–¹æ³•

```java
public Set<String> fullTreeTraversal(String startNodeId) {
    Set<String> visited = new HashSet<>();
    Set<String> topmostNodes = new HashSet<>();
    
    // é˜¶æ®µ1: å‘ä¸Šéå†åˆ°æ ¹
    traverseUpward(startNodeId, visited, topmostNodes);
    
    // é˜¶æ®µ2: ä»æ‰€æœ‰é¡¶ç«¯èŠ‚ç‚¹å‘ä¸‹éå†
    for (String topmostNode : topmostNodes) {
        traverseDownward(topmostNode, visited);
    }
    
    return visited;
}
```

#### é˜¶æ®µ1: å‘ä¸Šéå†

```java
private void traverseUpward(
        String nodeId, 
        Set<String> visited, 
        Set<String> topmostNodes) {
    
    // é˜²ç¯ï¼šå·²è®¿é—®è¿‡çš„èŠ‚ç‚¹ä¸å†å¤„ç†
    if (!visited.add(nodeId)) {
        return;
    }
    
    GraphNode node = nodes.get(nodeId);
    if (node == null) {
        return;  // èŠ‚ç‚¹ä¸å­˜åœ¨
    }
    
    // è·å–æ‰€æœ‰çˆ¶èŠ‚ç‚¹ï¼ˆä½¿ç”¨åå‘è¾¹ï¼‰
    Set<String> parents = reverseEdges.get(nodeId);
    
    if (parents == null || parents.isEmpty()) {
        // æ²¡æœ‰çˆ¶èŠ‚ç‚¹ï¼Œè¿™æ˜¯é¡¶ç«¯èŠ‚ç‚¹
        topmostNodes.add(nodeId);
    } else {
        // é€’å½’å‘ä¸Šéå†æ‰€æœ‰çˆ¶èŠ‚ç‚¹
        for (String parentId : parents) {
            traverseUpward(parentId, visited, topmostNodes);
        }
    }
}
```

**å…³é”®ç‚¹**:
1. ä½¿ç”¨ `visited` é›†åˆé˜²æ­¢ç¯
2. æ”¶é›†æ‰€æœ‰é¡¶ç«¯èŠ‚ç‚¹ï¼ˆæ²¡æœ‰çˆ¶èŠ‚ç‚¹çš„èŠ‚ç‚¹ï¼‰
3. æ”¯æŒå¤šä¸ªçˆ¶èŠ‚ç‚¹çš„æƒ…å†µï¼ˆè™½ç„¶è¿›ç¨‹é“¾é€šå¸¸æ˜¯æ ‘ç»“æ„ï¼‰

#### é˜¶æ®µ2: å‘ä¸‹éå†

```java
private void traverseDownward(
        String nodeId, 
        Set<String> visited) {
    
    // é˜²ç¯ï¼šå·²è®¿é—®è¿‡çš„èŠ‚ç‚¹ä¸å†å¤„ç†
    if (!visited.add(nodeId)) {
        return;
    }
    
    // è·å–æ‰€æœ‰å­èŠ‚ç‚¹ï¼ˆä½¿ç”¨å‰å‘è¾¹ï¼‰
    Set<String> children = edges.get(nodeId);
    
    if (children != null) {
        // é€’å½’å‘ä¸‹éå†æ‰€æœ‰å­èŠ‚ç‚¹
        for (String childId : children) {
            traverseDownward(childId, visited);
        }
    }
}
```

**å…³é”®ç‚¹**:
1. DFSæ·±åº¦ä¼˜å…ˆéå†
2. ä½¿ç”¨ `visited` é›†åˆé˜²æ­¢é‡å¤è®¿é—®
3. éå†æ‰€æœ‰å­åˆ†æ”¯

### 1.4 å¤æ‚åº¦åˆ†æ

**æ—¶é—´å¤æ‚åº¦**: O(V + E)
- V: èŠ‚ç‚¹æ•°
- E: è¾¹æ•°
- æ¯ä¸ªèŠ‚ç‚¹å’Œè¾¹æœ€å¤šè®¿é—®ä¸€æ¬¡

**ç©ºé—´å¤æ‚åº¦**: O(V)
- visited é›†åˆ: O(V)
- é€’å½’æ ˆæ·±åº¦: O(h)ï¼Œhä¸ºæ ‘çš„é«˜åº¦

### 1.5 ç¤ºä¾‹æ¼”ç¤º

**åœºæ™¯1: æœ‰æ ¹èŠ‚ç‚¹çš„å®Œæ•´æ ‘**

```
è¾“å…¥å›¾:
         ROOT
          |
        NODE_A
       /     \
    NODE_B   NODE_C (èµ·ç‚¹)
      |        |
  NODE_D    NODE_E
      |
  NODE_F

æ‰§è¡Œè¿‡ç¨‹:
  é˜¶æ®µ1 (å‘ä¸Š):
    NODE_C â†’ visited: {NODE_C}
    NODE_A â†’ visited: {NODE_C, NODE_A}
    ROOT â†’ visited: {NODE_C, NODE_A, ROOT}
    topmostNodes: {ROOT}
  
  é˜¶æ®µ2 (å‘ä¸‹):
    ä»ROOTå¼€å§‹:
      ROOT â†’ NODE_A â†’ visited: {NODE_C, NODE_A, ROOT}  (å·²è®¿é—®,è·³è¿‡)
      NODE_A â†’ NODE_B â†’ visited: {NODE_C, NODE_A, ROOT, NODE_B}
      NODE_B â†’ NODE_D â†’ visited: {..., NODE_D}
      NODE_D â†’ NODE_F â†’ visited: {..., NODE_F}
      NODE_A â†’ NODE_C â†’ visited: {...}  (å·²è®¿é—®,è·³è¿‡)
      NODE_C â†’ NODE_E â†’ visited: {..., NODE_E}
  
ç»“æœ: {ROOT, NODE_A, NODE_B, NODE_C, NODE_D, NODE_E, NODE_F}  âœ…
```

**åœºæ™¯2: æ–­é“¾ï¼ˆæ— æ ¹èŠ‚ç‚¹ï¼‰**

```
è¾“å…¥å›¾:
      NODE_A (æœ€é¡¶ç«¯ï¼Œä½†ä¸æ˜¯æ ¹)
          |
        NODE_B
       /     \
    NODE_C   NODE_D (èµ·ç‚¹)
      |        |
  NODE_E    NODE_F

æ‰§è¡Œè¿‡ç¨‹:
  é˜¶æ®µ1 (å‘ä¸Š):
    NODE_D â†’ NODE_B â†’ NODE_A
    topmostNodes: {NODE_A}
  
  é˜¶æ®µ2 (å‘ä¸‹):
    ä»NODE_Aå¼€å§‹éå†æ•´æ£µæ ‘
  
ç»“æœ: {NODE_A, NODE_B, NODE_C, NODE_D, NODE_E, NODE_F}  âœ…
```

**åœºæ™¯3: å¤šä¸ªèµ·ç‚¹**

```
è¾“å…¥å›¾:
         ROOT
          |
        NODE_A
       /     \
    NODE_B (èµ·ç‚¹1)   NODE_C (èµ·ç‚¹2)
      |                |
  NODE_D            NODE_E

å¤„ç†æ–¹å¼:
  åˆ†åˆ«è°ƒç”¨ fullTreeTraversal(NODE_B) å’Œ fullTreeTraversal(NODE_C)
  ç„¶ååˆå¹¶ç»“æœï¼ˆä½¿ç”¨Setè‡ªåŠ¨å»é‡ï¼‰

ç»“æœ: {ROOT, NODE_A, NODE_B, NODE_C, NODE_D, NODE_E}  âœ…
```

---

## 2. è™šæ‹Ÿçˆ¶èŠ‚ç‚¹æ‰¹é‡åˆ›å»ºç®—æ³•

### 2.1 ç®—æ³•æ¦‚è¿°

**ç®—æ³•åç§°**: `createVirtualParentsForSubgraph`

**æ‰€åœ¨ç±»**: `ProcessChainGraph.java`

**åŠŸèƒ½**: ä¸ºå­å›¾ä¸­ç¼ºå¤±çˆ¶èŠ‚ç‚¹çš„èŠ‚ç‚¹æ‰¹é‡åˆ›å»ºè™šæ‹Ÿçˆ¶èŠ‚ç‚¹

**æ ¸å¿ƒä¼˜åŒ–**: 
- å¤šä¸ªå­èŠ‚ç‚¹å…±äº«ä¸€ä¸ªè™šæ‹Ÿçˆ¶èŠ‚ç‚¹
- ä»å­èŠ‚ç‚¹çš„æ—¥å¿—/å‘Šè­¦ä¸­æå–çˆ¶è¿›ç¨‹ä¿¡æ¯
- é¿å…é‡å¤åˆ›å»º

### 2.2 ç®—æ³•åŸç†

**é—®é¢˜åœºæ™¯**:

```
åŸå§‹å®Œæ•´å›¾:
  PARENT_X â†’ NODE_A â†’ NODE_B
             (å‘Šè­¦)

å­å›¾æå–å:
  [PARENT_Xç¼ºå¤±] â†’ NODE_A â†’ NODE_B
  
é—®é¢˜: NODE_Açš„parentProcessGuidæŒ‡å‘PARENT_Xï¼Œä½†PARENT_Xä¸åœ¨å­å›¾ä¸­
```

**è§£å†³æ–¹æ¡ˆ**:

```
åˆ›å»ºè™šæ‹Ÿçˆ¶èŠ‚ç‚¹:
  VIRTUAL_PARENT_X â­ (è™šæ‹Ÿ) â†’ NODE_A â†’ NODE_B

è™šæ‹Ÿçˆ¶èŠ‚ç‚¹ç‰¹å¾:
  - isVirtual = true
  - ä»NODE_Açš„æ—¥å¿—/å‘Šè­¦ä¸­æå–çˆ¶è¿›ç¨‹ä¿¡æ¯
  - åªåŒ…å«åŸºæœ¬ä¿¡æ¯ï¼ˆè¿›ç¨‹åã€è·¯å¾„ç­‰ï¼‰
```

**å…±äº«ä¼˜åŒ–**:

```
åœºæ™¯: å¤šä¸ªå­èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ç›¸åŒ
  NODE_A (parentGuid = PARENT_SHARED)
  NODE_B (parentGuid = PARENT_SHARED)
  NODE_C (parentGuid = PARENT_SHARED)

ä¼ ç»Ÿæ–¹æ¡ˆ:
  åˆ›å»º3ä¸ªè™šæ‹Ÿçˆ¶èŠ‚ç‚¹  âŒ (å†—ä½™)

ä¼˜åŒ–æ–¹æ¡ˆ:
  åªåˆ›å»º1ä¸ªè™šæ‹Ÿçˆ¶èŠ‚ç‚¹  âœ…
  
ç»“æœ:
  PARENT_SHARED â­ (è™šæ‹Ÿ)
     â”œâ”€â†’ NODE_A
     â”œâ”€â†’ NODE_B
     â””â”€â†’ NODE_C
```

### 2.3 ç®—æ³•å®ç°

#### æ ¸å¿ƒæ–¹æ³•

```java
public void createVirtualParentsForSubgraph(
        Set<String> subgraphNodeIds,
        Set<String> traceIds) {
    
    // ç¬¬1æ­¥: æ”¶é›†ç¼ºå¤±çˆ¶èŠ‚ç‚¹çš„èŠ‚ç‚¹
    Map<String, List<GraphNode>> missingParents = new HashMap<>();
    
    for (String nodeId : subgraphNodeIds) {
        GraphNode node = nodes.get(nodeId);
        String parentGuid = node.getParentProcessGuid();
        
        // æ¡ä»¶: æœ‰parentGuid && çˆ¶èŠ‚ç‚¹ä¸åœ¨å­å›¾ä¸­ && ä¸æ˜¯æ ¹èŠ‚ç‚¹
        if (parentGuid != null 
                && !subgraphNodeIds.contains(parentGuid)
                && !traceIds.contains(node.getProcessGuid())) {
            
            missingParents.computeIfAbsent(parentGuid, k -> new ArrayList<>())
                         .add(node);
        }
    }
    
    // ç¬¬2æ­¥: æ‰¹é‡åˆ›å»ºè™šæ‹Ÿçˆ¶èŠ‚ç‚¹
    for (Map.Entry<String, List<GraphNode>> entry : missingParents.entrySet()) {
        String parentGuid = entry.getKey();
        List<GraphNode> children = entry.getValue();
        
        // åˆ›å»ºè™šæ‹Ÿçˆ¶èŠ‚ç‚¹
        GraphNode virtualParent = createVirtualParentNode(parentGuid, children);
        virtualParent.setIsVirtual(true);
        
        // æ·»åŠ åˆ°å›¾ä¸­
        nodes.put(parentGuid, virtualParent);
        
        // å»ºç«‹çˆ¶å­è¾¹
        for (GraphNode child : children) {
            addEdge(parentGuid, child.getProcessGuid());
        }
    }
}
```

#### åˆ›å»ºè™šæ‹Ÿçˆ¶èŠ‚ç‚¹

```java
private GraphNode createVirtualParentNode(
        String parentGuid,
        List<GraphNode> children) {
    
    GraphNode virtualParent = new GraphNode();
    virtualParent.setProcessGuid(parentGuid);
    virtualParent.setNodeType("process");
    virtualParent.setIsVirtual(true);
    
    // å°è¯•ä»å­èŠ‚ç‚¹çš„æ—¥å¿—ä¸­æå–çˆ¶è¿›ç¨‹ä¿¡æ¯
    for (GraphNode child : children) {
        // ä¼˜å…ˆä»æ—¥å¿—æå–
        if (child.getLogs() != null) {
            for (RawLog log : child.getLogs()) {
                if (parentGuid.equals(log.getParentProcessGuid())) {
                    // æ‰¾åˆ°äº†çˆ¶è¿›ç¨‹ä¿¡æ¯
                    extractParentInfoFromLog(virtualParent, log);
                    return virtualParent;
                }
            }
        }
        
        // å…¶æ¬¡ä»å‘Šè­¦æå–
        if (child.getAlarms() != null) {
            for (RawAlarm alarm : child.getAlarms()) {
                if (parentGuid.equals(alarm.getParentProcessGuid())) {
                    extractParentInfoFromAlarm(virtualParent, alarm);
                    return virtualParent;
                }
            }
        }
    }
    
    // å¦‚æœéƒ½æå–ä¸åˆ°ï¼Œä½¿ç”¨é»˜è®¤ä¿¡æ¯
    virtualParent.addLog(createDefaultLog(parentGuid));
    
    return virtualParent;
}
```

#### æå–çˆ¶è¿›ç¨‹ä¿¡æ¯

```java
private void extractParentInfoFromLog(GraphNode virtualParent, RawLog log) {
    RawLog parentLog = new RawLog();
    parentLog.setProcessGuid(virtualParent.getProcessGuid());
    parentLog.setLogType("process");
    
    // ä»å­èŠ‚ç‚¹æ—¥å¿—çš„çˆ¶è¿›ç¨‹å­—æ®µæå–ä¿¡æ¯
    parentLog.setProcessName(log.getParentProcessName());
    parentLog.setImage(log.getParentImage());
    parentLog.setCommandLine(log.getParentCommandLine());
    
    virtualParent.addLog(parentLog);
}
```

### 2.4 ç¤ºä¾‹æ¼”ç¤º

**åœºæ™¯1: å•ä¸ªå­èŠ‚ç‚¹ç¼ºå¤±çˆ¶èŠ‚ç‚¹**

```
åŸå§‹å›¾:
  PARENT_X (info: cmd.exe) â†’ NODE_A â†’ NODE_B
                              (å‘Šè­¦)

å­å›¾æå–:
  subgraphNodeIds = {NODE_A, NODE_B}

æ‰§è¡Œè¿‡ç¨‹:
  1. æ”¶é›†ç¼ºå¤±çˆ¶èŠ‚ç‚¹:
     NODE_A.parentGuid = "PARENT_X"
     PARENT_X ä¸åœ¨å­å›¾ä¸­
     missingParents = {"PARENT_X": [NODE_A]}
  
  2. åˆ›å»ºè™šæ‹Ÿçˆ¶èŠ‚ç‚¹:
     ä»NODE_Açš„æ—¥å¿—ä¸­æå–çˆ¶è¿›ç¨‹ä¿¡æ¯
     virtualParent = {
       processGuid: "PARENT_X",
       processName: "cmd.exe",  (ä»æ—¥å¿—æå–)
       isVirtual: true
     }
  
  3. å»ºç«‹è¾¹:
     addEdge("PARENT_X", "NODE_A")

ç»“æœ:
  VIRTUAL_PARENT_X â­ (cmd.exe) â†’ NODE_A â†’ NODE_B
```

**åœºæ™¯2: å¤šä¸ªå­èŠ‚ç‚¹å…±äº«çˆ¶èŠ‚ç‚¹**

```
åŸå§‹å›¾:
  PARENT_SHARED â†’ NODE_A
  PARENT_SHARED â†’ NODE_B
  PARENT_SHARED â†’ NODE_C

å­å›¾æå–:
  subgraphNodeIds = {NODE_A, NODE_B, NODE_C}

æ‰§è¡Œè¿‡ç¨‹:
  1. æ”¶é›†ç¼ºå¤±çˆ¶èŠ‚ç‚¹:
     missingParents = {"PARENT_SHARED": [NODE_A, NODE_B, NODE_C]}
  
  2. åˆ›å»ºè™šæ‹Ÿçˆ¶èŠ‚ç‚¹:
     åªåˆ›å»º1ä¸ª VIRTUAL_PARENT_SHARED âœ…
  
  3. å»ºç«‹è¾¹:
     addEdge("PARENT_SHARED", "NODE_A")
     addEdge("PARENT_SHARED", "NODE_B")
     addEdge("PARENT_SHARED", "NODE_C")

ç»“æœ:
  VIRTUAL_PARENT_SHARED â­
     â”œâ”€â†’ NODE_A
     â”œâ”€â†’ NODE_B
     â””â”€â†’ NODE_C
```

---

## 3. å‘Šè­¦é€‰ä¸¾ç®—æ³•

### 3.1 ç®—æ³•æ¦‚è¿°

**ç®—æ³•åç§°**: `electAlarms`

**æ‰€åœ¨ç±»**: `AlarmElectionUtil.java`

**åŠŸèƒ½**: ä»å¤šä¸ªå‘Šè­¦ç»„ä¸­é€‰å‡ºæœ€ä¸¥é‡çš„ç»„

**é€‰ä¸¾è§„åˆ™**:
```
1. ç½‘ç«¯å…³è”ä¼˜å…ˆ (associatedEventIdåŒ¹é…)
2. é«˜å±å‘Šè­¦ç»„ä¼˜å…ˆ (å¨èƒç­‰çº§=é«˜)
3. ä¸­å±å‘Šè­¦ç»„ä¼˜å…ˆ (å¨èƒç­‰çº§=ä¸­)
4. ä½å±å‘Šè­¦ç»„ä¼˜å…ˆ (å¨èƒç­‰çº§=ä½)
5. æ•°é‡å¤šçš„ä¼˜å…ˆ (åŒç­‰çº§æ¯”è¾ƒæ•°é‡)
6. æ—¶é—´æ—©çš„ä¼˜å…ˆ (æœ€åçš„tie-breaker)
```

### 3.2 ç®—æ³•å®ç°

```java
public static List<RawAlarm> electAlarms(
        List<RawAlarm> allAlarms,
        String associatedEventId) {
    
    if (allAlarms == null || allAlarms.isEmpty()) {
        return Collections.emptyList();
    }
    
    // æ­¥éª¤1: ç½‘ç«¯å…³è”ä¼˜å…ˆ
    if (associatedEventId != null && !associatedEventId.trim().isEmpty()) {
        List<RawAlarm> associated = allAlarms.stream()
            .filter(a -> associatedEventId.equals(a.getEventId()))
            .collect(Collectors.toList());
        
        if (!associated.isEmpty()) {
            return associated;  // ç›´æ¥è¿”å›å…³è”å‘Šè­¦
        }
    }
    
    // æ­¥éª¤2: æŒ‰ traceId åˆ†ç»„
    Map<String, List<RawAlarm>> groups = allAlarms.stream()
        .collect(Collectors.groupingBy(RawAlarm::getTraceId));
    
    // æ­¥éª¤3: è®¡ç®—æ¯ç»„çš„å¨èƒç»Ÿè®¡
    Map<String, ThreatStatistics> stats = new HashMap<>();
    for (Map.Entry<String, List<RawAlarm>> entry : groups.entrySet()) {
        stats.put(entry.getKey(), calculateThreatStats(entry.getValue()));
    }
    
    // æ­¥éª¤4: é€‰æ‹©æœ€ä¸¥é‡çš„ç»„
    String selectedTraceId = stats.entrySet().stream()
        .max((e1, e2) -> compareThreatStats(e1.getValue(), e2.getValue()))
        .map(Map.Entry::getKey)
        .orElse(null);
    
    return groups.get(selectedTraceId);
}
```

### 3.3 å¨èƒç»Ÿè®¡

```java
class ThreatStatistics {
    int highCount;     // é«˜å±æ•°é‡
    int mediumCount;   // ä¸­å±æ•°é‡
    int lowCount;      // ä½å±æ•°é‡
    int totalCount;    // æ€»æ•°
}

private static ThreatStatistics calculateThreatStats(List<RawAlarm> alarms) {
    ThreatStatistics stats = new ThreatStatistics();
    
    for (RawAlarm alarm : alarms) {
        String severity = alarm.getThreatSeverity();
        
        if ("é«˜".equals(severity) || "HIGH".equalsIgnoreCase(severity)) {
            stats.highCount++;
        } else if ("ä¸­".equals(severity) || "MEDIUM".equalsIgnoreCase(severity)) {
            stats.mediumCount++;
        } else if ("ä½".equals(severity) || "LOW".equalsIgnoreCase(severity)) {
            stats.lowCount++;
        }
        
        stats.totalCount++;
    }
    
    return stats;
}
```

### 3.4 å¨èƒæ¯”è¾ƒ

```java
private static int compareThreatStats(
        ThreatStatistics stats1,
        ThreatStatistics stats2) {
    
    // 1. æ¯”è¾ƒé«˜å±æ•°é‡
    if (stats1.highCount != stats2.highCount) {
        return stats1.highCount - stats2.highCount;
    }
    
    // 2. æ¯”è¾ƒä¸­å±æ•°é‡
    if (stats1.mediumCount != stats2.mediumCount) {
        return stats1.mediumCount - stats2.mediumCount;
    }
    
    // 3. æ¯”è¾ƒä½å±æ•°é‡
    if (stats1.lowCount != stats2.lowCount) {
        return stats1.lowCount - stats2.lowCount;
    }
    
    // 4. æ¯”è¾ƒæ€»æ•°
    return stats1.totalCount - stats2.totalCount;
}
```

### 3.5 ç¤ºä¾‹æ¼”ç¤º

**åœºæ™¯: å¤šä¸ªå‘Šè­¦ç»„é€‰ä¸¾**

```
è¾“å…¥:
  å‘Šè­¦ç»„1 (traceId=T001):
    - é«˜å±Ã—2, ä¸­å±Ã—1  â†’ stats: {high:2, medium:1, low:0, total:3}
  
  å‘Šè­¦ç»„2 (traceId=T002):
    - é«˜å±Ã—1, ä¸­å±Ã—3  â†’ stats: {high:1, medium:3, low:0, total:4}
  
  å‘Šè­¦ç»„3 (traceId=T003):
    - ä¸­å±Ã—5          â†’ stats: {high:0, medium:5, low:0, total:5}

æ¯”è¾ƒè¿‡ç¨‹:
  T001 vs T002:
    é«˜å±: 2 > 1  â†’ T001 èƒœå‡º
  
  T001 vs T003:
    é«˜å±: 2 > 0  â†’ T001 èƒœå‡º

ç»“æœ: é€‰æ‹©å‘Šè­¦ç»„1 (T001) âœ…
```

---

## 4. å¼ºåˆ¶è£å‰ªç®—æ³•

### 4.1 ç®—æ³•æ¦‚è¿°

**ç®—æ³•åç§°**: `forcePrune`

**æ‰€åœ¨ç±»**: `ForcePruner.java`

**è§¦å‘æ¡ä»¶**: èŠ‚ç‚¹æ•° > 100

**ç›®æ ‡**: è£å‰ªåˆ° 30 ä¸ªèŠ‚ç‚¹

**æ ¸å¿ƒç­–ç•¥**:
1. æŒ‰ traceId åˆ†ç»„ï¼ˆæœ€å¤š3ä¸ªtraceIdï¼‰
2. å¹³åˆ†é…é¢
3. ä¼˜å…ˆä¿ç•™ç½‘ç«¯å…³è”èŠ‚ç‚¹å’Œå…³é”®è·¯å¾„
4. ç¡®å®šæ€§ç®—æ³•ï¼ˆç»“æœå¯å¤ç°ï¼‰

### 4.2 ç®—æ³•æµç¨‹

```
è¾“å…¥: èŠ‚ç‚¹æ•° = 150ï¼ˆè¶…è¿‡é˜ˆå€¼100ï¼‰

æ­¥éª¤1: æŒ‰ traceId åˆ†ç»„
  traceId_1: 60ä¸ªèŠ‚ç‚¹
  traceId_2: 50ä¸ªèŠ‚ç‚¹
  traceId_3: 40ä¸ªèŠ‚ç‚¹

æ­¥éª¤2: é€‰æ‹© top 3 traceId
  (å¦‚æœè¶…è¿‡3ä¸ªï¼ŒæŒ‰å­—å…¸åºé€‰æ‹©å‰3ä¸ª)

æ­¥éª¤3: è®¡ç®—é…é¢
  æ€»é…é¢: 30
  æ¯ä¸ªtraceId: 30 / 3 = 10ä¸ªèŠ‚ç‚¹

æ­¥éª¤4: ä¸ºæ¯ä¸ªtraceIdé€‰æ‹©èŠ‚ç‚¹
  ä¼˜å…ˆçº§:
    1. ç½‘ç«¯å…³è”è¿›ç¨‹èŠ‚ç‚¹
    2. å…³è”èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„å•é“¾
    3. ç½‘ç«¯å…³è”å®ä½“èŠ‚ç‚¹
    4. å…¶ä»–èŠ‚ç‚¹ï¼ˆæ·±åº¦ä¼˜å…ˆ + GUIDå­—å…¸åºï¼‰

æ­¥éª¤5: æ‰§è¡Œè£å‰ª
  ä¿ç•™é€‰ä¸­çš„30ä¸ªèŠ‚ç‚¹
  ç§»é™¤å…¶ä»–120ä¸ªèŠ‚ç‚¹
```

### 4.3 æ ¸å¿ƒå®ç°

```java
public static ForcePruneResult forcePrune(
        ProcessChainGraph graph,
        Set<String> networkAssociatedEventIds,
        Set<String> traceIds) {
    
    // æ­¥éª¤1: æŒ‰ traceId åˆ†ç»„
    Map<String, TraceGroup> traceGroups = groupByTraceId(graph, traceIds);
    
    // æ­¥éª¤2: é€‰æ‹© top 3 traceId
    List<String> selectedTraceIds = selectTopTraceIds(traceGroups, 3);
    
    // æ­¥éª¤3: è®¡ç®—é…é¢
    int quotaPerTrace = FORCE_PRUNE_TARGET / selectedTraceIds.size();
    int remainder = FORCE_PRUNE_TARGET % selectedTraceIds.size();
    
    // æ­¥éª¤4: ä¸ºæ¯ä¸ª traceId é€‰æ‹©èŠ‚ç‚¹
    Set<String> nodesToKeep = new LinkedHashSet<>();
    
    for (int i = 0; i < selectedTraceIds.size(); i++) {
        String traceId = selectedTraceIds.get(i);
        TraceGroup group = traceGroups.get(traceId);
        
        // ç¬¬ä¸€ä¸ª traceId åˆ†é…ä½™æ•°
        int quota = quotaPerTrace + (i == 0 ? remainder : 0);
        
        Set<String> selected = selectNodesForTrace(
            group, quota, graph, networkAssociatedEventIds
        );
        
        nodesToKeep.addAll(selected);
    }
    
    // æ­¥éª¤5: æ‰§è¡Œè£å‰ª
    graph.retainNodes(nodesToKeep);
    
    return new ForcePruneResult(
        true,  // è£å‰ªæˆåŠŸ
        nodesToKeep.size(),
        graph.getNodeCount()
    );
}
```

### 4.4 èŠ‚ç‚¹é€‰æ‹©ç­–ç•¥

```java
private static Set<String> selectNodesForTrace(
        TraceGroup group,
        int quota,
        ProcessChainGraph graph,
        Set<String> networkAssociatedEventIds) {
    
    Set<String> selected = new LinkedHashSet<>();
    
    // æ­¥éª¤1: ä¿ç•™ç½‘ç«¯å…³è”è¿›ç¨‹èŠ‚ç‚¹
    Set<String> associatedProcessNodes = findAssociatedProcessNodes(
        group, networkAssociatedEventIds
    );
    selected.addAll(associatedProcessNodes);
    
    // æ­¥éª¤2: çº§è”ä¿ç•™å•é“¾ï¼ˆå…³è”èŠ‚ç‚¹ â†’ æ ¹èŠ‚ç‚¹ï¼‰
    for (String associatedNode : associatedProcessNodes) {
        Set<String> chainNodes = traceUpwardToRoot(
            associatedNode, group.rootNodeId, graph
        );
        selected.addAll(chainNodes);
    }
    
    // æ­¥éª¤3: ä¿ç•™ç½‘ç«¯å…³è”çš„å®ä½“èŠ‚ç‚¹
    Set<String> associatedEntityNodes = findAssociatedEntityNodes(
        group, networkAssociatedEventIds
    );
    selected.addAll(associatedEntityNodes);
    
    // æ­¥éª¤4: å¦‚æœè¿˜æœ‰é…é¢ï¼Œä¿ç•™å…¶ä»–èŠ‚ç‚¹
    if (selected.size() < quota) {
        int remaining = quota - selected.size();
        Set<String> otherNodes = selectRemainingNodes(
            group, selected, remaining, graph
        );
        selected.addAll(otherNodes);
    }
    
    // æ­¥éª¤5: å¦‚æœè¶…è¿‡é…é¢ï¼Œè£å‰ªåˆ°é…é¢
    if (selected.size() > quota) {
        selected = trimToQuota(selected, quota);
    }
    
    return selected;
}
```

---

## 5. å®ä½“æå–ç®—æ³•

### 5.1 ç®—æ³•æ¦‚è¿°

**ç®—æ³•åç§°**: `extractEntities`

**æ‰€åœ¨ç±»**: `EntityExtractor.java`

**åŠŸèƒ½**: ä»è£å‰ªåçš„è¿›ç¨‹èŠ‚ç‚¹æå–å®ä½“ï¼ˆæ–‡ä»¶ã€åŸŸåã€ç½‘ç»œã€æ³¨å†Œè¡¨ï¼‰

**æ ¸å¿ƒä¼˜åŒ–**: å»¶è¿Ÿæ‹†åˆ† - åªä¸ºä¿ç•™çš„è¿›ç¨‹æå–å®ä½“

### 5.2 ç®—æ³•æµç¨‹

```
è¾“å…¥: è£å‰ªåçš„30ä¸ªè¿›ç¨‹èŠ‚ç‚¹

æ­¥éª¤1: éå†è¿›ç¨‹èŠ‚ç‚¹
  for each processNode:
    æŒ‰ logType åˆ†ç»„æ—¥å¿—

æ­¥éª¤2: æå–å„ç±»å®ä½“
  - file æ—¥å¿— â†’ FileEntity
  - domain æ—¥å¿— â†’ DomainEntity
  - network æ—¥å¿— â†’ NetworkEntity
  - registry æ—¥å¿— â†’ RegistryEntity

æ­¥éª¤3: åˆ›å»ºå®ä½“èŠ‚ç‚¹
  - ç”Ÿæˆå”¯ä¸€ID
  - è®¾ç½® nodeType = "xxx_entity"
  - è®¾ç½® parentProcessGuid = processNode.id

æ­¥éª¤4: å»ºç«‹å…³è”è¾¹
  - åˆ›å»ºè¾¹: processNode â†’ entityNode

è¾“å‡º: å®ä½“èŠ‚ç‚¹ + å…³è”è¾¹
```

### 5.3 æ ¸å¿ƒå®ç°

```java
public static EntityExtractionResult extractEntities(
        Map<String, GraphNode> processNodes,
        Map<String, GraphNode> allNodes) {
    
    Map<String, GraphNode> entityNodes = new HashMap<>();
    List<Edge> entityEdges = new ArrayList<>();
    
    for (GraphNode processNode : processNodes.values()) {
        List<RawLog> logs = processNode.getLogs();
        
        if (logs == null || logs.isEmpty()) {
            // æ— æ—¥å¿—ï¼Œå°è¯•ä»å‘Šè­¦æå–
            extractFromAlarms(processNode, entityNodes, entityEdges);
            continue;
        }
        
        // æŒ‰ logType åˆ†ç»„
        Map<String, List<RawLog>> logsByType = logs.stream()
            .collect(Collectors.groupingBy(RawLog::getLogType));
        
        // æå–æ–‡ä»¶å®ä½“
        extractFileEntities(
            logsByType.get("file"), 
            processNode, 
            entityNodes, 
            entityEdges
        );
        
        // æå–åŸŸåå®ä½“
        extractDomainEntities(
            logsByType.get("domain"), 
            processNode, 
            entityNodes, 
            entityEdges
        );
        
        // æå–ç½‘ç»œå®ä½“
        extractNetworkEntities(
            logsByType.get("network"), 
            processNode, 
            entityNodes, 
            entityEdges
        );
        
        // æå–æ³¨å†Œè¡¨å®ä½“
        extractRegistryEntities(
            logsByType.get("registry"), 
            processNode, 
            entityNodes, 
            entityEdges
        );
    }
    
    return new EntityExtractionResult(entityNodes, entityEdges);
}
```

### 5.4 æ–‡ä»¶å®ä½“æå–

```java
private static void extractFileEntities(
        List<RawLog> fileLogs,
        GraphNode processNode,
        Map<String, GraphNode> entityNodes,
        List<Edge> entityEdges) {
    
    if (fileLogs == null || fileLogs.isEmpty()) {
        return;
    }
    
    for (RawLog fileLog : fileLogs) {
        // ç”Ÿæˆå®ä½“IDï¼ˆä½¿ç”¨MD5é¿å…é‡å¤ï¼‰
        String entityId = generateEntityId(fileLog);
        
        // é¿å…é‡å¤åˆ›å»º
        if (entityNodes.containsKey(entityId)) {
            continue;
        }
        
        // åˆ›å»ºå®ä½“èŠ‚ç‚¹
        GraphNode entityNode = new GraphNode();
        entityNode.setProcessGuid(entityId);
        entityNode.setNodeType("file_entity");
        entityNode.setParentProcessGuid(processNode.getProcessGuid());
        entityNode.addLog(fileLog);
        
        entityNodes.put(entityId, entityNode);
        
        // åˆ›å»ºè¾¹: è¿›ç¨‹ â†’ æ–‡ä»¶
        Edge edge = new Edge(
            processNode.getProcessGuid(),
            entityId,
            "æ–‡ä»¶æ“ä½œ"
        );
        entityEdges.add(edge);
    }
}
```

### 5.5 å®ä½“IDç”Ÿæˆ

```java
private static String generateEntityId(RawLog log) {
    StringBuilder sb = new StringBuilder();
    
    // æ–‡ä»¶å®ä½“: processGuid + targetFilename + eventType
    if ("file".equals(log.getLogType())) {
        sb.append(log.getProcessGuid())
          .append("|")
          .append(log.getTargetFilename())
          .append("|")
          .append(log.getEventType());
    }
    // åŸŸåå®ä½“: processGuid + queryName
    else if ("domain".equals(log.getLogType())) {
        sb.append(log.getProcessGuid())
          .append("|")
          .append(log.getQueryName());
    }
    // ç½‘ç»œå®ä½“: processGuid + destIp + destPort
    else if ("network".equals(log.getLogType())) {
        sb.append(log.getProcessGuid())
          .append("|")
          .append(log.getDestinationIp())
          .append("|")
          .append(log.getDestinationPort());
    }
    
    // ä½¿ç”¨MD5ç”Ÿæˆå”¯ä¸€ID
    return "ENTITY_" + md5(sb.toString());
}
```

---

## 6. æ‰©å±•æº¯æºç®—æ³•

### 6.1 ç®—æ³•æ¦‚è¿°

**ç®—æ³•åç§°**: `performExtension`

**æ‰€åœ¨ç±»**: `ProcessChainExtensionUtil.java`

**åŠŸèƒ½**: ä»æ ¹èŠ‚ç‚¹å‘ä¸Šè¿½æº¯çˆ¶/ç¥–çˆ¶è¿›ç¨‹ï¼ˆæœ€å¤š2å±‚ï¼‰

**ä½¿ç”¨åœºæ™¯**: æŸ¥çœ‹æ ¹èŠ‚ç‚¹çš„ä¸Šä¸‹æ–‡ï¼Œäº†è§£æ›´å®Œæ•´çš„æ”»å‡»æºå¤´

### 6.2 ç®—æ³•æµç¨‹

```
è¾“å…¥: æ ¹èŠ‚ç‚¹åˆ—è¡¨

æ­¥éª¤1: éå†æ ¹èŠ‚ç‚¹
  è·³è¿‡: EXPLOREèŠ‚ç‚¹ã€è™šæ‹Ÿæ ¹çˆ¶èŠ‚ç‚¹ã€æ–­é“¾èŠ‚ç‚¹

æ­¥éª¤2: å‘ä¸Šæ‰©å±•
  æŸ¥è¯¢çˆ¶è¿›ç¨‹æ—¥å¿—
  åˆ›å»ºæ‰©å±•èŠ‚ç‚¹ï¼ˆextensionDepth=1ï¼‰
  ç»§ç»­æŸ¥è¯¢ç¥–çˆ¶è¿›ç¨‹æ—¥å¿—
  åˆ›å»ºæ‰©å±•èŠ‚ç‚¹ï¼ˆextensionDepth=2ï¼‰

æ­¥éª¤3: æ›´æ–°isRootæ ‡è®°
  åŸæ ¹èŠ‚ç‚¹: isRoot = false
  æœ€é¡¶ç«¯èŠ‚ç‚¹: isRoot = true

æ­¥éª¤4: è°ƒæ•´æ¡¥æ¥ç‚¹ï¼ˆå¦‚æœæœ‰ï¼‰
  åŸæ¡¥æ¥: ç½‘ä¾§ â†’ ROOT
  æ–°æ¡¥æ¥: ç½‘ä¾§ â†’ GRANDPARENT

è¾“å‡º: æ‰©å±•åçš„èŠ‚ç‚¹å’Œè¾¹
```

### 6.3 æ ¸å¿ƒå®ç°

```java
public static Map<String, String> performExtension(
        Map<String, String> traceIdToRootMap,
        Map<String, String> hostToTraceId,
        List<ProcessNode> allNodes,
        List<ProcessEdge> allEdges,
        OptimizedESQueryService esQueryService,
        int maxDepth) {
    
    Map<String, String> updatedMap = new HashMap<>();
    
    for (Map.Entry<String, String> entry : traceIdToRootMap.entrySet()) {
        String traceId = entry.getKey();
        String rootNodeId = entry.getValue();
        
        // è·³è¿‡ä¸éœ€è¦æ‰©å±•çš„èŠ‚ç‚¹
        if (shouldSkip(rootNodeId, allNodes)) {
            updatedMap.put(traceId, rootNodeId);
            continue;
        }
        
        // å‘ä¸Šæ‰©å±•
        String topmostNodeId = extendFromNode(
            rootNodeId,
            hostToTraceId.get(traceId),
            allNodes,
            allEdges,
            esQueryService,
            maxDepth
        );
        
        updatedMap.put(traceId, topmostNodeId);
    }
    
    return updatedMap;
}
```

### 6.4 å‘ä¸Šæ‰©å±•

```java
private static String extendFromNode(
        String startNodeId,
        String hostAddress,
        List<ProcessNode> allNodes,
        List<ProcessEdge> allEdges,
        OptimizedESQueryService esQueryService,
        int maxDepth) {
    
    ProcessNode currentNode = findNodeById(startNodeId, allNodes);
    String currentNodeId = startNodeId;
    int depth = 0;
    
    while (depth < maxDepth) {
        // æŸ¥è¯¢çˆ¶è¿›ç¨‹æ—¥å¿—
        String parentGuid = queryParentGuid(currentNode);
        if (parentGuid == null) {
            break;  // æ— æ³•ç»§ç»­æ‰©å±•
        }
        
        RawLog parentLog = esQueryService.queryLogByGuid(
            parentGuid, 
            hostAddress
        );
        
        if (parentLog == null) {
            break;  // æŸ¥è¯¢ä¸åˆ°çˆ¶è¿›ç¨‹
        }
        
        // åˆ›å»ºæ‰©å±•èŠ‚ç‚¹
        ProcessNode parentNode = createExtensionNode(
            parentLog,
            depth + 1,
            currentNodeId
        );
        
        allNodes.add(parentNode);
        
        // åˆ›å»ºè¾¹
        ProcessEdge edge = new ProcessEdge();
        edge.setSource(parentNode.getNodeId());
        edge.setTarget(currentNodeId);
        edge.setVal("è¿›ç¨‹åˆ›å»º");
        
        allEdges.add(edge);
        
        currentNodeId = parentNode.getNodeId();
        currentNode = parentNode;
        depth++;
    }
    
    // æ›´æ–°isRootæ ‡è®°
    if (depth > 0) {
        findNodeById(startNodeId, allNodes)
            .getChainNode()
            .setIsRoot(false);
        
        findNodeById(currentNodeId, allNodes)
            .getChainNode()
            .setIsRoot(true);
    }
    
    return currentNodeId;
}
```

---

## 7. è§’è‰²ä¿®æ­£ç®—æ³•

### 7.1 ç®—æ³•æ¦‚è¿°

**ç®—æ³•åç§°**: `correctRoles`

**æ‰€åœ¨ç±»**: `NetworkNodeRoleCorrector.java`

**åŠŸèƒ½**: ä¿®æ­£ç½‘ç»œèŠ‚ç‚¹çš„æ”»å‡»è€…/å—å®³è€…è§’è‰²

**é—®é¢˜**: æœ‰äº›è¿›ç¨‹é“¾æ˜¯åå‘çš„ï¼ˆä»å—å®³è€…åˆ°æ”»å‡»è€…ï¼‰

### 7.2 è¯†åˆ«åå‘é“¾

```
æ­£å‘é“¾ï¼ˆæ­£å¸¸ï¼‰:
  æ”»å‡»è€…IP â†’ è·³æ¿æœº â†’ å—å®³è€…IP (ç›®æ ‡ä¸»æœº)
  
åå‘é“¾ï¼ˆéœ€è¦ä¿®æ­£ï¼‰:
  å—å®³è€…IP (ç›®æ ‡ä¸»æœº) â†’ è·³æ¿æœº â†’ æ”»å‡»è€…IP
```

**è¯†åˆ«è§„åˆ™**:

```java
boolean isReverse = 
    firstNode.getHostAddress().equals(targetHost) &&
    !lastNode.getHostAddress().equals(targetHost);
```

### 7.3 ä¿®æ­£ç­–ç•¥

```java
public static boolean correctRoles(
        List<ProcessNode> networkNodes,
        String targetHost) {
    
    if (networkNodes == null || networkNodes.isEmpty()) {
        return false;
    }
    
    // åˆ¤æ–­æ˜¯å¦æ˜¯åå‘é“¾
    ProcessNode firstNode = networkNodes.get(0);
    ProcessNode lastNode = networkNodes.get(networkNodes.size() - 1);
    
    boolean isReverse = 
        firstNode.getHostAddress().equals(targetHost) &&
        !lastNode.getHostAddress().equals(targetHost);
    
    if (!isReverse) {
        return false;  // ä¸éœ€è¦ä¿®æ­£
    }
    
    // ä¿®æ­£è§’è‰²
    for (ProcessNode node : networkNodes) {
        NodeColor color = node.getNodeColor();
        
        if (color != null) {
            // åè½¬è§’è‰²
            if ("victim".equals(color.getRole())) {
                color.setRole("attacker");
                color.setColor("#FF6B6B");  // çº¢è‰²
            } else if ("attacker".equals(color.getRole())) {
                color.setRole("victim");
                color.setColor("#4ECDC4");  // è“è‰²
            }
        }
    }
    
    return true;
}
```

---

**æœ€åæ›´æ–°**: 2025-12-08  
**æ–‡æ¡£ç»´æŠ¤è€…**: å¼€å‘å›¢é˜Ÿ

