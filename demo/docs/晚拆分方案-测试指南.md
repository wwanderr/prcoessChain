# 晚拆分方案 - 测试指南

## 🎯 核心问题

**症状**：实体没有被抽取出来，没有形成 `父进程 → 子进程 → 实体节点` 的三层结构。

**可能原因**：
1. **告警节点的 nodeType 设置错误**：如果告警的 `logType` 是 "file"，告警节点的 `nodeType` 被设置为 "file" 而不是 "process"，导致 `EntityExtractor.isProcessNode()` 跳过该节点
2. **代码没有重新编译**：修改后的代码没有编译生效
3. **实体日志的 logType 不匹配**：日志的 `logType` 不是 "file"/"domain"/"network"/"registry" 中的一个

---

## 🔧 已修复的问题

### 问题1：告警节点的 nodeType 设置错误

**修复位置**：`ProcessChainGraphBuilder.createNodeFromAlarm()`

**修复前**：
```java
// ❌ 错误：直接使用告警的 logType 作为 nodeType
String logType = alarm.getLogType();
if (logType == null || logType.isEmpty()) {
    logType = "process";
}
node.setNodeType(logType);  // 如果 logType="file"，nodeType 就是 "file"
```

**修复后**：
```java
// ✅ 正确：所有节点统一设置为 "process"
node.setNodeType("process");  // 始终是 "process"
```

**影响**：
- 修复前：如果告警的 `logType` 是 "file"，那么节点的 `nodeType` 也是 "file"，`EntityExtractor.isProcessNode()` 会跳过它，实体不会被提取
- 修复后：所有节点的 `nodeType` 都是 "process"，`EntityExtractor` 会正常处理

### 问题2：添加了详细的调试日志

**位置**：`EntityExtractor.extractEntitiesFromGraph()`

**新增日志**：
```
【实体提取】统计信息:
  - 进程节点数: XXX
  - 总日志数: XXX
  - 日志类型分布: {file=XX, domain=XX, process=XX}
  - 实体日志数: XXX
  - 创建实体节点数: XXX
```

**用途**：帮助快速定位问题

---

## 🧪 测试步骤

### 步骤1：重新编译代码

**必须执行 clean，确保旧的 class 文件被删除！**

```bash
cd demo
mvn clean compile -DskipTests
```

**检查编译是否成功**：
```bash
# Windows
dir target\classes\com\security\processchain\util\EntityExtractor.class
dir target\classes\com\security\processchain\service\ProcessChainGraphBuilder.class

# Linux/Mac
ls -l target/classes/com/security/processchain/util/EntityExtractor.class
ls -l target/classes/com/security/processchain/service/ProcessChainGraphBuilder.class
```

### 步骤2：运行专门的测试用例

我已经创建了一个专门的测试用例：`LateEntityExtractionTest`

```bash
mvn test -Dtest=LateEntityExtractionTest
```

**期望输出**：
```
【测试数据】告警数=1, 日志数=3
【测试数据】日志类型: file=1, domain=1, process=1

【建图后】节点数=2
【建图后-节点】id=TRACE_001, nodeType=process, 日志数=0
【建图后-节点】id=PROC_001, nodeType=process, 日志数=3
    日志: logType=file, opType=create
    日志: logType=domain, opType=connect
    日志: logType=process, opType=create

========================================
开始实体提取...
========================================

【实体提取】开始从进程节点提取实体，当前节点数=2
【实体提取】进程节点 PROC_001 包含实体日志: [file, domain]
【实体提取】创建实体节点: processGuid=PROC_001, entityType=file, entityNodeId=PROC_001_FILE_...
【实体提取】创建实体节点: processGuid=PROC_001, entityType=domain, entityNodeId=PROC_001_DOMAIN_...

【实体提取】统计信息:
  - 进程节点数: 2
  - 总日志数: 3
  - 日志类型分布: {file=1, domain=1, process=1}
  - 实体日志数: 2
  - 创建实体节点数: 2
  - 图节点总数: 4

【实体提取后】节点总数=4
【实体提取后-节点】id=TRACE_001, nodeType=process
【实体提取后-节点】id=PROC_001, nodeType=process
【实体提取后-节点】id=PROC_001_FILE_..., nodeType=file_entity
【实体提取后-节点】id=PROC_001_DOMAIN_..., nodeType=domain_entity

【节点类型统计】{process=2, file_entity=1, domain_entity=1}

✅ 测试通过！实体提取工作正常
```

**如果看到**：
```
【实体提取】⚠️ 警告: 有日志但没有创建实体节点！
```

说明问题仍然存在，继续排查。

### 步骤3：运行完整的集成测试

```bash
mvn test -Dtest=ProcessChainIntegrationTest
```

查看日志中的 `【实体提取】` 部分。

### 步骤4：运行实际系统并查看日志

启动应用后，使用实际数据测试，查看日志：

```
【建图】构建完成: 节点数=XXX, 根节点=X, 断链节点=X, 告警节点=X
【实体提取】开始从进程节点提取实体，当前节点数=XXX
【实体提取】统计信息:
  - 进程节点数: XXX
  - 日志类型分布: {file=XX, domain=XX, process=XX, ...}
  - 创建实体节点数: XXX
```

---

## 🔍 问题排查清单

### 检查1：代码是否重新编译？

```bash
# 查看 class 文件的修改时间
# Windows
dir /T:W target\classes\com\security\processchain\util\EntityExtractor.class

# Linux/Mac
ls -l --time=ctime target/classes/com/security/processchain/util/EntityExtractor.class
```

**期望**：修改时间应该是最近（刚刚编译的）

### 检查2：告警节点的 nodeType 是否正确？

在日志中搜索：`【建图】从告警创建节点`

**期望输出**：
```
【建图】从告警创建节点: processGuid=XXX, alarm.logType=file, node.nodeType=process
```

**错误输出**：
```
【建图】从告警创建节点: processGuid=XXX, logType=file, nodeType=file
```

如果看到错误输出，说明代码没有重新编译！

### 检查3：进程节点是否包含实体日志？

在日志中搜索：`【实体提取-调试】进程节点`

**期望看到**：
```
【实体提取-调试】进程节点: id=XXX, nodeType=process, 日志数=10
```

并且在日志类型分布中看到：
```
日志类型分布: {file=3, domain=2, process=5, ...}
```

**如果看到**：
```
日志类型分布: {process=10}
```

说明所有日志的 `logType` 都是 "process"，没有实体日志。这时需要检查：
- 输入数据是否包含 file/domain/network/registry 类型的日志？
- ES查询是否正确返回了这些日志？

### 检查4：实体节点是否被创建？

在日志中搜索：`创建实体节点数`

**期望**：
```
- 创建实体节点数: 150
```

**如果是**：
```
- 创建实体节点数: 0
```

说明实体提取逻辑有问题。继续检查：
1. 进程节点中是否有实体日志？（检查3）
2. `groupEntityLogs()` 是否正确识别实体日志？
3. `ENTITY_LOG_TYPES` 常量是否包含正确的类型？

---

## ✅ 验证成功的标志

运行测试后，应该看到：

### 1. 日志验证
- ✅ `【建图】从告警创建节点: ... node.nodeType=process`（所有告警节点都是 process）
- ✅ `【实体提取】进程节点 XXX 包含实体日志: [file, domain]`
- ✅ `创建实体节点数: XXX`（大于0）
- ✅ `【节点类型统计】{process=XX, file_entity=XX, domain_entity=XX}`

### 2. 输出验证
```json
{
  "nodes": [
    {
      "nodeId": "PROC_001",
      "nodeType": "process",
      "processEntity": { ... },   // ✅ 只有 processEntity
      "entity": null,
      "alarmNodeInfo": { ... }
    },
    {
      "nodeId": "PROC_001_FILE_abc123",
      "nodeType": "file_entity",
      "processEntity": null,
      "entity": { ... },           // ✅ 只有 entity
      "alarmNodeInfo": null
    }
  ]
}
```

### 3. 图结构验证

```
父进程 (TRACE_001, nodeType=process)
  ↓
子进程 (PROC_001, nodeType=process, 告警在这里)
  ↓                    ↓
文件实体             域名实体
(file_entity)        (domain_entity)
```

---

## 🚨 如果还是不工作

请提供以下信息：

1. **编译输出**（`mvn clean compile` 的完整输出）
2. **测试日志**（`mvn test -Dtest=LateEntityExtractionTest` 的完整输出）
3. **输入数据示例**（一个 RawAlarm 和对应的 RawLog 的 JSON）
4. **实际输出**（ProcessNode 的 JSON 结构）

---

**版本**：v1.1  
**日期**：2025-11-20  
**更新**：添加核心问题修复和测试指南

