# 进程链生成系统 - 项目总览与快速上手

> **文档版本**: v2.0  
> **最后更新**: 2025-12-08  
> **适用人群**: 新入职开发人员、项目维护者

---

## 📋 目录

1. [项目概述](#1-项目概述)
2. [快速开始](#2-快速开始)
3. [核心概念](#3-核心概念)
4. [系统架构](#4-系统架构)
5. [技术栈](#5-技术栈)
6. [项目结构](#6-项目结构)
7. [常见问题](#7-常见问题)

---

## 1. 项目概述

### 1.1 什么是进程链生成系统？

进程链生成系统是一个**企业级安全事件分析系统**，用于从EDR（端点检测与响应）告警和原始日志中自动构建、分析和可视化完整的进程调用链路。

### 1.2 核心价值

- 🔍 **威胁溯源**: 从告警节点向上追溯到攻击源头（根节点）
- 📊 **完整视图**: 构建包含父子进程、文件操作、网络连接的完整攻击链
- 🎯 **智能分析**: 自动识别关键节点、过滤冗余信息
- 🌐 **网端融合**: 将网络侧攻击路径与端点侧进程链合并

### 1.3 典型使用场景

```
场景1: 勒索软件分析
  告警: 检测到恶意文件加密行为
    ↓
  系统自动生成进程链:
    powershell.exe → cmd.exe → ransomware.exe → 文件加密操作
    ↑
  溯源到攻击入口: 钓鱼邮件附件

场景2: APT攻击分析  
  告警: 发现横向移动行为
    ↓
  系统生成网端融合链:
    攻击者IP → 跳板机 → 目标服务器 → 远程执行 → 权限提升 → 数据窃取
```

### 1.4 核心功能模块

| 功能模块 | 功能描述 | 状态 |
|---------|---------|------|
| **进程链构建** | 从告警和日志构建完整的进程执行链 | ✅ 完成 |
| **智能裁剪** | 基于重要性评分的节点裁剪（保留关键路径） | ✅ 完成 |
| **断链处理** | 自动检测并修复断链（创建EXPLORE虚拟根节点） | ✅ 完成 |
| **扩展溯源** | 向上追溯父/祖父进程，扩展攻击上下文 | ✅ 完成 |
| **实体提取** | 从进程节点提取文件、域名、网络等实体 | ✅ 完成 |
| **网端桥接** | 合并网络侧和端点侧的进程链 | ✅ 完成 |
| **角色修正** | 自动修正网络侧节点的攻击者/受害者角色 | ✅ 完成 |
| **合法性检查** | 检测并移除自环、重复边、无效边 | ✅ 完成 |

---

## 2. 快速开始

### 2.1 环境要求

- ☕ **Java**: JDK 8 或以上
- 📦 **Maven**: 3.6+ 
- 🔍 **Elasticsearch**: 7.17+ （可选，用于实际查询）
- 💻 **IDE**: IntelliJ IDEA / Eclipse（推荐IDEA）

### 2.2 快速启动（5分钟）

#### 步骤1: 克隆项目

```bash
git clone <your-repo-url>
cd prcoessChain/demo
```

#### 步骤2: 配置Elasticsearch（可选）

编辑 `src/main/resources/application.yml`:

```yaml
elasticsearch:
  hosts: localhost:9200  # 修改为你的ES地址
  username:              # 如果有认证则填写
  password:              # 如果有认证则填写
```

**注意**: 如果没有ES环境，可以跳过此步骤，使用Mock数据进行开发和测试。

#### 步骤3: 编译项目

```bash
mvn clean install
```

#### 步骤4: 启动应用

**方式1: 使用Maven**
```bash
mvn spring-boot:run
```

**方式2: 使用启动脚本（Windows）**
```bash
build.bat
```

**方式3: IDEA运行**
- 打开 `ProcessChainApplication.java`
- 点击 `main` 方法旁的绿色运行按钮

#### 步骤5: 验证启动

应用启动后，查看控制台输出：

```
Started ProcessChainApplication in 3.456 seconds (JVM running for 4.567)
```

### 2.3 第一个API调用

#### 2.3.1 准备测试数据

项目提供了测试数据生成工具，位于 `demo/dataSet/` 目录：

```bash
cd demo/dataSet
python generate_test_data.py
```

#### 2.3.2 调用API

使用Postman或curl调用API：

```bash
POST http://localhost:8080/api/processchain/batch-generate
Content-Type: application/json

{
  "ipAndAssociation": {
    "192.168.1.100": true,
    "192.168.1.101": false
  },
  "alarmIps": {
    "192.168.1.100": "EVENT_001"
  }
}
```

#### 2.3.3 查看响应

```json
{
  "traceIds": ["TRACE_001", "TRACE_002"],
  "hostAddresses": ["192.168.1.100", "192.168.1.101"],
  "nodes": [
    {
      "nodeId": "GUID_001",
      "logType": "PROCESS",
      "isChainNode": true,
      "chainNode": {
        "isRoot": true,
        "isAlarm": true,
        "processEntity": {
          "processName": "cmd.exe",
          "commandLine": "cmd.exe /c whoami"
        }
      }
    }
  ],
  "edges": [
    {
      "source": "GUID_001",
      "target": "GUID_002",
      "val": "进程创建"
    }
  ]
}
```

---

## 3. 核心概念

### 3.1 基础概念

#### 3.1.1 进程链 (Process Chain)

进程链是进程之间父子关系的有向图，展示了进程的创建、调用和关联关系。

```
示例:
  explorer.exe (父进程)
    ↓ 创建
  cmd.exe (子进程)
    ↓ 创建
  powershell.exe (孙进程)
    ↓ 创建
  malware.exe (曾孙进程)
```

#### 3.1.2 节点 (Node)

节点代表一个进程或实体，包含以下类型：

| 节点类型 | logType | 描述 | 示例 |
|---------|---------|------|------|
| **进程节点** | `process` | 进程创建/结束 | `cmd.exe` |
| **文件节点** | `file` | 文件创建/修改/删除 | `malware.dll` |
| **网络节点** | `network` | 网络连接 | `192.168.1.100:443` |
| **域名节点** | `domain` | 域名解析 | `evil.com` |
| **注册表节点** | `registry` | 注册表操作 | `HKEY_LOCAL_MACHINE\...` |

#### 3.1.3 边 (Edge)

边代表节点之间的关系：

```java
ProcessEdge {
  source: "GUID_PARENT",    // 源节点ID
  target: "GUID_CHILD",     // 目标节点ID
  val: "进程创建"            // 边的类型/描述
}
```

#### 3.1.4 根节点 (Root Node)

根节点是进程链的起点，识别规则：

```
根节点条件:
  1. processGuid == traceId
  2. parentProcessGuid == null 或为空
```

**示例**:
```
告警: { traceId: "T001", processGuid: "T001", parentProcessGuid: null }
→ 这是根节点 ✅

告警: { traceId: "T001", processGuid: "CHILD_001", parentProcessGuid: "T001" }
→ 这不是根节点 ❌
```

#### 3.1.5 traceId

traceId是溯源ID，用于关联同一攻击链的所有进程。同一个traceId下的所有进程节点属于同一棵进程树。

```
场景: 一次攻击产生多个进程
  traceId: TRACE_001
    ├─ ROOT_NODE (processGuid = TRACE_001)
    ├─ CHILD_1
    ├─ CHILD_2
    └─ CHILD_3
```

### 3.2 高级概念

#### 3.2.1 断链 (Broken Chain)

**定义**: 找不到根节点的进程链

**场景**:
```
场景1: 日志不完整
  [缺失根节点] ← NODE_MIDDLE ← NODE_CHILD

场景2: 父节点不存在
  NODE_MIDDLE (parentProcessGuid: "MISSING_PARENT")
```

**处理**: 系统自动创建EXPLORE虚拟根节点

```
EXPLORE_ROOT (虚拟根节点, isRoot=true)
  ├── BROKEN_NODE_1 (断链分支1)
  │   └── CHILD_1_1
  ├── BROKEN_NODE_2 (断链分支2)
  └── BROKEN_NODE_3 (断链分支3)
```

#### 3.2.2 虚拟父节点 (Virtual Parent Node)

当子图提取后发现某些节点的父节点不在子图中时，系统会创建虚拟父节点。

```
场景: 子图提取后缺失父节点
  原始图:
    PARENT_X → NODE_A → NODE_B
    
  子图提取（只提取NODE_A和NODE_B）:
    [PARENT_X不在子图中] → NODE_A → NODE_B
    
  创建虚拟父节点:
    VIRTUAL_PARENT_X ⭐ (虚拟) → NODE_A → NODE_B
```

**特点**:
- `isVirtual = true`
- 从日志或告警中提取父进程信息
- 只包含基本信息（进程名、路径等）

#### 3.2.3 网端桥接 (Network-Endpoint Bridge)

将网络侧攻击路径与端点侧进程链连接起来。

```
网络侧:
  攻击者IP (10.0.0.1) → 跳板机 (192.168.1.50) → 目标主机 (192.168.1.100)
  
端点侧:
  ROOT_NODE → CHILD_1 → CHILD_2
  
桥接后:
  攻击者IP → 跳板机 → 目标主机 ---桥接边---> ROOT_NODE → CHILD_1 → CHILD_2
```

#### 3.2.4 延迟拆分 (Late Split)

**核心优化**: 在建图阶段不拆分实体，而是在裁剪后才提取实体。

**优势**:
1. **性能优化**: 只为保留的进程提取实体，避免无用计算
2. **避免断链**: 如果先拆分再裁剪，会导致实体节点的父进程被裁剪，形成孤立节点
3. **日志累积优化**: 所有日志在建图阶段累积到进程节点，避免重复查找

```
传统方案（早拆分）:
  建图 → 拆分实体 → 裁剪 ❌ 问题: 实体的父进程可能被裁剪

延迟拆分方案:
  建图 → 裁剪 → 拆分实体 ✅ 优势: 只为保留的进程提取实体
```

---

## 4. 系统架构

### 4.1 分层架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Controller Layer                          │
│                  ProcessChainController                       │
│              - REST API接口                                   │
│              - 参数验证                                       │
└───────────────────────────┬─────────────────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────┐
│                    Service Layer                             │
│              ProcessChainServiceImpl                         │
│              - 业务逻辑编排                                   │
│              - 告警选举                                       │
│              - 进程链构建调度                                 │
└───────────────────────────┬─────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
        ▼                   ▼                   ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ ES查询服务    │  │ 图构建器      │  │ 工具类        │
│Optimized     │  │ProcessChain  │  │EntityExtract │
│ESQuery       │  │GraphBuilder  │  │ForcePruner   │
│Service       │  │              │  │Extension     │
└──────────────┘  └──────────────┘  └──────────────┘
```

### 4.2 核心处理流程

```
【阶段0: 数据准备】
  ├─ 查询告警 (ES MultiSearch)
  ├─ 告警选举 (选择最严重的告警组)
  └─ 查询日志 (ES Terms Query)
        ↓
【阶段1: 建图】ProcessChainGraphBuilder
  ├─ 创建进程节点 (GraphNode)
  ├─ 建立父子边关系
  ├─ 处理自引用节点
  └─ 累积日志到节点（不拆分实体）
        ↓
【阶段2: 子图提取】ProcessChainGraph.fullTreeTraversal
  ├─ 从告警/起点日志出发
  ├─ 全树遍历（向上到根 + 向下到叶）
  ├─ 收集连通子图的所有节点
  └─ 支持多traceId场景
        ↓
【阶段3: 虚拟父节点创建】(延迟拆分优化)
  ├─ 收集缺失父节点的节点
  ├─ 批量创建虚拟父节点
  └─ 建立虚拟父子边
        ↓
【阶段4: 图分析】
  ├─ 识别根节点
  ├─ 识别断链节点
  ├─ 创建EXPLORE虚拟根节点（如果有断链）
  └─ 调整虚拟父节点的父节点指向
        ↓
【阶段5: 图裁剪】ForcePruner
  ├─ 计算节点重要性评分
  ├─ 保留关键节点和路径
  ├─ 移除冗余节点
  └─ 验证裁剪结果
        ↓
【阶段6: 实体提取】EntityExtractor (延迟拆分)
  ├─ 从裁剪后的进程节点提取实体
  ├─ 创建 FileEntity、DomainEntity 等
  ├─ 优先从日志提取，无日志时从告警提取
  └─ 建立实体与进程的关联边
        ↓
【阶段7: 实体过滤】EntityFilterUtil
  ├─ 按 traceId 分组
  ├─ 每组保留最多10个实体
  ├─ 优先保留高危实体
  └─ 移除冗余实体
        ↓
【阶段8: 扩展溯源】ProcessChainExtensionUtil (可选)
  ├─ 从根节点向上追溯父/祖父进程
  ├─ 创建扩展节点（最多2层）
  └─ 更新isRoot标记
        ↓
【阶段9: 网端桥接】(可选)
  ├─ 识别网侧victim节点和端侧root节点
  ├─ 创建桥接边
  ├─ 修正节点角色（攻击者/受害者）
  └─ 合并网侧和端侧节点/边
        ↓
【阶段10: 合法性检查】ProcessChainValidator
  ├─ 移除无效边（指向不存在的节点）
  ├─ 移除自环
  ├─ 移除重复边
  └─ 检测简单环
        ↓
【阶段11: 输出转换】IncidentConverters
  ├─ 转换为前端所需格式
  ├─ 填充实体字段
  └─ 生成最终JSON
        ↓
【输出: IncidentProcessChain】
```

### 4.3 核心类职责

| 类名 | 职责 | 文件路径 |
|------|------|----------|
| `ProcessChainController` | REST API入口 | `controller/ProcessChainController.java` |
| `ProcessChainServiceImpl` | 业务逻辑编排 | `service/impl/ProcessChainServiceImpl.java` |
| `OptimizedESQueryService` | ES批量查询优化 | `service/OptimizedESQueryService.java` |
| `AlarmElectionUtil` | 告警选举算法 | `util/AlarmElectionUtil.java` |
| `ProcessChainGraphBuilder` | 建图（创建节点和边） | `service/ProcessChainGraphBuilder.java` |
| `ProcessChainGraph` | 图数据结构和子图提取 | `service/ProcessChainGraph.java` |
| `ForcePruner` | 强制裁剪（兜底机制） | `util/ForcePruner.java` |
| `EntityExtractor` | 实体提取 | `util/EntityExtractor.java` |
| `EntityFilterUtil` | 实体过滤 | `util/EntityFilterUtil.java` |
| `ProcessChainExtensionUtil` | 扩展溯源 | `util/ProcessChainExtensionUtil.java` |
| `NetworkNodeRoleCorrector` | 网络节点角色修正 | `util/NetworkNodeRoleCorrector.java` |
| `ProcessChainValidator` | 合法性检查 | `util/ProcessChainValidator.java` |
| `IncidentConverters` | 最终输出转换 | `service/IncidentConverters.java` |

---

## 5. 技术栈

### 5.1 后端技术

| 技术 | 版本 | 用途 |
|------|------|------|
| **Java** | 8+ | 核心开发语言 |
| **Spring Boot** | 2.7.18 | 应用框架 |
| **Elasticsearch** | 7.17.15 | 数据存储和查询 |
| **Lombok** | 1.18.30 | 代码简化 |
| **SLF4J + Logback** | 1.7.36 | 日志框架 |
| **JUnit** | 4.13.2 | 单元测试 |
| **Maven** | 3.6+ | 项目构建 |

### 5.2 数据格式

- **输入**: JSON (RawAlarm, RawLog)
- **输出**: JSON (IncidentProcessChain)
- **API**: RESTful

### 5.3 性能指标

| 场景 | 节点数 | 处理时间 | 内存占用 |
|------|-------|---------|---------|
| 小规模 | <50 | <500ms | <100MB |
| 中规模 | 50-200 | <2s | <300MB |
| 大规模 | 200-400 | <5s | <500MB |
| 超大规模（强制裁剪） | >400 → 30 | <8s | <200MB |

---

## 6. 项目结构

```
demo/
├── pom.xml                          # Maven配置文件
├── build.bat                        # Windows构建脚本
├── README.md                        # 项目说明
│
├── src/main/
│   ├── java/com/security/processchain/
│   │   ├── ProcessChainApplication.java    # 启动类
│   │   │
│   │   ├── config/                         # 配置类
│   │   │   ├── ElasticsearchConfig.java    # ES连接配置
│   │   │   └── ProcessChainConfig.java     # 业务配置
│   │   │
│   │   ├── constants/                      # 常量定义
│   │   │   └── ProcessChainConstants.java  # 系统常量
│   │   │
│   │   ├── controller/                     # REST API层
│   │   │   └── ProcessChainController.java # 主控制器
│   │   │
│   │   ├── model/                          # 数据模型
│   │   │   ├── RawAlarm.java              # 原始告警
│   │   │   ├── RawLog.java                # 原始日志
│   │   │   ├── ProcessNode.java           # 进程节点
│   │   │   ├── ProcessEdge.java           # 边
│   │   │   └── IpMappingRelation.java     # IP映射关系
│   │   │
│   │   ├── service/                        # 服务层
│   │   │   ├── impl/
│   │   │   │   └── ProcessChainServiceImpl.java  # 核心服务实现 ⭐
│   │   │   ├── ProcessChainGraphBuilder.java     # 建图器 ⭐
│   │   │   ├── ProcessChainGraph.java            # 图数据结构 ⭐
│   │   │   ├── OptimizedESQueryService.java      # ES查询优化 ⭐
│   │   │   ├── IncidentConverters.java           # 输出转换器 ⭐
│   │   │   ├── GraphNode.java                    # 图节点
│   │   │   ├── ChainNode.java                    # 链节点
│   │   │   ├── ProcessEntity.java                # 进程实体
│   │   │   ├── FileEntity.java                   # 文件实体
│   │   │   ├── NetworkEntity.java                # 网络实体
│   │   │   ├── DomainEntity.java                 # 域名实体
│   │   │   └── RegistryEntity.java               # 注册表实体
│   │   │
│   │   └── util/                           # 工具类
│   │       ├── AlarmElectionUtil.java      # 告警选举 ⭐
│   │       ├── ForcePruner.java            # 强制裁剪 ⭐
│   │       ├── EntityExtractor.java        # 实体提取 ⭐
│   │       ├── EntityFilterUtil.java       # 实体过滤 ⭐
│   │       ├── ProcessChainExtensionUtil.java  # 扩展溯源 ⭐
│   │       ├── NetworkNodeRoleCorrector.java   # 角色修正 ⭐
│   │       ├── ProcessChainValidator.java      # 合法性检查 ⭐
│   │       ├── DataConverter.java          # 数据转换
│   │       ├── TimeUtil.java               # 时间工具
│   │       └── Pair.java                   # 键值对工具
│   │
│   └── resources/
│       └── application.yml                 # 应用配置文件
│
├── src/test/
│   └── java/.../                           # 测试代码
│       ├── ProcessChainBuilderTest.java
│       ├── AlarmElectionTest.java
│       └── ...
│
└── docs/                                   # 文档目录 📚
    ├── 00-文档索引.md                      # 文档总索引 ⭐
    ├── 00-项目总览与快速上手.md             # 本文档 ⭐
    ├── 01-核心架构与数据流程.md             # 架构详解 ⭐
    ├── 02-核心算法实现详解.md               # 算法详解 ⭐
    ├── 03-API接口文档.md                   # API文档 ⭐
    └── 04-开发与调试指南.md                 # 开发指南 ⭐
```

**重点文件说明**:
- ⭐ 标记的文件是系统核心，建议优先阅读
- `ProcessChainServiceImpl.java`: 业务逻辑编排的核心类
- `ProcessChainGraphBuilder.java`: 建图的核心实现
- `ForcePruner.java`: 裁剪算法的实现

---

## 7. 常见问题

### 7.1 启动相关

#### Q1: 启动时提示 "Cannot connect to Elasticsearch"

**A**: 
1. 检查 `application.yml` 中的ES地址是否正确
2. 确认ES服务是否正常运行: `curl http://localhost:9200`
3. 检查网络连接和防火墙设置
4. 如果没有ES环境，可以注释掉ES相关的Bean配置

#### Q2: 端口冲突 "Port 8080 is already in use"

**A**: 
- 修改 `application.yml` 中的 `server.port` 配置
- 或者关闭占用8080端口的其他应用

### 7.2 API调用相关

#### Q3: 调用API返回空进程链

**A**: 排查步骤：
1. 检查ES中是否有对应IP的告警数据
2. 检查告警的 `traceId` 是否正确
3. 检查日志数据是否匹配告警
4. 查看控制台日志，搜索 "【进程链生成】" 关键字

#### Q4: 进程链节点很少，缺失很多进程

**A**: 可能原因：
1. 日志数据不完整（缺失父进程日志）
2. 触发了裁剪机制（节点数>100）
3. 实体过滤过于激进
4. 检查日志输出，确认是否有 "【裁剪】" 或 "【实体过滤】" 相关日志

### 7.3 开发相关

#### Q5: 如何调试进程链构建过程？

**A**: 
1. 在 `ProcessChainServiceImpl.generateProcessChains()` 方法打断点
2. 逐步跟踪每个阶段的执行
3. 查看每个阶段的日志输出（使用 "【阶段名】" 关键字过滤）
4. 使用IDEA的 "Evaluate Expression" 查看中间变量

#### Q6: 如何增加新的实体类型？

**A**: 
1. 在 `service/` 目录下创建新的实体类（如 `XxxEntity.java`）
2. 在 `EntityExtractor.java` 中添加提取逻辑
3. 在 `IncidentConverters.java` 中添加转换逻辑
4. 在 `ProcessChainConstants.LogType` 中添加常量

#### Q7: 如何修改裁剪阈值？

**A**: 
修改 `ForcePruner.java` 中的常量：
```java
private static final int FORCE_PRUNE_THRESHOLD = 100;  // 触发阈值
private static final int FORCE_PRUNE_TARGET = 30;      // 目标节点数
```

### 7.4 性能相关

#### Q8: 处理大量IP时性能很慢

**A**: 
1. 检查ES查询性能，确保索引已优化
2. 增加ES查询的 `batch size`
3. 考虑使用异步处理
4. 检查是否触发了频繁的裁剪操作

#### Q9: 内存占用过高

**A**: 
1. 减小 `MAX_LOGS_PER_NODE` 参数（在 `ProcessChainGraphBuilder.java`）
2. 启用更激进的裁剪策略
3. 增加JVM堆内存: `java -Xmx2g -jar ...`

---

## 📚 下一步阅读

恭喜！你已经完成了项目的快速入门。接下来推荐按以下顺序深入学习：

1. **[01-核心架构与数据流程](./01-核心架构与数据流程.md)** - 深入理解系统架构和数据流转
2. **[02-核心算法实现详解](./02-核心算法实现详解.md)** - 学习核心算法的实现原理
3. **[03-API接口文档](./03-API接口文档.md)** - 了解所有API接口的详细说明
4. **[04-开发与调试指南](./04-开发与调试指南.md)** - 掌握开发和调试技巧

---

**最后更新**: 2025-12-08  
**文档维护者**: 开发团队  
**反馈**: 如有问题请联系项目负责人

