# 进程链裁剪机制说明与强制裁剪修复

## 一、裁剪机制概述

进程链生成系统有两层裁剪机制：

### 1. 智能裁剪（图裁剪）- 第一层
**触发时机**：实体提取之前  
**目标**：将进程节点数量控制在合理范围内  
**阈值**：`MAX_NODE_COUNT = 400`（可配置）  
**策略**：基于重要性评分的智能裁剪

### 2. 强制裁剪（兜底机制）- 第二层
**触发时机**：实体过滤之后，如果节点数仍然 > 100  
**目标**：强制裁剪到 `MAX_NODE_COUNT`（默认20）  
**策略**：确定性算法，保留网端关联链和单链

---

## 二、智能裁剪（图裁剪）详解

### 2.1 触发条件
```java
// 阶段6：智能裁剪（在实体提取之前）
if (subgraph.getNodeCount() > MAX_NODE_COUNT) {
    log.warn("【智能裁剪】节点数={} 超过阈值={}，开始裁剪", 
            subgraph.getNodeCount(), MAX_NODE_COUNT);
    
    GraphPruner.pruneGraph(subgraph, MAX_NODE_COUNT, networkAssociatedEventIds);
}
```

### 2.2 裁剪策略
智能裁剪基于**重要性评分**，评分规则：

#### 基础分（100分）
所有节点的起始分数

#### 加分项
1. **告警节点**：+50分
2. **网端关联节点**：+100分
3. **断链节点**：+30分
4. **根节点**：+20分
5. **子节点数量**：每个子节点 +5分（最多+50分）

#### 减分项
1. **深度惩罚**：深度每增加1，-10分
2. **叶子节点**：-20分

### 2.3 裁剪算法
```java
1. 计算所有节点的重要性评分
2. 按评分降序排序
3. 保留前 MAX_NODE_COUNT 个节点
4. 移除低分节点
5. 清理孤立节点和无效边
```

### 2.4 保护机制
- **告警节点**：永远保留
- **网端关联节点**：永远保留
- **根节点**：优先保留
- **断链节点**：优先保留

---

## 三、强制裁剪（兜底机制）详解

### 3.1 触发条件
```java
// 阶段7.5：强制裁剪（在实体过滤之后）
final int FORCE_PRUNE_THRESHOLD = 100;
if (subgraph.getNodeCount() > FORCE_PRUNE_THRESHOLD) {
    log.warn("【强制裁剪】节点数={} 超过阈值={}，触发强制裁剪到 MAX_NODE_COUNT={}",
            subgraph.getNodeCount(), FORCE_PRUNE_THRESHOLD, MAX_NODE_COUNT);
    
    ForcePruner.forcePrune(subgraph, networkAssociatedEventIds, traceIds);
}
```

### 3.2 裁剪策略
强制裁剪采用**确定性算法**，确保结果可复现：

#### 优先级顺序
1. **网端关联的进程节点及其向上单链**（最高优先级）
2. **网端关联的实体节点**
3. **其他节点（按DFS + GUID字典序）**

#### 配额分配
- 如果有多个 traceId，平均分配配额
- 最多支持3个 traceId
- 每个 traceId 独立裁剪

### 3.3 单链模式
强制裁剪采用**单链模式**，避免树杈：
- 只保留一条从根节点到叶子节点的链
- 不保留分支节点
- 确保图的简洁性

---

## 四、强制裁剪的问题与修复

### 4.1 问题描述

在强制裁剪场景下（节点数超过阈值20），当没有根节点时，`selectByGuidOrder` 方法存在以下问题：

### 问题1：只向下DFS，丢失断链节点
- **现象**：只选择了 AAA10001 节点，丢失了其父节点 PPP10001（断链节点）
- **影响**：无法创建虚拟根节点，导致网端无法桥接
- **原因**：只从 AAA10001 向下 DFS，没有向上追溯到 PPP10001

### 问题2：添加了所有实体节点，破坏单链
- **现象**：保留了 AAA10002、AAA10003 的实体节点
- **影响**：形成了多条链（树杈），不是单链
- **原因**：遍历了所有 traceId 下的实体节点，没有限制只添加单链上的实体

## 修复方案

### 修复前的逻辑
```java
1. 选择第一个进程节点（AAA10001）
2. 向下DFS选择子进程节点（没有子进程，只有1个节点）
3. 添加所有实体节点（包括AAA10002、AAA10003的实体）
```

### 修复后的逻辑
```java
1. 选择第一个进程节点（AAA10001）
2. ✅ 向上追溯到断链节点/根节点（找到PPP10001）
3. 反转链条，让根节点在前（[PPP10001, AAA10001]）
4. 向下DFS选择子进程节点（单链）
5. ✅ 只添加单链上进程节点的直接子实体
```

## 核心改动

### 改动1：向上追溯
```java
// ✅ 向上追溯到断链节点/根节点（形成向上的单链）
List<String> upwardChain = traceToRootProcessOnly(firstProcessNode, graph);

// 反转，让根节点在前
Collections.reverse(upwardChain);

// 添加向上的单链
for (String nodeId : upwardChain) {
    if (result.size() >= quota) {
        break;
    }
    result.add(nodeId);
}
```

### 改动2：只添加单链上的直接子实体
```java
// ✅ 只遍历已选中的进程节点
for (String processNodeId : result) {
    GraphNode processNode = graph.getNode(processNodeId);
    if (processNode != null && processNode.getNodeType() == NodeType.PROCESS) {
        List<String> children = graph.getChildren(processNodeId);
        
        for (String childId : children) {
            GraphNode childNode = graph.getNode(childId);
            if (childNode != null && 
                childNode.getNodeType() != NodeType.PROCESS &&  // 只要实体节点
                !excludeNodes.contains(childId) &&
                !result.contains(childId)) {
                directChildEntities.add(childId);
            }
        }
    }
}
```

## 预期效果

### 修复前
```
选中节点：
- AAA10001（1个进程节点）
- AAA10001的4个实体
- AAA10002的11个实体（错误！）
- 其他实体
总计：17个节点

问题：
❌ 丢失了断链节点PPP10001
❌ 包含了其他链的实体
❌ 无法桥接网端
```

### 修复后
```
选中节点：
- PPP10001（断链节点）✅
- AAA10001（告警节点）✅
- AAA10001的4个实体（registry×3 + network×1）✅
总计：6个节点

效果：
✅ 保留了断链节点，可以创建虚拟根节点
✅ 形成完整单链，没有分叉
✅ 可以正确桥接网端和端侧
```

## 测试场景

### 场景：3个告警节点，阈值20
```
原始数据：
- PPP10001 -> AAA10001（4个实体）
- PPP10002 -> AAA10002（11个实体）
- PPP10003 -> AAA10003（0个实体）
- EXPLORE_ROOT -> PPP10001/PPP10002/PPP10003
总计：25个节点

强制裁剪后（配额20）：
- PPP10001 -> AAA10001（4个实体）
总计：6个节点

桥接：
- 网侧：150.12.11.2 -> 60.60.1.1
- 端侧：EXPLORE_ROOT -> PPP10001 -> AAA10001 -> 实体
- 桥接边：60.60.1.1 -> EXPLORE_ROOT
```

## 关键点

1. **单链定义**：从一个起点开始，向上追溯到根节点（或断链节点），向下选择子节点，全程不分叉
2. **断链节点重要性**：断链节点是桥接的关键，必须保留
3. **确定性**：所有操作按GUID排序，确保结果可复现
4. **配额控制**：优先保留进程节点，然后才是实体节点

## 修复文件

- `demo/src/main/java/com/security/processchain/util/ForcePruner.java`
  - 方法：`selectByGuidOrder`（591-659行）

## 修复时间

2025-12-10

## 修复人员

AI Assistant (Claude Sonnet 4.5)

