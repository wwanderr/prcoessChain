# 测试指南

本文档介绍如何运行测试、编写测试以及测试覆盖情况。

---

## 📋 目录

1. [测试文件概览](#1-测试文件概览)
2. [运行测试](#2-运行测试)
3. [测试覆盖范围](#3-测试覆盖范围)
4. [如何编写测试](#4-如何编写测试)
5. [测试最佳实践](#5-测试最佳实践)

---

## 1. 测试文件概览

### 1.1 测试文件列表

项目包含 **5个测试文件**，共 **40个测试方法**：

| 文件名 | 测试数量 | 说明 | 测试类型 |
|--------|---------|------|---------|
| `CoreLogicTest.java` | 8 | 核心逻辑测试 | 单元测试 |
| `ProcessChainIntegrationTest.java` | 6 | 端到端集成测试 | 集成测试 |
| `ProcessChainMergeTest.java` | 6 | 合并逻辑测试 | 单元测试 |
| `ProcessChainPrunerTest.java` | 5 | 裁剪逻辑测试 | 单元测试 |
| `SpringBootProcessChainTest.java` | 15 | 功能测试 | 功能测试 |

**总计**: 40个测试用例

### 1.2 测试覆盖率

- **预估覆盖率**: ~85%
- **核心逻辑覆盖**: ~95%
- **边界情况覆盖**: ~80%

---

## 2. 运行测试

### 2.1 运行所有测试

```bash
mvn test
```

**预期输出**:
```
Tests run: 40, Failures: 0, Errors: 0, Skipped: 0
```

### 2.2 运行特定测试文件

```bash
# 核心逻辑测试
mvn test -Dtest=CoreLogicTest

# 集成测试
mvn test -Dtest=ProcessChainIntegrationTest

# 裁剪测试
mvn test -Dtest=ProcessChainPrunerTest

# 合并测试
mvn test -Dtest=ProcessChainMergeTest

# 功能测试
mvn test -Dtest=SpringBootProcessChainTest
```

### 2.3 运行单个测试方法

```bash
# 运行 CoreLogicTest 的 test01 方法
mvn test -Dtest=CoreLogicTest#test01_SingleTraceId_WithRootNode
```

### 2.4 查看测试报告

测试报告位于：
```
target/surefire-reports/
  ├── TEST-CoreLogicTest.xml
  ├── TEST-ProcessChainIntegrationTest.xml
  └── ...
```

查看HTML报告（需要配置）:
```bash
mvn surefire-report:report
# 报告位于：target/site/surefire-report.html
```

---

## 3. 测试覆盖范围

### 3.1 CoreLogicTest（核心逻辑测试）

**测试范围**: 从获取 `RawAlarm` 和 `RawLog` 数据后的所有逻辑

| 测试方法 | 测试场景 | 验证要点 |
|---------|---------|---------|
| test01 | 单个traceId，有真实根节点 | 根节点识别、节点数量 |
| test02 | 单个traceId，无根节点 | Explore创建、断链标记 |
| test03 | 多个traceId，都有根节点 | 多根节点、节点数量 |
| test04 | 多个断链，统一Explore | 单一Explore、连接数量 |
| test05 | 网端关联节点标记 | 关联节点标记正确 |
| test06 | 节点裁剪，根节点保护 | 根节点保留、裁剪有效 |
| test07 | 同traceId多个告警 | 告警节点数量 |
| test08 | 边界情况：空数据 | 空数据处理正常 |

**示例测试**:
```java
@Test
public void test01_SingleTraceId_WithRootNode() {
    // 准备数据
    String traceId = "TRACE_001";
    List<RawAlarm> alarms = Collections.singletonList(
        createAlarm("EVENT_001", traceId, traceId, null, "恶意进程", "高")
    );
    List<RawLog> logs = Arrays.asList(
        createProcessLog(traceId, null, traceId, "malware.exe", "processCreate"),
        createProcessLog("CHILD_001", traceId, traceId, "cmd.exe", "processCreate")
    );
    
    // 执行
    ProcessChainBuilder builder = new ProcessChainBuilder();
    IncidentProcessChain result = builder.buildIncidentChain(
        alarms, logs, Collections.singleton(traceId), new HashSet<>(),
        IncidentConverters.NODE_MAPPER, IncidentConverters.EDGE_MAPPER
    );
    
    // 验证
    assertNotNull(result);
    assertEquals(2, result.getNodes().size());
    assertEquals(1, countRootNodes(result));
}
```

### 3.2 ProcessChainIntegrationTest（集成测试）

**测试范围**: 端到端的进程链构建流程

| 测试方法 | 测试场景 |
|---------|---------|
| testSingleTraceId_WithRootNode | 单traceId有根节点 |
| testSingleTraceId_NoBrokenChain | 单traceId无断链 |
| testMultipleTraceIds_AllWithRootNodes | 多traceId都有根 |
| testMultipleBrokenChains_NoRootNode | 多断链无根 |
| testPruning_RootNodePreserved | 裁剪保留根节点 |
| testPruning_AssociatedNodePreserved | 裁剪保留关联节点 |

### 3.3 ProcessChainPrunerTest（裁剪测试）

**测试范围**: 智能裁剪逻辑

| 测试方法 | 测试场景 |
|---------|---------|
| testPruning_BelowThreshold | 节点数<阈值，不裁剪 |
| testPruning_RootNodePreserved | 裁剪保留根节点 |
| testPruning_AlarmNodesPreserved | 裁剪保留告警节点 |
| testPruning_RollbackOnError | 异常时回滚 |
| testPruning_CompletePath | 保留完整路径 |

### 3.4 ProcessChainMergeTest（合并测试）

**测试范围**: 网端端侧合并逻辑

| 测试方法 | 测试场景 |
|---------|---------|
| testBuildChain_SingleIp | 单IP进程链 |
| testBuildChain_MultipleIps | 多IP合并 |
| testBuildChain_WithNetworkAssociation | 网端关联 |
| testBuildChain_DifferentTraceIds | 不同traceId |
| testBuildChain_MixedSeverity | 混合告警等级 |
| testBuildChain_NonProcessNodes | 非进程节点 |

### 3.5 SpringBootProcessChainTest（功能测试）

**测试范围**: 各种功能场景

包含15个测试，覆盖：
- 告警等级影响（高危/中危/低危）
- 非进程节点处理
- 树状结构
- 长链条
- 网端关联
- 空数据边界
- 节点裁剪
- 多告警同节点

---

## 4. 如何编写测试

### 4.1 测试数据准备

**使用辅助方法创建测试数据**:

```java
// 创建告警
private RawAlarm createAlarm(String eventId, String traceId, 
                              String processGuid, String parentProcessGuid,
                              String alarmName, String severity) {
    RawAlarm alarm = new RawAlarm();
    alarm.setEventId(eventId);
    alarm.setTraceId(traceId);
    alarm.setProcessGuid(processGuid);
    alarm.setParentProcessGuid(parentProcessGuid);
    alarm.setAlarmName(alarmName);
    alarm.setThreatSeverity(severity);
    alarm.setHostAddress("192.168.1.100");
    alarm.setStartTime("2024-01-15 10:00:00");
    return alarm;
}

// 创建进程日志
private RawLog createProcessLog(String processGuid, String parentProcessGuid,
                                 String traceId, String processName, 
                                 String eventType) {
    RawLog log = new RawLog();
    log.setProcessGuid(processGuid);
    log.setParentProcessGuid(parentProcessGuid);
    log.setTraceId(traceId);
    log.setLogType("process");
    log.setEventType(eventType);
    log.setProcessName(processName);
    log.setCommandLine(processName + " --args");
    log.setHostAddress("192.168.1.100");
    log.setStartTime("2024-01-15 10:00:00");
    return log;
}
```

### 4.2 测试模板

```java
@Test
public void test_YourTestName() {
    // ===== 1. 准备测试数据 =====
    String traceId = "TRACE_001";
    List<RawAlarm> alarms = ...;
    List<RawLog> logs = ...;
    Set<String> traceIds = Collections.singleton(traceId);
    Set<String> associatedEventIds = new HashSet<>();
    
    // ===== 2. 执行测试 =====
    ProcessChainBuilder builder = new ProcessChainBuilder();
    IncidentProcessChain result = builder.buildIncidentChain(
        alarms, logs, traceIds, associatedEventIds,
        IncidentConverters.NODE_MAPPER, IncidentConverters.EDGE_MAPPER
    );
    
    // ===== 3. 验证结果 =====
    assertNotNull("进程链不应为空", result);
    assertEquals("节点数应该为3", 3, result.getNodes().size());
    assertTrue("应该有根节点", hasRootNode(result));
    
    // 输出日志（可选）
    System.out.println("✅ 测试通过：节点数=" + result.getNodes().size());
}
```

### 4.3 常用验证方法

```java
// 统计根节点数量
private long countRootNodes(IncidentProcessChain chain) {
    return chain.getNodes().stream()
        .filter(node -> node.getIsChainNode() &&
                       node.getChainNode() != null &&
                       Boolean.TRUE.equals(node.getChainNode().getIsRoot()))
        .count();
}

// 获取根节点
private ProcessNode getRootNode(IncidentProcessChain chain) {
    return chain.getNodes().stream()
        .filter(node -> node.getIsChainNode() &&
                       node.getChainNode() != null &&
                       Boolean.TRUE.equals(node.getChainNode().getIsRoot()))
        .findFirst()
        .orElse(null);
}

// 统计告警节点数量
private long countAlarmNodes(IncidentProcessChain chain) {
    return chain.getNodes().stream()
        .filter(node -> node.getIsChainNode() &&
                       node.getChainNode() != null &&
                       Boolean.TRUE.equals(node.getChainNode().getIsAlarm()))
        .count();
}
```

---

## 5. 测试最佳实践

### 5.1 测试命名规范

**推荐格式**: `test_场景描述_预期结果`

```java
// ✅ 好的命名
test_SingleTraceId_WithRootNode_ShouldCreateCorrectChain()
test_MultipleTraceIds_NoBrokenChains_ShouldCreateMultipleRoots()
test_Pruning_ExceedsThreshold_ShouldPreserveRootNode()

// ❌ 不好的命名
test1()
testA()
testChain()
```

### 5.2 测试数据设计原则

**DO ✅**:
- 根节点的 `processGuid` 必须等于 `traceId`
- 需要验证子节点时，使用"高危"告警
- 多个traceId时，每个都应有独立的根节点ID
- 使用清晰的节点ID（如 `"ROOT"`, `"CHILD_001"`）

**DON'T ❌**:
- 不要使用 `"ROOT_T001"` 作为processGuid（应该用 `"T001"`）
- 不要用中危告警测试子节点添加（遍历策略不同）
- 不要假设长链能触发裁剪（受深度限制50）

### 5.3 测试独立性

每个测试应该：
- ✅ 独立运行（不依赖其他测试）
- ✅ 可重复执行（结果一致）
- ✅ 清理资源（如果创建了临时文件）

### 5.4 测试覆盖重点

**必须覆盖**:
- ✅ 正常路径（Happy Path）
- ✅ 边界情况（空数据、null）
- ✅ 异常情况（异常回滚）
- ✅ 不同告警等级
- ✅ 单/多 traceId
- ✅ 有/无根节点

**可选覆盖**:
- ⭕ 性能测试（大数据量）
- ⭕ 并发测试（多线程）
- ⭕ 集成测试（连接真实ES）

### 5.5 断言最佳实践

```java
// ✅ 好的断言（有明确的错误信息）
assertEquals("节点数应该为3", 3, result.getNodes().size());
assertTrue("应该有根节点", hasRootNode(result));
assertNotNull("根节点不应为null", rootNode);

// ❌ 不好的断言（没有错误信息）
assertEquals(3, result.getNodes().size());
assertTrue(hasRootNode(result));
assertNotNull(rootNode);
```

---

## 6. 测试场景示例

### 6.1 测试根节点识别

```java
@Test
public void test_RootNodeIdentification() {
    String traceId = "T001";
    
    // 准备数据：processGuid == traceId 才是根节点
    RawAlarm alarm = createAlarm("E001", traceId, traceId, null, "告警", "高");
    List<RawLog> logs = Arrays.asList(
        createProcessLog(traceId, null, traceId, "root.exe", "processCreate")
    );
    
    // 执行
    IncidentProcessChain result = buildChain(alarm, logs, traceId);
    
    // 验证
    ProcessNode rootNode = getRootNode(result);
    assertNotNull("应该找到根节点", rootNode);
    assertEquals("根节点ID应该是traceId", traceId, rootNode.getNodeId());
    assertTrue("根节点isRoot应为true", rootNode.getChainNode().getIsRoot());
}
```

### 6.2 测试Explore节点创建

```java
@Test
public void test_ExploreNodeCreation() {
    String traceId = "T001";
    
    // 准备数据：无根节点（断链）
    RawAlarm alarm = createAlarm("E001", traceId, "NODE_MIDDLE", 
                                 "MISSING_PARENT", "告警", "高");
    List<RawLog> logs = Arrays.asList(
        createProcessLog("NODE_MIDDLE", "MISSING_PARENT", traceId, 
                        "cmd.exe", "processCreate")
    );
    
    // 执行
    IncidentProcessChain result = buildChain(alarm, logs, traceId);
    
    // 验证
    ProcessNode rootNode = getRootNode(result);
    assertEquals("应该创建Explore", "EXPLORE_ROOT", rootNode.getNodeId());
    assertTrue("Explore应该标记为root", rootNode.getChainNode().getIsRoot());
}
```

### 6.3 测试裁剪保护

```java
@Test
public void test_PruningPreservesRootNode() {
    String traceId = "T001";
    
    // 准备大量数据（触发裁剪）
    List<RawLog> logs = createLongChain(traceId, 100);  // 100个节点
    
    // 执行
    IncidentProcessChain result = buildChain(alarm, logs, traceId);
    
    // 验证
    ProcessNode rootNode = findNodeById(result, traceId);
    assertNotNull("裁剪后根节点必须保留", rootNode);
}
```

---

## 📊 测试统计

### 当前测试统计

| 指标 | 数值 |
|------|------|
| 测试文件数 | 5 |
| 测试方法数 | 40 |
| 代码覆盖率 | ~85% |
| 测试通过率 | 100% |

### 测试执行时间

| 测试文件 | 平均执行时间 |
|---------|------------|
| CoreLogicTest | ~200ms |
| ProcessChainIntegrationTest | ~300ms |
| ProcessChainPrunerTest | ~150ms |
| ProcessChainMergeTest | ~250ms |
| SpringBootProcessChainTest | ~500ms |
| **总计** | **~1.4s** |

---

## 🔗 相关文档

- [快速开始](../01-快速开始.md) - 5分钟上手
- [核心功能说明](../02-核心功能说明.md) - 功能介绍
- [项目详细说明](../../项目详细说明文档.md) - 完整文档

---

**最后更新**: 2025-10-22


