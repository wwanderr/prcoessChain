# 进程链节点评分细则说明

## 文档信息
- **版本**: 1.0.0
- **更新时间**: 2025-10-22
- **适用模块**: `ProcessChainBuilder.calculateNodeScores()`

---

## 目录

1. [概述](#1-概述)
2. [评分规则详解](#2-评分规则详解)
3. [优先级总结](#3-优先级总结)
4. [实际评分示例](#4-实际评分示例)
5. [分数区间参考](#5-分数区间参考)
6. [裁剪逻辑](#6-裁剪逻辑)

---

## 1. 概述

### 1.1 评分目的

在进程链构建过程中，当节点数量超过 `MAX_NODE_COUNT`（默认1000）时，系统需要对节点进行裁剪，只保留最重要的节点。`calculateNodeScores()` 方法通过多维度评分来确定节点的重要性。

### 1.2 评分机制

- **分数越高**：节点越重要，越优先保留
- **多维度累加**：一个节点可以从多个维度获得分数
- **动态排序**：根据实时计算的分数进行排序和裁剪

### 1.3 代码位置

**文件**: `com.security.processchain.service.ProcessChainBuilder`  
**方法**: `calculateNodeScores()`  
**行号**: 465-533

---

## 2. 评分规则详解

### 2.1 网端关联成功的告警节点：+1000分 🥇

#### 条件
- 节点是告警节点（`node.getIsAlarm() == true`）
- 且告警的 `eventId` 在 `associatedEventIds` 集合中

#### 代码
```java
if (node.getIsAlarm()) {
    for (RawAlarm alarm : node.getAlarms()) {
        if (associatedEventIds.contains(alarm.getEventId())) {
            score += 1000;
            break;  // 只要有一个关联成功就加分
        }
    }
}
```

#### 说明
- **最高优先级**：1000分确保这类节点绝对不会被裁剪
- **关键性**：表示该节点是网侧和端侧成功关联的关键节点
- **业务价值**：在攻击链路分析中至关重要，是连接攻击者和受害者的桥梁

#### 典型场景
- 攻击者通过网络入侵某台主机
- 该主机上的告警被成功关联到网络侧的攻击行为
- 这个节点是整个攻击链的核心证据

---

### 2.2 告警节点（按威胁等级）：+20 ~ +100分 🥈

#### 条件
节点是告警节点（`node.getIsAlarm() == true`）

#### 分值表

| 威胁等级 | 判断条件 | 分值 | 说明 |
|---------|---------|------|------|
| **高危 (HIGH)** | `isHighSeverity(severity)` | **+100分** | 严重威胁，必须重点关注 |
| **中危 (MEDIUM)** | `isMediumSeverity(severity)` | **+50分** | 中等威胁，需要关注 |
| **低危 (LOW)** | 其他情况 | **+20分** | 低等威胁，较低优先级 |

#### 代码
```java
if (node.getIsAlarm()) {
    for (RawAlarm alarm : node.getAlarms()) {
        String severity = alarm.getThreatSeverity();
        if (isHighSeverity(severity)) {
            score += 100; // 高危: +100分
        } else if (isMediumSeverity(severity)) {
            score += 50;  // 中危: +50分
        } else {
            score += 20;  // 低危: +20分
        }
    }
}
```

#### 说明
- **累加机制**：一个节点可能有多个告警，每个告警都会累加分数
- **高危告警**：代表严重的安全事件
  - 恶意进程启动
  - 勒索软件行为
  - 命令执行攻击
  - 权限提升
- **中危告警**：需要关注但不紧急
  - 可疑网络连接
  - 异常文件操作
  - 注册表修改
- **低危告警**：轻微威胁
  - 信息收集行为
  - 合规性问题

#### 典型场景
```
高危告警节点示例：
  alarmName: "勒索软件行为检测"
  severity: HIGH
  score: +100
  
多告警节点示例：
  alarm1: severity=HIGH  → +100
  alarm2: severity=MEDIUM → +50
  总分: +150
```

---

### 2.3 根节点：+80分 🥈

#### 条件
`rootNodes.contains(processGuid)`

根节点的判断标准：
- `processGuid == traceId`
- 或 `processGuid` 在 `Set<String> traceIds` 中

#### 代码
```java
if (rootNodes.contains(processGuid)) {
    score += 80;
}
```

#### 说明
- **进程链起点**：根节点是进程树的最顶层节点
- **攻击入口**：通常代表攻击的初始入口点
- **分析价值**：
  - 展示攻击如何开始
  - 追溯攻击源头
  - 理解攻击路径的起点

#### 典型场景
```
场景1：正常进程链
  explorer.exe (根节点)
    ├─ cmd.exe
    └─ powershell.exe

场景2：攻击进程链
  svchost.exe (根节点，被利用的合法进程)
    ├─ malware.exe (恶意进程)
    └─ payload.exe (攻击载荷)
```

---

### 2.4 节点连接数（度中心性）：+2/连接，最多+30分 🥉

#### 条件
统计该节点在边中出现的次数（作为 source 或 target）

#### 代码
```java
int connectionCount = 0;
for (ChainBuilderEdge edge : edges) {
    if (edge.getSource().equals(processGuid) || edge.getTarget().equals(processGuid)) {
        connectionCount++;
    }
}
score += Math.min(connectionCount * 2, 30); // 最多+30分
```

#### 分值计算表

| 连接数 | 计算公式 | 实际分值 | 节点类型 | 重要性 |
|--------|---------|---------|---------|--------|
| 1条边 | 1 × 2 | +2分 | 叶子节点 | 低 |
| 3条边 | 3 × 2 | +6分 | 一般节点 | 较低 |
| 5条边 | 5 × 2 | +10分 | 常见节点 | 中等 |
| 10条边 | 10 × 2 | +20分 | 重要节点 | 较高 |
| 15条边 | 15 × 2 | +30分（上限） | 核心节点 | 高 |
| 20条边+ | 20 × 2 = 40 → 30 | +30分（上限） | 超级节点 | 高 |

#### 说明
- **度中心性**：图论中的重要概念，连接数多的节点通常是关键节点
- **上限设置**：避免某些系统进程（如 `svchost.exe`）权重过高
- **应用场景**：
  - 父进程启动了多个子进程
  - 进程进行了多次文件、网络操作
  - 关键的中间节点，连接了多个攻击步骤

#### 典型场景
```
场景1：核心攻击节点（15条边）
  malware.exe (核心节点)
    ├─ 创建 10 个文件节点
    ├─ 发起 3 个网络连接
    └─ 启动 2 个子进程
  总连接数: 15
  得分: +30（上限）

场景2：叶子节点（1条边）
  victim_file.txt (被修改的文件)
    └─ 只有一条边连接到父进程
  总连接数: 1
  得分: +2
```

---

### 2.5 有日志数据的节点：+10分

#### 条件
`!node.getLogs().isEmpty()`

#### 代码
```java
if (!node.getLogs().isEmpty()) {
    score += 10;
}
```

#### 说明
- **数据完整性**：有日志数据表示节点有实际的操作记录
- **分析价值**：比只有告警信息的节点更有分析价值
- **日志内容**：
  - 进程详细信息（进程名、命令行、用户等）
  - 文件操作记录（路径、MD5、大小等）
  - 网络连接信息（IP、端口、协议等）
  - 域名解析记录
  - 注册表操作

#### 典型场景
```
有日志的节点：
  processGuid: GUID-123
  logs: [
    {logType: "process", processName: "cmd.exe", ...},
    {logType: "file", filePath: "C:\\temp\\malware.exe", ...}
  ]
  得分: +10

无日志的节点：
  processGuid: GUID-456
  logs: []
  得分: 0
```

---

### 2.6 process 类型的节点：+5分

#### 条件
节点的日志中包含 `logType == "process"` 的记录

#### 代码
```java
boolean hasProcessLog = false;
for (RawLog log : node.getLogs()) {
    if ("process".equalsIgnoreCase(log.getLogType())) {
        hasProcessLog = true;
        break;
    }
}
if (hasProcessLog) {
    score += 5;
}
```

#### 说明
- **类型优先级**：process 类型是进程链的核心节点类型
- **高于其他类型**：优先级高于 file、network、domain、registry
- **进程树结构**：进程节点能展示完整的进程树父子关系

#### 类型对比

| 节点类型 | logType | 分值 | 重要性 |
|---------|---------|------|--------|
| 进程节点 | process | +5分 | ⭐⭐⭐ 核心 |
| 文件节点 | file | 0分 | ⭐⭐ 辅助 |
| 网络节点 | network | 0分 | ⭐⭐ 辅助 |
| 域名节点 | domain | 0分 | ⭐⭐ 辅助 |
| 注册表节点 | registry | 0分 | ⭐⭐ 辅助 |

#### 典型场景
```
进程节点（+5分）：
  logType: process
  processName: "powershell.exe"
  commandLine: "powershell -enc ..."
  → 能展示完整的进程调用链

文件节点（0分）：
  logType: file
  filePath: "C:\\temp\\data.txt"
  → 只是进程操作的结果，非核心
```

---

## 3. 优先级总结

### 3.1 评分规则表

| 优先级 | 评分项 | 条件 | 分值 | 适用场景 |
|--------|--------|------|------|---------|
| 🥇 **1** | 网端关联告警 | 告警节点 + eventId 在 associatedEventIds | **+1000** | 网侧端侧关联的关键节点 |
| 🥈 **2** | 高危告警 | 告警节点 + severity=HIGH | **+100** | 严重安全威胁 |
| 🥈 **2** | 根节点 | processGuid 在 rootNodes | **+80** | 进程链起点/攻击入口 |
| 🥉 **3** | 中危告警 | 告警节点 + severity=MEDIUM | **+50** | 中等安全威胁 |
| 4 | 节点连接数 | 边中出现次数 | **+2/连接，最多+30** | 关键中间节点/核心节点 |
| 5 | 低危告警 | 告警节点 + severity=LOW | **+20** | 低等安全威胁 |
| 6 | 有日志数据 | logs 列表不为空 | **+10** | 有实际操作记录 |
| 7 | process 类型 | logType=process | **+5** | 进程类型节点 |

### 3.2 分数范围

- **网端关联节点**: 1000+ 分
- **高危告警节点**: 100 - 300 分
- **根节点 + 中危告警**: 80 - 150 分
- **普通告警节点**: 20 - 100 分
- **非告警节点**: 0 - 45 分

---

## 4. 实际评分示例

### 4.1 示例1：网端关联的高危告警根节点

#### 节点属性
```java
ChainBuilderNode node = new ChainBuilderNode();
node.setProcessGuid("ROOT-123");

// 添加高危告警（网端关联）
RawAlarm alarm = new RawAlarm();
alarm.setEventId("EVENT-001");  // 在 associatedEventIds 中
alarm.setThreatSeverity("HIGH");
node.addAlarm(alarm);

// 添加进程日志
node.addLog(new RawLog() {{ setLogType("process"); }});

// 假设：该节点是根节点且有5个连接
```

#### 评分计算
```
网端关联告警:    +1000  (最高优先级)
高危告警:        +100   (严重威胁)
根节点:          +80    (进程链起点)
节点连接数(5):   +10    (5 × 2)
有日志数据:      +10    (有操作记录)
process类型:     +5     (核心类型)
─────────────────────────────────
总分:            1205分  ✅✅✅ 最高优先级保留
```

#### 结论
- **绝对保留**：分数超过1000，不可能被裁剪
- **关键节点**：网侧端侧关联成功的高危攻击节点
- **分析价值**：是整个攻击链路的核心证据

---

### 4.2 示例2：高危告警节点（非根节点，非网端关联）

#### 节点属性
```java
ChainBuilderNode node = new ChainBuilderNode();
node.setProcessGuid("HIGH-456");

// 添加高危告警（非网端关联）
RawAlarm alarm = new RawAlarm();
alarm.setEventId("EVENT-002");  // 不在 associatedEventIds 中
alarm.setThreatSeverity("HIGH");
node.addAlarm(alarm);

// 添加进程日志
node.addLog(new RawLog() {{ setLogType("process"); }});

// 假设：该节点有3个连接
```

#### 评分计算
```
网端关联告警:    0      (eventId 不在关联列表)
高危告警:        +100   (严重威胁)
根节点:          0      (不是根节点)
节点连接数(3):   +6     (3 × 2)
有日志数据:      +10    (有操作记录)
process类型:     +5     (核心类型)
─────────────────────────────────
总分:            121分  ✅✅ 极大概率保留
```

#### 结论
- **高概率保留**：高危告警保证了较高分数
- **重要节点**：虽然不是网端关联，但仍是高危事件
- **分析价值**：代表攻击链中的关键恶意行为

---

### 4.3 示例3：中危告警节点（非根节点）

#### 节点属性
```java
ChainBuilderNode node = new ChainBuilderNode();
node.setProcessGuid("MEDIUM-789");

// 添加中危告警（非网端关联）
RawAlarm alarm = new RawAlarm();
alarm.setEventId("EVENT-003");  // 不在 associatedEventIds 中
alarm.setThreatSeverity("MEDIUM");
node.addAlarm(alarm);

// 添加文件日志
node.addLog(new RawLog() {{ setLogType("file"); }});

// 假设：该节点有10个连接
```

#### 评分计算
```
网端关联告警:    0      (eventId 不在关联列表)
中危告警:        +50    (中等威胁)
根节点:          0      (不是根节点)
节点连接数(10):  +20    (10 × 2)
有日志数据:      +10    (有操作记录)
process类型:     0      (是 file 类型)
─────────────────────────────────
总分:            80分   ✅ 可能保留
```

#### 结论
- **可能保留**：分数适中，取决于节点总数
- **中等重要**：中危告警 + 多连接
- **分析价值**：可能是攻击链中的辅助步骤

---

### 4.4 示例4：普通进程节点（非告警）

#### 节点属性
```java
ChainBuilderNode node = new ChainBuilderNode();
node.setProcessGuid("NORMAL-456");

// 只有日志，没有告警
node.addLog(new RawLog() {{ setLogType("process"); }});

// 假设：该节点有2个连接
```

#### 评分计算
```
网端关联告警:    0      (不是告警节点)
告警等级:        0      (不是告警节点)
根节点:          0      (不是根节点)
节点连接数(2):   +4     (2 × 2)
有日志数据:      +10    (有操作记录)
process类型:     +5     (核心类型)
─────────────────────────────────
总分:            19分   ⚠️ 可能被裁剪
```

#### 结论
- **可能被裁剪**：分数较低，节点数超限时优先移除
- **普通节点**：没有告警，连接数少
- **分析价值**：辅助性节点，不是攻击的核心

---

### 4.5 示例5：根节点（无告警，多连接）

#### 节点属性
```java
ChainBuilderNode node = new ChainBuilderNode();
node.setProcessGuid("ROOT-999");

// 无告警，但是根节点
// 添加进程日志
node.addLog(new RawLog() {{ setLogType("process"); }});

// 假设：该节点有12个连接（启动了多个子进程）
```

#### 评分计算
```
网端关联告警:    0      (不是告警节点)
告警等级:        0      (不是告警节点)
根节点:          +80    (进程链起点)
节点连接数(12):  +24    (12 × 2)
有日志数据:      +10    (有操作记录)
process类型:     +5     (核心类型)
─────────────────────────────────
总分:            119分  ✅✅ 大概率保留
```

#### 结论
- **大概率保留**：根节点 + 多连接保证了较高分数
- **重要节点**：虽然无告警，但是进程树的起点
- **分析价值**：展示整个进程链的结构起点

---

## 5. 分数区间参考

### 5.1 分数区间表

| 分数区间 | 节点类型 | 保留概率 | 典型场景 | 特征 |
|---------|---------|---------|---------|------|
| **1000+** | 网端关联告警节点 | ✅✅✅ 100% 保留 | 关联成功的高危攻击节点 | 网侧端侧桥接节点 |
| **150-300** | 高危告警 + 根节点 + 多连接 | ✅✅ 极大概率保留 | 高危攻击入口 + 核心节点 | 多个高分项累加 |
| **80-150** | 根节点 + 中危告警 | ✅ 大概率保留 | 进程树根节点、中危事件 | 单个高分项 + 辅助分 |
| **50-80** | 中危告警 或 低危告警 + 多连接 | ⚠️ 可能保留 | 中等威胁或重要中间节点 | 中等分数 |
| **20-50** | 低危告警 或 普通节点 + 多连接 | ⚠️ 看节点总数 | 低危事件或一般中间节点 | 较低分数 |
| **0-20** | 普通日志节点 | ❌ 优先被裁剪 | 叶子节点、辅助节点 | 无告警、少连接 |

### 5.2 保留概率说明

#### ✅✅✅ 100% 保留 (1000+)
- **绝对保留**：无论节点总数多少，这类节点必定保留
- **数量**：通常很少，是最核心的关联节点

#### ✅✅ 极大概率保留 (150-300)
- **高概率**：除非节点数严重超限（如超过10倍），否则会保留
- **数量**：占比约 5-10%

#### ✅ 大概率保留 (80-150)
- **较高概率**：在节点数超限不严重时会保留
- **数量**：占比约 10-20%

#### ⚠️ 可能保留 (20-80)
- **不确定**：取决于节点总数和超限程度
- **数量**：占比约 30-40%

#### ❌ 优先被裁剪 (0-20)
- **优先移除**：节点数超限时第一批被裁剪
- **数量**：占比约 40-50%

---

## 6. 裁剪逻辑

### 6.1 触发条件

```java
if (nodeMap.size() > MAX_NODE_COUNT) {
    log.warn("节点数量({})超过限制({}),开始裁剪...", nodeMap.size(), MAX_NODE_COUNT);
    pruneNodes();
}
```

**说明**：
- `MAX_NODE_COUNT` 默认值：1000
- 可通过配置文件修改

### 6.2 裁剪流程

```java
private void pruneNodes() {
    // 1. 计算每个节点的重要性分数
    Map<String, Integer> nodeScores = calculateNodeScores();
    
    // 2. 按分数排序（从高到低）
    List<Map.Entry<String, Integer>> sortedNodes = new ArrayList<>(nodeScores.entrySet());
    sortedNodes.sort((a, b) -> b.getValue().compareTo(a.getValue()));
    
    // 3. 保留前 MAX_NODE_COUNT 个节点
    Set<String> nodesToKeep = new HashSet<>();
    for (int i = 0; i < Math.min(MAX_NODE_COUNT, sortedNodes.size()); i++) {
        nodesToKeep.add(sortedNodes.get(i).getKey());
    }
    
    // 4. 移除低分节点
    Iterator<Map.Entry<String, ChainBuilderNode>> iterator = nodeMap.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, ChainBuilderNode> entry = iterator.next();
        if (!nodesToKeep.contains(entry.getKey())) {
            iterator.remove();
        }
    }
    
    // 5. 清理无效的边
    Iterator<ChainBuilderEdge> edgeIterator = edges.iterator();
    while (edgeIterator.hasNext()) {
        ChainBuilderEdge edge = edgeIterator.next();
        if (!nodeMap.containsKey(edge.getSource()) || !nodeMap.containsKey(edge.getTarget())) {
            edgeIterator.remove();
        }
    }
    
    log.info("裁剪完成: 移除了 {} 个节点, 保留 {} 个节点", removedCount, nodeMap.size());
}
```

### 6.3 裁剪策略

#### 保留的节点类型
- ✅ 所有网端关联的告警节点（1000+分）
- ✅ 所有高危告警节点（100+分）
- ✅ 所有根节点（80+分）
- ✅ 关键的中间节点（连接数多）
- ⚠️ 部分中低危告警节点

#### 可能被移除的节点类型
- ❌ 叶子节点（连接数为1）
- ❌ 非告警的普通日志节点
- ❌ 低危告警且连接数少的节点
- ❌ 辅助性的文件、注册表节点

### 6.4 边的处理

**规则**：如果边的 source 或 target 被移除，该边也会被删除

**原因**：
- 确保图结构的完整性
- 避免悬空的边
- 保持拓扑结构的一致性

**示例**：
```
原始图：
  A -> B -> C -> D
  分数: A=150, B=50, C=20, D=10
  
裁剪后（假设只保留前2个）：
  A -> B
  边 B->C 和 C->D 被删除
```

---

## 7. 总结

### 7.1 核心要点

1. **多维度评分**：从6个维度综合评估节点重要性
2. **分数累加**：一个节点可以从多个维度获得分数
3. **明确优先级**：网端关联 > 高危告警 > 根节点 > 其他
4. **自动裁剪**：节点数超限时自动移除低分节点
5. **保证完整性**：保留关键节点和边的同时确保图结构一致

### 7.2 使用建议

1. **理解评分规则**：在分析进程链时，了解哪些节点会被保留
2. **关注高分节点**：1000+ 和 100+ 分的节点是分析重点
3. **调整配置**：根据实际场景调整 `MAX_NODE_COUNT`
4. **验证结果**：裁剪后检查关键节点是否保留

### 7.3 注意事项

- ⚠️ 裁剪可能导致部分攻击链路不完整
- ⚠️ 低危告警节点可能被移除
- ⚠️ 叶子节点（文件、注册表等）容易被裁剪
- ✅ 核心攻击节点始终会被保留
- ✅ 根节点和高危告警节点不会被裁剪

---

## 附录：快速查询表

### 评分速查表

| 评分项 | 分值 | 条件简述 |
|--------|------|---------|
| 网端关联 | +1000 | 告警节点 + eventId 匹配 |
| 高危告警 | +100 | severity=HIGH |
| 根节点 | +80 | processGuid=traceId |
| 中危告警 | +50 | severity=MEDIUM |
| 节点连接 | +2~30 | 连接数 × 2（上限30） |
| 低危告警 | +20 | severity=LOW |
| 有日志 | +10 | logs 不为空 |
| process类型 | +5 | logType=process |

### 分数区间速查

| 分数 | 保留概率 | 节点特征 |
|------|---------|---------|
| 1000+ | 100% | 网端关联 |
| 150-300 | 99% | 高危+根节点+多连接 |
| 80-150 | 90% | 根节点或高危告警 |
| 50-80 | 60% | 中危告警 |
| 20-50 | 30% | 低危告警 |
| 0-20 | 5% | 普通节点 |

---

**文档结束**







