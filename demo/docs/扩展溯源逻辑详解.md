# 扩展溯源逻辑详解

## 📌 核心功能

从已识别的根节点（`isRoot=true`）向上查询父节点，最多扩展2层，以获得更完整的攻击上下文。

---

## 🔄 完整流程

### 1. 入口：`performExtension()`

**输入：**
- `traceIdToRootMap`: traceId → 根节点ID 的映射
- `hostToTraceId`: host → traceId 的映射（用于反查 hostAddress）
- `allNodes`: 所有节点列表（会添加扩展节点）
- `allEdges`: 所有边列表（会添加扩展边）
- `esQueryService`: ES 查询服务
- `maxDepth`: 最大扩展深度（推荐值：2）

**处理逻辑：**

```
for (traceId, rootNodeId) in traceIdToRootMap:
    
    ┌─ 步骤1：检查是否跳过 ─────────────────────┐
    │                                           │
    │  shouldSkipExtension(rootNodeId):        │
    │    ├─ Explore 虚拟节点？ → 跳过          │
    │    ├─ 虚拟根父节点？ → 跳过               │
    │    └─ 断链节点？ → 跳过                   │
    │                                           │
    └───────────────────────────────────────────┘
              ↓ 不跳过
    ┌─ 步骤2：执行扩展 ─────────────────────────┐
    │                                           │
    │  newTopNodeId = extendFromNode(...)      │
    │                                           │
    └───────────────────────────────────────────┘
              ↓
    ┌─ 步骤3：处理结果 ─────────────────────────┐
    │                                           │
    │  if (newTopNodeId != originalRootId):    │
    │    ✅ 扩展成功                            │
    │    - 更新映射：traceId → newTopNodeId    │
    │    - 调整 isRoot 标记                     │
    │  else:                                   │
    │    ❌ 扩展失败                            │
    │    - 保持映射：traceId → originalRootId  │
    │                                           │
    └───────────────────────────────────────────┘
```

**输出：**
- 更新后的 `traceId → 根节点ID` 映射（用于网端桥接）

---

## 🚫 跳过条件（`shouldSkipExtension`）

### 条件1：Explore 虚拟节点

```
nodeId.startsWith("EXPLORE_")
```

**原因：** Explore 节点是系统为断链创建的虚拟节点，没有实际的父进程。

**示例：**
```
EXPLORE_ROOT_T1 → 断链节点X → 子节点
    ↑
  虚拟节点，无父进程
```

---

### 条件2：虚拟根父节点

```
nodeId.startsWith("VIRTUAL_ROOT_PARENT_")
```

**原因：** 虚拟根父节点的 `parentProcessGuid` 固定为 `null`，无法向上扩展。

**详细说明：**

#### 虚拟根父节点的创建场景

**只在这一种情况下创建：**
```
processGuid == parentProcessGuid == traceId
```

这是特殊的自引用根节点，需要创建虚拟父节点用于网端桥接。

**创建时机：**
- 在 `ProcessChainGraphBuilder.buildGraph()` 阶段
- 检测到 `processGuid == parentProcessGuid == traceId` 时
- 生成虚拟父节点ID：`generateVirtualRootParentId(processGuid)`
- 建立映射：`graph.addVirtualRootParentMapping(processGuid, virtualParentId)`

**信息来源：**
虚拟根父节点是从**子进程日志**的 `parentXXX` 字段构造的：

```java
// ProcessChainBuilder.createVirtualParentNodeFromLog()
parentNode.setProcessName(rawLog.getParentProcessName());    // 从子进程日志
parentNode.setProcessId(rawLog.getParentProcessId());        // 从子进程日志
parentNode.setImage(rawLog.getParentImage());                // 从子进程日志
parentNode.setParentProcessGuid(null);  // ✅ 永远是 null（未知）
```

**为什么 `parentProcessGuid` 是 null？**

1. 虚拟根父节点是从**子进程日志**的 `parentXXX` 字段构造的
2. 子进程日志中**没有父进程的父进程信息**（即祖父进程信息）
3. 所以虚拟根父节点的 `parentProcessGuid` 无法确定，只能设为 `null`

**为什么无法向上扩展？**

```
extendFromNode() 需要 parentProcessGuid 作为查询条件：
  ↓
if (processEntity.getParentProcessGuid() == null) {
    return originalRootId;  // ❌ 无法扩展
}
  ↓
List<String> parentGuids = Arrays.asList(parentGuid);
List<RawLog> extensionLogs = esQueryService.queryLogsByProcessGuids(...);
                                               ↑
                                    需要 parentGuid，但它是 null
```

**结论：** 虚拟根父节点本身就是扩展的边界，无法继续向上扩展。

---

### 条件3：断链节点

```
node.getChainNode().getIsBroken() == true
```

**原因：** 断链节点的父节点日志缺失，无法继续向上追溯。

**示例：**
```
? (父节点缺失)
  ↓ (断链)
断链节点 (isBroken=true)
  ↓
子节点
```

---

## 🔍 扩展逻辑（`extendFromNode`）

### 步骤1：获取父节点 GUID

```java
ProcessEntity processEntity = originalNode.getChainNode().getProcessEntity();
if (processEntity == null || processEntity.getParentProcessGuid() == null) {
    return originalRootId; // ❌ 无父节点信息，无法扩展
}

String parentGuid = processEntity.getParentProcessGuid();
```

**检查点：**
- ✅ 如果 `parentProcessGuid == null`：直接返回，不扩展
- ✅ 如果 `parentProcessGuid` 有值：继续查询

---

### 步骤2：查询 ES

```java
List<String> parentGuids = Arrays.asList(parentGuid);
List<RawLog> extensionLogs = esQueryService.queryLogsByProcessGuids(
        hostAddress, parentGuids, maxDepth);
```

**查询深度：**
- `maxDepth=2`：查询父节点及其祖父节点（最多2层）
- ES 会递归查询 `parentProcessGuid`，直到达到 `maxDepth`

---

### 步骤3：过滤 traceId

```java
List<RawLog> filteredLogs = extensionLogs.stream()
        .filter(rawLog -> traceId.equals(rawLog.getTraceId()))
        .collect(Collectors.toList());
```

**重要：** 扩展溯源必须在同一个 `traceId` 内进行，不能跨 `traceId`。

---

### 步骤4：构建扩展链

```java
Map<String, List<RawLog>> logsByGuid = groupLogsByProcessGuid(filteredLogs);

return buildExtensionChain(
        originalRootId,    // 子节点ID（原始根节点）
        parentGuid,        // 当前节点ID（父节点）
        logsByGuid,        // 日志数据
        allNodes,          // 节点列表（会添加新节点）
        allEdges,          // 边列表（会添加新边）
        1,                 // 当前深度（从1开始）
        maxDepth);         // 最大深度
```

---

## 🏗️ 递归构建（`buildExtensionChain`）

### 递归逻辑

```
buildExtensionChain(子节点, 当前节点, depth=1):
  │
  ├─ 步骤1：创建当前节点
  │    - 转换日志为 ProcessNode
  │    - 设置 isExtensionNode=true
  │    - 设置 extensionDepth=depth
  │
  ├─ 步骤2：添加边
  │    - 创建边：当前节点 → 子节点
  │
  ├─ 步骤3：检查是否继续
  │    - parentGuid == null？ → 返回当前节点
  │    - depth >= maxDepth？ → 返回当前节点
  │    - 父节点日志不存在？ → 返回当前节点
  │
  └─ 步骤4：递归向上
       - return buildExtensionChain(当前节点, 父节点, depth+1)
```

### 终止条件

1. 当前节点没有对应的日志数据
2. 当前节点的 `parentProcessGuid` 为 `null`
3. 达到最大深度（`depth >= maxDepth`）
4. 父节点的日志不在 `logsByGuid` 中

---

## 🎯 示例场景

### 场景1：普通根节点扩展成功

**初始状态：**
```
根节点A (isRoot=true, parentProcessGuid=PARENT_B)
  ↓
子节点C
```

**扩展后：**
```
祖父节点D (新Root, isRoot=true, extensionDepth=2)
  ↓
父节点B (extensionDepth=1)
  ↓
根节点A (isRoot=false, 不再是根)
  ↓
子节点C
```

**映射更新：**
```
扩展前：traceIdToRootMap = {T1 -> A}
扩展后：traceIdToRootMap = {T1 -> D}
```

---

### 场景2：虚拟根父节点（跳过扩展）

**初始状态：**
```
VIRTUAL_ROOT_PARENT_A (isRoot=true, parentProcessGuid=null)
  ↓
特殊根节点A (processGuid==parentProcessGuid==traceId)
  ↓
子节点B
```

**执行 `performExtension`：**
```
shouldSkipExtension("VIRTUAL_ROOT_PARENT_A") → true
  ↓
跳过，保持原样
```

**映射不变：**
```
扩展前：traceIdToRootMap = {T1 -> VIRTUAL_ROOT_PARENT_A}
扩展后：traceIdToRootMap = {T1 -> VIRTUAL_ROOT_PARENT_A}
```

**原因：** 虚拟根父节点的 `parentProcessGuid` 固定为 `null`，无法继续向上扩展。

---

### 场景3：断链节点（跳过扩展）

**初始状态：**
```
EXPLORE_ROOT_T1 (虚拟节点)
  ↓ (断链边，val="断链")
断链节点X (isBroken=true, isRoot=true)
  ↓
子节点Y
```

**执行 `performExtension`：**
```
shouldSkipExtension("X") → true (因为 isBroken=true)
  ↓
跳过，保持原样
```

**映射不变：**
```
扩展前：traceIdToRootMap = {T1 -> X}
扩展后：traceIdToRootMap = {T1 -> X}
```

**原因：** 断链节点的父节点日志缺失，无法继续向上追溯。

---

### 场景4：根节点 `parentProcessGuid == null`（扩展失败）

**初始状态：**
```
根节点A (isRoot=true, parentProcessGuid=null)
  ↓
子节点B
```

**执行 `extendFromNode`：**
```java
if (processEntity.getParentProcessGuid() == null) {
    return originalRootId;  // ❌ 无父节点信息，无法扩展
}
```

**映射不变：**
```
扩展前：traceIdToRootMap = {T1 -> A}
扩展后：traceIdToRootMap = {T1 -> A}
```

**原因：** 根节点的 `parentProcessGuid` 为 `null`，无法作为查询条件。

---

## ✅ 扩展溯源逻辑正确性验证

### 1. 跳过条件完整

| 节点类型 | `parentProcessGuid` | 是否跳过 | 原因 |
|---------|-------------------|---------|------|
| Explore 虚拟节点 | N/A | ✅ 跳过 | 系统虚拟节点，无实际父进程 |
| 虚拟根父节点 | `null`（固定） | ✅ 跳过 | 从子进程日志构造，无祖父信息 |
| 断链节点 | 有值但父节点缺失 | ✅ 跳过 | 父节点日志缺失 |
| 普通根节点 | `null` | ✅ 跳过 | 在 `extendFromNode` 中返回 |
| 普通根节点 | 有值 | ✅ 可扩展 | 正常向上查询 |

---

### 2. 扩展流程正确

```
performExtension()
  ├─ 遍历所有根节点
  ├─ 检查跳过条件（Explore/虚拟根父/断链）
  ├─ 调用 extendFromNode()
  │   ├─ 检查 parentProcessGuid
  │   ├─ 查询 ES（最多 maxDepth 层）
  │   ├─ 过滤同 traceId 的日志
  │   └─ 调用 buildExtensionChain()
  │       ├─ 创建节点（设置 extensionDepth）
  │       ├─ 创建边（父 → 子）
  │       └─ 递归向上（直到达到 maxDepth）
  ├─ 更新 isRoot 标记
  └─ 返回更新后的映射
```

---

### 3. 边界条件处理

| 边界条件 | 处理方式 | 结果 |
|---------|---------|------|
| `parentProcessGuid == null` | 在 `extendFromNode` 第404行返回 | ✅ 不扩展，保持原样 |
| ES 查询结果为空 | 在 `extendFromNode` 第428行返回 | ✅ 不扩展，保持原样 |
| 过滤后无同 traceId 日志 | 在 `extendFromNode` 第446行返回 | ✅ 不扩展，保持原样 |
| 达到 maxDepth | 在 `buildExtensionChain` 第548行返回当前节点 | ✅ 停止扩展 |
| 父节点日志不存在 | 在 `buildExtensionChain` 第514行返回子节点 | ✅ 停止扩展 |

---

### 4. 正确性总结

✅ **跳过逻辑正确**：三种跳过条件（Explore、虚拟根父、断链）都有明确的原因和处理。

✅ **扩展逻辑正确**：
- 只扩展有 `parentProcessGuid` 的真实根节点
- 正确过滤同 `traceId` 的日志
- 递归构建扩展链，设置 `extensionDepth`
- 正确处理所有边界条件

✅ **映射更新正确**：
- 扩展成功：映射到最顶端节点
- 扩展失败/跳过：保持原映射

✅ **isRoot 标记正确**：
- 原根节点：`isRoot=false`
- 新顶端节点：`isRoot=true`

---

## 🎯 关键要点

1. **虚拟根父节点不扩展**：它们的 `parentProcessGuid` 固定为 `null`，本身就是扩展边界
2. **只在同 traceId 内扩展**：确保扩展的节点属于同一个攻击链
3. **最多扩展2层**：平衡性能和可见性，避免过深的扩展
4. **优雅处理失败**：任何失败都保持原映射，不影响整体流程

---

## 📝 总结

扩展溯源逻辑**完全正确**！

- ✅ 跳过条件完整且合理
- ✅ 扩展流程清晰且正确
- ✅ 边界条件处理完善
- ✅ 与虚拟根父节点的设计完美契合
- ✅ 删除 `tryReplaceVirtualRootParent` 后逻辑更加简洁和正确

**核心设计理念：** 虚拟根父节点是"占位符"，用于网端桥接，不需要（也无法）继续向上扩展。






