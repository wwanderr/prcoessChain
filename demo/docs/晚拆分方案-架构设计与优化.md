# 晚拆分方案 - 架构设计与优化说明

## 📋 方案概述

**晚拆分方案（Late Entity Extraction）**是对进程链生成系统的重大架构优化，将实体节点的提取时机从**建图阶段**推迟到**裁剪后阶段**。

### 核心思想

```
早拆分方案（旧）:
建图 → 拆分实体 → 遍历 → 子图提取 → 实体过滤 → 裁剪 → 输出
      ↑
      在这里拆分，可能导致实体节点的父进程在裁剪时被删除（断链）

晚拆分方案（新）:
建图（只含进程）→ 遍历 → 子图提取 → 裁剪 → 实体提取 → 实体过滤 → 输出
                                        ↑
                                        在这里拆分，父进程一定存在（不会断链）
```

---

## 🎯 解决的问题

### 问题1：实体节点断链

**场景描述**：
- 日志类型：`file`
- 早拆分：建图时创建 `父进程 → 子进程 → 文件实体` 三个节点
- 裁剪时：如果父进程或子进程被裁剪掉，文件实体节点就会**断链**（没有父节点）

**晚拆分解决方案**：
- 建图时：只创建 `父进程 → 子进程` 两个节点（file日志保留在子进程节点上）
- 裁剪后：从保留的子进程节点中提取文件实体
- 结果：**实体节点的父进程一定存在，不会断链**

### 问题2：建图阶段性能

**早拆分的性能瓶颈**：
- 假设有 10 万条日志，其中 3 万条是实体类型（file/domain/network/registry）
- 建图阶段会创建：10 万个进程节点 + 3 万个实体节点 = **13 万个节点**
- 后续的遍历、子图提取都要处理这 13 万个节点

**晚拆分的性能优势**：
- 建图阶段只创建：**10 万个进程节点**
- 遍历和裁剪更快（节点数少 30%）
- 裁剪后假设只剩 500 个进程节点，实体提取只需处理这 500 个节点

### 问题3：裁剪精度

**早拆分的裁剪挑战**：
- 裁剪算法需要同时考虑进程节点和实体节点的重要性
- 实体节点可能占用大量裁剪槽位
- 进程链的完整性可能受影响

**晚拆分的裁剪优势**：
- 裁剪时只考虑进程链关系（更纯粹）
- 保证关键进程链路径的完整性
- 实体节点是在裁剪后"附加"上去的

---

## 🏗️ 架构设计

### 系统架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                      进程链生成系统（晚拆分方案）                    │
└─────────────────────────────────────────────────────────────────┘

输入：
  - RawAlarm[]      告警数据
  - RawLog[]        日志数据（包含 process/file/domain/network/registry）
  - traceIds[]      溯源ID集合

                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 阶段1：建图（ProcessChainGraphBuilder）                           │
│   - 处理告警：创建告警节点（告警类型 = alarm.logType）              │
│   - 处理日志：创建进程节点（所有日志的 nodeType = "process"）       │
│   - 创建虚拟父节点（如果父进程信息只在日志字段中）                   │
│   - 建立父子边关系                                                 │
│                                                                   │
│   输出：ProcessChainGraph（只包含进程节点）                         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 阶段2：确定起点节点                                               │
│   - 有告警场景：使用告警节点作为起点                                │
│   - 无告警场景：使用指定日志的 processGuid 作为起点                │
│   - 兜底场景：使用根节点作为起点                                   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 阶段3：子图提取（全树遍历）                                        │
│   - 从起点向上遍历到根节点                                         │
│   - 在路径的每个节点向下遍历所有子树                                │
│   - 收集所有连通的节点                                            │
│                                                                   │
│   输出：相关节点ID集合                                            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 阶段4：提取子图                                                   │
│   - 根据相关节点ID从完整图中提取子图                               │
│   - 保留相关节点和它们之间的边                                     │
│                                                                   │
│   输出：ProcessChainGraph（子图，只含进程节点）                    │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 阶段5：智能裁剪（ProcessChainPruner）                             │
│   - 条件：如果进程节点数 > MAX_NODE_COUNT                         │
│   - 策略：                                                        │
│     1. 强制保留：根节点、告警节点、网端关联节点                     │
│     2. 级联保留：从关键节点到根节点的完整路径                       │
│     3. 选择性保留：剩余槽位按重要性选择其他节点                     │
│                                                                   │
│   输出：裁剪后的 ProcessChainGraph（进程节点更少）                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 阶段6：实体提取（EntityExtractor）🆕                              │
│   - 遍历裁剪后保留的进程节点                                       │
│   - 从每个进程节点的日志中识别实体日志（logType: file/domain/等）  │
│   - 为每个实体日志创建实体节点                                     │
│   - 创建边：进程节点 → 实体节点                                    │
│                                                                   │
│   关键优势：                                                      │
│   ✅ 实体节点的父进程一定在图中（不会断链）                         │
│   ✅ 只处理保留的进程节点，性能高                                  │
│                                                                   │
│   输出：ProcessChainGraph（包含进程节点 + 实体节点）               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 阶段7：实体过滤（EntityFilterUtil）                               │
│   - 对同一 processGuid 的实体节点进行过滤                         │
│   - 应用优先级规则和数量限制：                                     │
│     • file: 保留3个，优先 .exe/.dll/.bat 等后缀                   │
│     • domain: 保留5个，最新的                                     │
│     • network: 保留5个，最新的                                    │
│     • registry: 保留3个，最早的                                   │
│   - 去重逻辑（按唯一标识）                                        │
│                                                                   │
│   输出：过滤后的 ProcessChainGraph                                │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ 阶段8：转换为输出格式（IncidentConverters）                        │
│   - GraphNode → ProcessNode                                      │
│   - EdgeInfo → ProcessEdge                                       │
│   - 根据 nodeType 分配字段：                                      │
│     • process 节点：processEntity + alarmNodeInfo                │
│     • entity 节点：entity 字段                                    │
│                                                                   │
│   输出：IncidentProcessChain                                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                          最终输出
```

---

## 📦 核心组件

### 1. EntityExtractor（实体提取器）🆕

**文件**：`com.security.processchain.util.EntityExtractor`

**职责**：
- 从进程节点中提取实体节点
- 创建进程 → 实体的边关系
- 应用去重逻辑

**关键方法**：
```java
public static void extractEntitiesFromGraph(ProcessChainGraph graph)
```

**提取规则**：

| 实体类型 | 日志类型 | 节点ID格式 | 去重规则 |
|---------|---------|-----------|---------|
| file | file | `processGuid_FILE_hash(fileMd5+targetFilename)` | fileMd5 + targetFilename |
| domain | domain | `processGuid_DOMAIN_hash(requestDomain)` | requestDomain |
| network | network | `processGuid_NETWORK_hash(destAddress)` | destAddress |
| registry | registry | `processGuid_REGISTRY_hash(targetObject)` | targetObject |

**工作流程**：
```
1. 遍历图中所有节点
   └─> 筛选进程节点（nodeType == "process"）
       └─> 获取节点的日志列表
           └─> 识别实体日志（logType: file/domain/network/registry）
               └─> 按类型分组
                   └─> 为每个实体日志创建实体节点
                       └─> 创建边：进程 → 实体
                       └─> 添加到图中
```

### 2. ProcessChainGraphBuilder（建图器）🔄 重构

**文件**：`com.security.processchain.service.ProcessChainGraphBuilder`

**重构内容**：
- ❌ 移除：调用 `LogNodeSplitter.splitLogNode()` 的逻辑
- ✅ 新增：直接创建进程节点的逻辑
- ✅ 保留：虚拟父节点创建逻辑（但不拆分实体）

**关键变化**：

```java
// 旧代码（早拆分）
SplitResult splitResult = LogNodeSplitter.splitLogNode(rawLog);
if (splitResult.getEntityNode() != null) {
    graph.addNode(splitResult.getEntityNode());  // 在建图时就添加实体
}

// 新代码（晚拆分）
GraphNode childNode = createNodeFromLog(rawLog);  // 所有日志都创建进程节点
childNode.setNodeType("process");                 // nodeType 统一为 "process"
graph.addNode(childNode);
// 实体日志保留在进程节点的 logs 列表中，不拆分
```

### 3. ProcessChainBuilder（链构建器）🔄 重构

**文件**：`com.security.processchain.service.ProcessChainBuilder`

**重构内容**：
- ✅ 调整阶段顺序：裁剪 → 实体提取 → 实体过滤
- ✅ 新增：调用 `EntityExtractor.extractEntitiesFromGraph()`

**新的执行流程**：

```java
// 阶段1-4：建图、起点确定、遍历、子图提取（不变）
ProcessChainGraph subgraph = fullGraph.extractSubgraph(relevantNodes);

// 阶段5：裁剪（只裁剪进程节点）
if (subgraph.getNodeCount() > MAX_NODE_COUNT) {
    pruneGraph(subgraph);  // 只处理进程节点
}

// 阶段6：实体提取（新增）🆕
EntityExtractor.extractEntitiesFromGraph(subgraph);

// 阶段7：实体过滤（位置不变，但此时才有实体节点）
EntityFilterUtil.filterEntityNodesInGraph(subgraph);

// 阶段8：转换输出（不变）
return convertGraphToResult(subgraph, traceIds);
```

### 4. LogNodeSplitter（日志拆分器）🚫 弃用

**状态**：保留代码但不再使用

**说明**：
- 该工具类在早拆分方案中用于在建图阶段拆分日志
- 晚拆分方案中，`ProcessChainGraphBuilder` 不再调用它
- 保留代码是为了兼容性和回滚考虑

---

## 📊 性能对比

### 场景：10万条日志（3万条实体日志）

| 阶段 | 早拆分方案 | 晚拆分方案 | 性能提升 |
|-----|-----------|-----------|---------|
| 建图节点数 | 13万个（10万进程 + 3万实体） | 10万个（只有进程） | **-23%** |
| 遍历处理节点 | 13万个 | 10万个 | **-23%** |
| 裁剪输入节点 | 13万个 | 10万个 | **-23%** |
| 裁剪后节点数 | 500个（含大量实体） | 500个（只有进程） | 相同 |
| 实体提取开销 | 无（已拆分） | 从500个节点中提取 | 新增但很小 |
| 实体过滤输入 | 可能包含断链实体 | 只有有效实体 | 质量提升 |
| **总节点数** | **500个** | **500个** | 相同 |

### 性能优势总结

1. **建图性能提升 ~23%**
   - 节点创建数量减少
   - 边关系更简单（只有进程间的边）

2. **内存占用优化**
   - 建图阶段内存峰值降低
   - 垃圾回收压力减小

3. **裁剪精度提升**
   - 裁剪算法只考虑进程链关系
   - 关键路径保留更准确

4. **实体节点零断链**
   - 实体节点的父进程 100% 存在
   - 数据完整性保证

---

## 🎨 节点类型说明

### 进程节点（Process Node）

**nodeType**: `"process"`

**包含的日志类型**：
- `logType: "process"` - 纯进程日志
- `logType: "file"` - 文件操作日志（保留在进程节点）
- `logType: "domain"` - 域名请求日志（保留在进程节点）
- `logType: "network"` - 网络连接日志（保留在进程节点）
- `logType: "registry"` - 注册表操作日志（保留在进程节点）

**实体提取时机**：
- 裁剪后，`EntityExtractor` 会遍历进程节点的日志
- 识别 `logType: file/domain/network/registry` 的日志
- 为这些日志创建对应的实体节点

### 实体节点（Entity Node）

**nodeType**: 
- `"file_entity"`
- `"domain_entity"`
- `"network_entity"`
- `"registry_entity"`

**创建时机**：裁剪后（阶段6）

**父节点**：一定是某个进程节点（保证不断链）

**字段映射**：
```java
// ProcessNode 中的字段分配
if (nodeType.endsWith("_entity")) {
    chainNode.setEntity(...);        // 只设置 entity 字段
    chainNode.setProcessEntity(null); // 不设置 processEntity
    chainNode.setAlarmNodeInfo(null); // 不设置 alarmNodeInfo
} else {
    chainNode.setProcessEntity(...);  // 只设置 processEntity
    chainNode.setEntity(null);        // 不设置 entity
    // alarmNodeInfo 根据是否是告警节点决定
}
```

---

## 🔄 数据流示例

### 示例：文件创建日志

**输入日志**：
```json
{
  "logType": "file",
  "opType": "create",
  "processGuid": "GUID_CHILD",
  "parentProcessGuid": "GUID_PARENT",
  "processName": "malware.exe",
  "targetFilename": "C:\\Windows\\System32\\evil.dll",
  "fileMd5": "abc123..."
}
```

**早拆分方案（旧）**：
```
阶段1：建图
  创建节点：
    - 父进程: GUID_PARENT (虚拟或真实)
    - 子进程: GUID_CHILD
    - 文件实体: GUID_CHILD_FILE_hash
  创建边：
    - GUID_PARENT → GUID_CHILD
    - GUID_CHILD → GUID_CHILD_FILE_hash

阶段5：裁剪
  假设 GUID_CHILD 被裁剪掉了
  
结果：文件实体节点 GUID_CHILD_FILE_hash 断链 ❌
```

**晚拆分方案（新）**：
```
阶段1：建图
  创建节点：
    - 父进程: GUID_PARENT (虚拟或真实)
    - 子进程: GUID_CHILD （日志保留在这里）
  创建边：
    - GUID_PARENT → GUID_CHILD

阶段5：裁剪
  假设保留了 GUID_CHILD
  
阶段6：实体提取
  从 GUID_CHILD 的日志中识别 logType: "file"
  创建文件实体节点: GUID_CHILD_FILE_hash
  创建边: GUID_CHILD → GUID_CHILD_FILE_hash
  
结果：文件实体节点一定有父节点 ✅
```

---

## ✅ 优化效果

### 1. 解决实体断链问题
- ✅ **实体节点的父进程 100% 存在**
- ✅ 图结构更完整
- ✅ 前端展示无断链

### 2. 提升建图性能
- ✅ 节点数减少 ~23%（取决于实体日志比例）
- ✅ 内存占用降低
- ✅ 遍历速度提升

### 3. 优化裁剪精度
- ✅ 裁剪算法只关注进程链关系
- ✅ 关键路径保留更准确
- ✅ 实体节点是"附加"的，不占用裁剪槽位

### 4. 简化架构
- ✅ 建图阶段逻辑更简单（不需要拆分）
- ✅ 实体提取独立为单独阶段（职责清晰）
- ✅ 代码可维护性提升

---

## 🚀 未来优化方向

### 1. 实体提取并行化
```java
// 当前：串行提取
for (GraphNode processNode : graph.getAllNodes()) {
    extractEntitiesFromNode(processNode);
}

// 优化：并行提取（如果进程节点数很多）
graph.getAllNodes()
    .parallelStream()
    .forEach(node -> extractEntitiesFromNode(node));
```

### 2. 实体过滤策略优化
- 当前：固定数量限制（file: 3, domain: 5...）
- 优化：根据告警重要性动态调整保留数量

### 3. 增量实体提取
- 当前：一次性提取所有实体
- 优化：按需提取（如：只提取关键进程的实体）

### 4. 实体节点缓存
- 对于相同的 `processGuid + 实体标识`，缓存已创建的实体节点ID
- 避免重复计算hash

---

## 📝 迁移说明

### 从早拆分迁移到晚拆分

**代码变更**：
1. ✅ `ProcessChainGraphBuilder` - 已重构
2. ✅ `ProcessChainBuilder` - 已重构
3. ✅ `EntityExtractor` - 新增

**不需要变更**：
- ❌ `EntityFilterUtil` - 逻辑不变，只是调用时机变了
- ❌ `ProcessChainPruner` - 逻辑不变
- ❌ `IncidentConverters` - 逻辑不变

**兼容性**：
- ✅ API接口不变（输入输出相同）
- ✅ 数据结构不变（ProcessNode/ProcessEdge）
- ✅ 前端无需改动

**回滚方案**：
- 保留了 `LogNodeSplitter` 代码
- 如需回滚，恢复 `ProcessChainGraphBuilder` 中对 `LogNodeSplitter.splitLogNode()` 的调用即可

---

## 📊 总结

晚拆分方案通过**延迟实体节点的创建时机**，从根本上解决了实体断链问题，同时带来了显著的性能提升和架构简化。

| 对比项 | 早拆分方案 | 晚拆分方案 | 优势 |
|-------|-----------|-----------|-----|
| 实体断链 | ❌ 可能发生 | ✅ 不会发生 | 质量提升 |
| 建图性能 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | +23% |
| 裁剪精度 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 更准确 |
| 代码复杂度 | ⭐⭐⭐⭐ | ⭐⭐⭐ | 更简单 |

**推荐**：所有新项目使用晚拆分方案，现有项目逐步迁移。

