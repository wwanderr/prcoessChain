# 进程链生成系统 - 核心代码实现文档

> **文档目的**: 帮助开发者快速理解核心代码实现逻辑，方便对照源码阅读  
> **适用人员**: 后端开发、安全分析、代码审查  
> **最后更新**: 2025-10-25

---

## 📚 目录

1. [系统架构概览](#1-系统架构概览)
2. [核心类详解](#2-核心类详解)
3. [关键流程](#3-关键流程)
4. [数据结构](#4-数据结构)
5. [算法实现](#5-算法实现)
6. [优化策略](#6-优化策略)
7. [常见问题](#7-常见问题)
8. [代码阅读建议](#8-代码阅读建议)

---

## 1. 系统架构概览

### 1.1 核心组件关系

```
┌─────────────────────────────────────────────────────────────┐
│                    ProcessChainController                    │
│                      (REST API 入口)                         │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│              ProcessChainServiceImpl (服务层)                │
│  • 批量查询告警和日志                                         │
│  • 告警选举                                                   │
│  • 进程链构建调度                                             │
│  • 网侧端侧合并                                               │
└──────────────────────────┬──────────────────────────────────┘
                           │
           ┌───────────────┼───────────────┐
           ▼               ▼               ▼
    ┌──────────┐  ┌──────────────┐  ┌──────────────┐
    │ ES查询   │  │ 告警选举     │  │ 进程链构建   │
    │ Service  │  │ Util         │  │ Builder      │
    └──────────┘  └──────────────┘  └──────────────┘
                           │
                           ▼
                  ┌──────────────────┐
                  │  智能裁剪 Pruner  │
                  └──────────────────┘
```

### 1.2 数据流向

```
原始告警(RawAlarm) + 原始日志(RawLog)
           │
           ▼
    [告警选举算法]
           │
           ▼
    [进程链构建]
           │
           ├─→ 高危告警: 双向遍历(向上+向下)
           └─→ 中低危告警: 向上遍历
           │
           ▼
    [断链检测与EXPLORE节点]
           │
           ▼
    [智能裁剪(超过1000节点)]
           │
           ▼
    [网侧端侧合并]
           │
           ▼
    最终进程链(IncidentProcessChain)
```

---

## 2. 核心类详解

### 2.1 ProcessChainBuilder (进程链构建器)

**文件位置**: `com.security.processchain.service.ProcessChainBuilder`

**核心职责**:
- 根据告警和日志构建进程链图结构
- 处理单/多 traceId 场景
- 检测断链并创建 EXPLORE 虚拟根节点
- 支持高危告警的双向遍历和中低危告警的向上遍历

#### 2.1.1 关键字段

```java
// 节点存储: key=processGuid, value=ChainBuilderNode
private Map<String, ChainBuilderNode> nodeMap;

// 边列表
private List<ChainBuilderEdge> edges;

// 根节点集合
private Set<String> rootNodes;

// 断链节点集合
private Set<String> brokenNodes;

// 断链节点到traceId的映射(用于多traceId场景)
private Map<String, String> brokenNodeToTraceId;

// traceId到根节点ID的映射(用于网侧桥接)
private Map<String, String> traceIdToRootNodeMap;

// 最大遍历深度限制(防止环)
private static final int MAX_TRAVERSE_DEPTH = 50;

// 节点数量上限
private static final int MAX_NODE_COUNT = 1000;
```

#### 2.1.2 核心方法

##### `buildProcessChain()` - 主入口

**方法签名**:
```java
public ProcessChainResult buildProcessChain(
    List<RawAlarm> alarms,      // 告警列表
    List<RawLog> logs,          // 日志列表
    Set<String> traceIds,       // 溯源ID集合
    Set<String> associatedEventIds  // 网端关联的eventId
)
```

**执行流程**:

```
1. 参数校验
   ├─ 告警列表不能为空
   └─ traceIds不能为空

2. 日志索引化
   ├─ 按processGuid索引: Map<String, List<RawLog>>
   └─ 按parentProcessGuid索引: Map<String, List<RawLog>>

3. 遍历每个告警
   ├─ 高危告警 → buildBidirectionalChain() (双向遍历)
   └─ 中低危告警 → buildUpwardChain() (向上遍历)

4. 智能裁剪(如果节点数>1000)
   └─ 调用 ProcessChainPruner.pruneNodes()

5. 构建返回结果
   ├─ 节点列表
   ├─ 边列表
   ├─ 根节点集合
   ├─ 断链节点集合
   └─ traceId映射
```

**代码位置**: `ProcessChainBuilder.java` 第71-173行

---

##### `buildBidirectionalChain()` - 双向遍历(高危告警)

**方法签名**:
```java
private void buildBidirectionalChain(
    RawAlarm alarm,
    Map<String, List<RawLog>> logsByProcessGuid,
    Map<String, List<RawLog>> logsByParentProcessGuid,
    Set<String> traceIds
)
```

**执行逻辑**:

```
1. 添加告警节点
   └─ addAlarmNode(alarm)

2. 检查告警节点是否是根节点
   └─ if (traceIds.contains(processGuid))
      ├─ 标记为根节点
      └─ 记录 traceId → rootNodeId 映射

3. 添加同级日志节点
   └─ 从 logsByProcessGuid 获取同processGuid的日志

4. 向上遍历(如果不是根节点)
   └─ traverseUpward(processGuid, ...)

5. 向下遍历
   └─ traverseDownward(processGuid, ...)
```

**适用场景**: 高危告警需要完整的攻击链路(父进程+子进程)

**代码位置**: `ProcessChainBuilder.java` 第178-247行

---

##### `buildUpwardChain()` - 向上遍历(中低危告警)

**方法签名**:
```java
private void buildUpwardChain(
    RawAlarm alarm,
    Map<String, List<RawLog>> logsByProcessGuid,
    Set<String> traceIds
)
```

**执行逻辑**:

```
1. 添加告警节点

2. 检查告警节点是否是根节点

3. 添加同级日志节点

4. 向上遍历到根节点
   └─ traverseUpward(processGuid, ...)
```

**适用场景**: 中低危告警只需要追溯到攻击源头

**代码位置**: `ProcessChainBuilder.java` 第252-310行

---

##### `traverseUpward()` - 向上递归遍历

**方法签名**:
```java
private void traverseUpward(
    String processGuid,
    Map<String, List<RawLog>> logsByProcessGuid,
    Set<String> traceIds,
    int depth  // 当前深度
)
```

**核心逻辑**:

```java
// 1. 深度检查(防止无限递归)
if (depth >= MAX_TRAVERSE_DEPTH) {
    log.warn("达到最大深度限制");
    return;
}

// 2. 环检测
if (visitedNodesInPath.contains(processGuid)) {
    log.warn("检测到环");
    return;
}

// 3. 获取当前节点
ChainBuilderNode currentNode = nodeMap.get(processGuid);

// 4. 检查是否是根节点
if (traceIds.contains(processGuid)) {
    foundRootNode = true;
    rootNodes.add(processGuid);
    currentNode.setIsRoot(true);  // ✅ 设置isRoot标记
    traceIdToRootNodeMap.put(traceId, processGuid);
    return;  // 找到根节点,停止向上
}

// 5. 获取父节点GUID
String parentProcessGuid = currentNode.getParentProcessGuid();

// 6. 检查父节点是否存在
if (parentProcessGuid == null || !nodeMap.containsKey(parentProcessGuid)) {
    // 断链!
    brokenNodes.add(processGuid);
    currentNode.setIsBroken(true);  // ✅ 设置isBroken标记
    
    // 记录断链节点的traceId(用于多traceId场景)
    String traceId = extractTraceIdFromNode(currentNode);
    if (traceId != null) {
        brokenNodeToTraceId.put(processGuid, traceId);
    }
    return;
}

// 7. 添加父节点和边
addLogNode(parentLog, false);
addEdge(parentProcessGuid, processGuid);

// 8. 递归向上
traverseUpward(parentProcessGuid, logsByProcessGuid, traceIds, depth + 1);
```

**关键点**:
- **深度限制**: 防止环导致栈溢出
- **环检测**: 使用 `visitedNodesInPath` 集合
- **断链检测**: 父节点不存在时标记为断链
- **traceId提取**: 从节点的告警或日志中提取traceId

**代码位置**: `ProcessChainBuilder.java` 第312-428行

---

##### `addExploreNodesForBrokenChains()` - 创建EXPLORE虚拟根节点

**方法签名**:
```java
private void addExploreNodesForBrokenChains(
    Set<String> brokenNodes,
    Set<String> traceIds,
    Map<String, String> brokenNodeToTraceId  // 断链节点→traceId映射
)
```

**核心逻辑**:

```java
// 场景1: 单traceId - 创建一个 EXPLORE_ROOT_{traceId}
if (traceIds.size() == 1) {
    String traceId = traceIds.iterator().next();
    String exploreNodeId = "EXPLORE_ROOT_" + traceId;
    
    // 创建虚拟根节点
    ChainBuilderNode exploreNode = new ChainBuilderNode();
    exploreNode.setProcessGuid(exploreNodeId);
    exploreNode.setIsRoot(true);
    nodeMap.put(exploreNodeId, exploreNode);
    
    // 连接所有断链节点到EXPLORE节点
    for (String brokenGuid : brokenNodes) {
        addEdge(exploreNodeId, brokenGuid);
    }
    
    // 记录映射
    traceIdToRootNodeMap.put(traceId, exploreNodeId);
}

// 场景2: 多traceId - 每个traceId创建独立的 EXPLORE_ROOT_{traceId}
else {
    // 按traceId分组断链节点
    Map<String, List<String>> brokenNodesByTraceId = new HashMap<>();
    for (String brokenGuid : brokenNodes) {
        String traceId = brokenNodeToTraceId.get(brokenGuid);
        if (traceId != null) {
            brokenNodesByTraceId
                .computeIfAbsent(traceId, k -> new ArrayList<>())
                .add(brokenGuid);
        }
    }
    
    // 为每个traceId创建独立的EXPLORE节点
    for (Map.Entry<String, List<String>> entry : brokenNodesByTraceId.entrySet()) {
        String traceId = entry.getKey();
        List<String> brokenGuidsForTrace = entry.getValue();
        
        String exploreNodeId = "EXPLORE_ROOT_" + traceId;
        
        // 创建虚拟根节点
        ChainBuilderNode exploreNode = new ChainBuilderNode();
        exploreNode.setProcessGuid(exploreNodeId);
        exploreNode.setIsRoot(true);
        nodeMap.put(exploreNodeId, exploreNode);
        
        // 连接该traceId的断链节点
        for (String brokenGuid : brokenGuidsForTrace) {
            addEdge(exploreNodeId, brokenGuid);
        }
        
        // 记录映射
        traceIdToRootNodeMap.put(traceId, exploreNodeId);
    }
}
```

**设计原则**:
- **单traceId**: 所有断链节点共享一个 `EXPLORE_ROOT_{traceId}`
- **多traceId**: 每个traceId的断链节点连接到各自的 `EXPLORE_ROOT_{traceId}`
- **命名规范**: `EXPLORE_ROOT_{traceId}` 确保唯一性

**代码位置**: `ProcessChainBuilder.java` 第757-867行

---

### 2.2 ProcessChainServiceImpl (服务实现层)

**文件位置**: `com.security.processchain.service.impl.ProcessChainServiceImpl`

**核心职责**:
- 批量查询告警和日志(性能优化)
- 告警选举(选择最严重的traceId)
- 调度进程链构建
- 网侧端侧合并

#### 2.2.1 核心方法

##### `generateProcessChains()` - 主入口

**方法签名**:
```java
public IncidentProcessChain generateProcessChains(
    IpMappingRelation ipMappingRelation,  // IP映射关系
    Pair<List<ProcessNode>, List<ProcessEdge>> networkChain  // 网侧进程链(可选)
)
```

**执行流程**:

```
阶段1: 批量查询告警
├─ esQueryService.batchQueryEDRAlarms(ips)
└─ 返回 Map<String, List<RawAlarm>>

阶段2: 告警选举
├─ 遍历每个IP
├─ selectAlarm(alarms, associatedEventId, hasAssociation)
│  ├─ 优先选择网端关联的告警
│  └─ 否则使用选举算法
└─ 收集所有选中的告警和traceId

阶段3: 批量查询日志
├─ 构建 hostToTraceId 映射
└─ esQueryService.batchQueryRawLogs(hostToTraceId)

阶段4: 构建端侧进程链
├─ ProcessChainBuilder.buildIncidentChain(...)
└─ 返回 IncidentProcessChain

阶段5: 合并网侧和端侧(如果有网侧数据)
└─ mergeNetworkAndEndpointChain(...)
```

**代码位置**: `ProcessChainServiceImpl.java` 第37-206行

---

##### `selectAlarm()` - 告警选举

**方法签名**:
```java
private List<RawAlarm> selectAlarm(
    List<RawAlarm> alarms,
    String associatedEventId,
    boolean hasAssociation
)
```

**选举策略**:

```
场景1: 有网端关联
├─ 查找 eventId == associatedEventId 的告警
├─ 如果找到,使用该告警的traceId
└─ 返回该traceId的所有告警

场景2: 无网端关联或关联失败
├─ 按traceId分组告警
├─ 调用 AlarmElectionUtil.electAlarm(alarmGroups)
│  ├─ 优先级1: 高危告警数量
│  ├─ 优先级2: 中危告警数量
│  └─ 优先级3: 低危告警数量
└─ 返回选中traceId的所有告警
```

**代码位置**: `ProcessChainServiceImpl.java` 第218-266行

---

##### `mergeNetworkAndEndpointChain()` - 网侧端侧合并

**方法签名**:
```java
private IncidentProcessChain mergeNetworkAndEndpointChain(
    Pair<List<ProcessNode>, List<ProcessEdge>> networkChain,
    IncidentProcessChain endpointChain,
    Map<String, String> hostToTraceId
)
```

**合并逻辑**:

```
1. 添加网侧节点(storyNode)
   └─ 包含 victim, attacker, tool 等节点

2. 添加端侧节点(chainNode)
   └─ 包含进程链节点

3. 添加网侧边

4. 添加端侧边

5. 创建桥接边(关键!)
   └─ createBridgeEdges(networkNodes, hostToTraceId, traceIdToRootNodeMap)
```

**代码位置**: `ProcessChainServiceImpl.java` 第296-371行

---

##### `createBridgeEdges()` - 创建桥接边

**方法签名**:
```java
private List<ProcessEdge> createBridgeEdges(
    List<ProcessNode> networkNodes,
    Map<String, String> hostToTraceId,
    Map<String, String> traceIdToRootNodeMap
)
```

**桥接逻辑**:

```
遍历网侧节点:
  ├─ 只处理 storyNode.type == "victim" 的节点
  │
  ├─ 步骤1: 从 storyNode.other.ip 提取 victim 的 IP
  │
  ├─ 步骤2: 通过 hostToTraceId 映射找到该 IP 对应的 traceId
  │
  ├─ 步骤3: 通过 traceIdToRootNodeMap 映射找到该 traceId 对应的根节点ID
  │  └─ 可能是真实根节点,也可能是 EXPLORE_ROOT_{traceId}
  │
  └─ 步骤4: 创建桥接边
     ├─ source = victim.nodeId
     ├─ target = rootNodeId
     └─ val = "桥接"
```

**设计优势**:
- **支持EXPLORE节点**: 即使端侧没有真实根节点,也能通过EXPLORE节点桥接
- **多traceId支持**: 每个victim通过IP→traceId→rootNodeId链路找到对应的根节点
- **逻辑清晰**: IP → traceId → rootNodeId 三级映射

**代码位置**: `ProcessChainServiceImpl.java` 第393-497行

---

### 2.3 ProcessChainPruner (智能裁剪工具)

**文件位置**: `com.security.processchain.util.ProcessChainPruner`

**核心职责**:
- 当节点数超过1000时进行智能裁剪
- 保证关键节点(根节点、告警节点、网端关联节点)不被裁剪
- 级联保留从关键节点到根节点的完整路径

#### 2.3.1 核心方法

##### `pruneNodes()` - 主入口

**方法签名**:
```java
public static PruneResult pruneNodes(PruneContext context)
```

**执行流程**:

```
1. 备份原始数据(安全措施)
   ├─ backupNodeMap = new HashMap<>(nodeMap)
   └─ backupEdges = new ArrayList<>(edges)

2. 识别必须保留的节点
   └─ identifyMustKeepNodes(context)
      ├─ 所有根节点
      ├─ 所有网端关联节点
      ├─ 所有高危告警节点
      └─ 所有中危告警节点

3. 级联保留完整路径
   └─ cascadeKeepParentChain(context, mustKeepNodes)
      └─ 从必须保留的节点向上追溯到根节点

4. 选择剩余节点(如果还有槽位)
   └─ selectRemainingNodes(context, nodesToKeep)
      ├─ 计算所有节点的重要性分数
      └─ 按分数排序选择前N个

5. 执行裁剪
   └─ performPruning(context, nodesToKeep, ...)
      ├─ 移除不在保留集合中的节点
      └─ 移除相关的边

6. 裁剪后验证
   └─ validateAfterPruning(context, result)
      ├─ 验证根节点必须保留
      └─ 验证数据完整性

7. 如果验证失败,回滚到原始数据
```

**代码位置**: `ProcessChainPruner.java` 第134-211行

---

##### `calculateNodeScores()` - 节点评分算法

**方法签名**:
```java
private static Map<String, Integer> calculateNodeScores(PruneContext context)
```

**评分规则**:

| 节点类型 | 分数 | 说明 |
|---------|------|------|
| 网端关联告警节点 | +1000 | 最高优先级 |
| 高危告警节点 | +100 | 关键安全事件 |
| 中危告警节点 | +50 | 重要安全事件 |
| 低危告警节点 | +20 | 一般安全事件 |
| 根节点 | +80 | 攻击源头 |
| 连接数(度中心性) | +2×连接数 (最多+30) | 关键路径节点 |
| 有日志数据 | +10 | 有详细信息 |
| process类型 | +5 | 核心进程 |

**代码位置**: `ProcessChainPruner.java` 第581-676行

---

### 2.4 AlarmElectionUtil (告警选举工具)

**文件位置**: `com.security.processchain.util.AlarmElectionUtil`

**核心职责**:
- 从多个traceId的告警组中选出最严重的一组

#### 2.4.1 核心方法

##### `electAlarm()` - 选举算法

**方法签名**:
```java
public static String electAlarm(Map<String, List<RawAlarm>> alarmGroups)
```

**选举规则**:

```
1. 计算每个告警组的威胁统计
   └─ ThreatStatistics { highCount, mediumCount, lowCount }

2. 比较威胁统计
   ├─ 优先级1: 高危告警数量多的组
   ├─ 优先级2: 中危告警数量多的组
   └─ 优先级3: 低危告警数量多的组

3. 返回最优组的traceId
```

**示例**:

```java
// 组A: 高危=2, 中危=1, 低危=3
// 组B: 高危=1, 中危=5, 低危=10
// 结果: 选择组A (因为高危告警数量更多)

// 组C: 高危=2, 中危=3, 低危=1
// 组D: 高危=2, 中危=5, 低危=2
// 结果: 选择组D (高危相同,中危更多)
```

**代码位置**: `AlarmElectionUtil.java` 第20-58行

---

## 3. 关键流程

### 3.1 完整进程链生成流程

```
开始
  │
  ▼
批量查询告警
  │
  ▼
告警选举
  │
  ▼
批量查询日志
  │
  ▼
构建进程链
  │
  ▼
节点数>1000? ──是──> 智能裁剪
  │否                    │
  ▼                      ▼
检测断链 <───────────────┘
  │
  ▼
有断链? ──是──> 创建EXPLORE节点
  │否              │
  ▼                ▼
构建最终结果 <────┘
  │
  ▼
有网侧数据? ──是──> 网侧端侧合并 ──> 创建桥接边
  │否                                    │
  ▼                                      ▼
返回端侧进程链                    返回完整进程链
  │                                      │
  └──────────────────┬───────────────────┘
                     ▼
                    结束
```

### 3.2 向上遍历流程(核心算法)

```
当前节点 = 告警节点
深度 = 0

while (深度 < 50):
    ├─ 检查是否访问过(环检测)
    │  └─ 如果访问过,停止遍历
    │
    ├─ 检查是否是根节点(traceId匹配)
    │  ├─ 如果是,标记为根节点
    │  ├─ 记录 traceId → rootNodeId 映射
    │  └─ 停止遍历
    │
    ├─ 获取父节点GUID
    │
    ├─ 检查父节点是否存在
    │  ├─ 如果不存在,标记为断链节点
    │  ├─ 记录断链节点的traceId
    │  └─ 停止遍历
    │
    ├─ 添加父节点到nodeMap
    │
    ├─ 添加边: 父节点 → 当前节点
    │
    ├─ 当前节点 = 父节点
    │
    └─ 深度 += 1
```

### 3.3 断链处理流程

```
场景1: 单traceId
├─ 创建 EXPLORE_ROOT_{traceId}
├─ 连接所有断链节点到EXPLORE节点
└─ 记录 traceId → EXPLORE_ROOT_{traceId} 映射

场景2: 多traceId
├─ 按traceId分组断链节点
│  └─ 使用 brokenNodeToTraceId 映射
│
├─ 为每个traceId创建独立的EXPLORE节点
│  ├─ EXPLORE_ROOT_{traceId1}
│  ├─ EXPLORE_ROOT_{traceId2}
│  └─ ...
│
└─ 连接各自的断链节点
   ├─ traceId1的断链 → EXPLORE_ROOT_{traceId1}
   └─ traceId2的断链 → EXPLORE_ROOT_{traceId2}
```

---

## 4. 数据结构

### 4.1 核心数据模型

#### ProcessNode (最终返回的节点)

```java
public class ProcessNode {
    private NodeType logType;              // 日志类型
    private ThreatSeverity nodeThreatSeverity;  // 威胁等级
    private String nodeId;                 // 节点ID
    private Boolean isChainNode;           // 是否是进程链节点
    private ChainNode chainNode;           // 进程链节点详情
    private StoryNode storyNode;           // 故事线节点详情
}
```

#### ChainNode (进程链节点详情)

```java
public class ChainNode {
    private Boolean isRoot;                // 是否是根节点
    private Boolean isBroken;              // 是否是断链节点
    private Boolean isAlarm;               // 是否是告警节点
    private AlarmNodeInfo alarmNodeInfo;   // 告警信息
    private ProcessEntity processEntity;   // 进程实体
    private Object entity;                 // 其他实体(file/network/domain)
}
```

#### ChainBuilderNode (构建过程中的内部节点)

```java
public static class ChainBuilderNode {
    private String processGuid;            // 进程GUID
    private String parentProcessGuid;      // 父进程GUID
    private List<RawAlarm> alarms;         // 告警列表
    private List<RawLog> logs;             // 日志列表
    
    // 数据结构优化新增字段
    private String traceId;                // 溯源ID
    private String hostAddress;            // 主机地址
    private Boolean isRoot;                // 是否是根节点
    private Boolean isBroken;              // 是否是断链节点
    private Boolean isAlarm;               // 是否是告警节点
    private Integer importance;            // 重要性分数
}
```

#### ProcessChainResult (构建结果)

```java
public static class ProcessChainResult {
    private NodeIndex nodeIndex;           // 节点索引(优化版)
    private List<ChainBuilderEdge> edges;  // 边列表
    private Map<String, String> traceIdToRootNodeMap;  // traceId→根节点映射
    private Map<String, String> brokenNodeToTraceId;   // 断链节点→traceId映射
}
```

### 4.2 NodeIndex (节点索引结构)

```java
public class NodeIndex {
    // 主索引: processGuid → Node (O(1)查找)
    private Map<String, ChainBuilderNode> nodesByGuid;
    
    // traceId索引: traceId → List<Node>
    private Map<String, List<ChainBuilderNode>> nodesByTraceId;
    
    // hostAddress索引: hostAddress → List<Node>
    private Map<String, List<ChainBuilderNode>> nodesByHost;
    
    // 根节点集合
    private Set<ChainBuilderNode> rootNodes;
    
    // 断链节点集合
    private Set<ChainBuilderNode> brokenNodes;
    
    // 告警节点集合
    private Set<ChainBuilderNode> alarmNodes;
}
```

**优化建议**: 将 `List<ChainBuilderNode>` 改为 `Set<ChainBuilderNode>` 可以将删除操作从 O(n) 优化到 O(1)。

---

## 5. 算法实现

### 5.1 环检测算法

```java
// 使用访问集合检测环
private Set<String> visitedNodesInPath = new HashSet<>();

private void traverseUpward(...) {
    // 环检测
    if (visitedNodesInPath.contains(processGuid)) {
        log.warn("检测到环: {}", processGuid);
        return;
    }
    
    visitedNodesInPath.add(processGuid);
    
    // ... 遍历逻辑 ...
    
    // 注意: 每次新的遍历路径前需要清空
    visitedNodesInPath.clear();
}
```

### 5.2 断链检测算法

```java
// 检查父节点是否存在
String parentGuid = currentNode.getParentProcessGuid();

if (parentGuid == null || parentGuid.isEmpty()) {
    // 情况1: 节点没有父节点信息
    brokenNodes.add(processGuid);
    return;
}

if (!nodeMap.containsKey(parentGuid)) {
    // 情况2: 父节点不在nodeMap中(日志缺失)
    brokenNodes.add(processGuid);
    
    // 提取并记录该断链节点的traceId
    String traceId = extractTraceIdFromNode(currentNode);
    if (traceId != null) {
        brokenNodeToTraceId.put(processGuid, traceId);
    }
    
    return;
}
```

### 5.3 traceId提取算法

```java
private String extractTraceIdFromNode(ChainBuilderNode node) {
    // 优先从告警中提取
    if (node.getAlarms() != null) {
        for (RawAlarm alarm : node.getAlarms()) {
            if (alarm != null && alarm.getTraceId() != null) {
                return alarm.getTraceId();
            }
        }
    }
    
    // 其次从日志中提取
    if (node.getLogs() != null) {
        for (RawLog log : node.getLogs()) {
            if (log != null && log.getTraceId() != null) {
                return log.getTraceId();
            }
        }
    }
    
    return null;
}
```

---

## 6. 优化策略

### 6.1 性能优化

#### 批量查询优化

```java
// ❌ 原始方式: 逐个IP查询(N次网络请求)
for (String ip : ips) {
    List<RawAlarm> alarms = esQueryService.queryEDRAlarms(ip);
    // 处理...
}

// ✅ 优化方式: 批量查询(1次网络请求)
Map<String, List<RawAlarm>> allAlarmsMap = 
    esQueryService.batchQueryEDRAlarms(ips);
```

**性能提升**: 10个IP从10次请求降低到1次请求，响应时间从10秒降低到1秒。

#### 日志索引化

```java
// ❌ 原始方式: 每次查找都遍历整个日志列表 O(n)
for (RawLog log : allLogs) {
    if (log.getProcessGuid().equals(targetGuid)) {
        // 找到了
    }
}

// ✅ 优化方式: 预先建立索引 O(1)
Map<String, List<RawLog>> logsByProcessGuid = indexLogsByProcessGuid(logs);
List<RawLog> targetLogs = logsByProcessGuid.get(targetGuid);
```

### 6.2 内存优化

#### 智能裁剪

```java
// 当节点数超过1000时触发裁剪
if (nodeMap.size() > MAX_NODE_COUNT) {
    ProcessChainPruner.pruneNodes(context);
}
```

**裁剪策略**:
1. 必须保留: 根节点、高危告警、中危告警、网端关联节点
2. 级联保留: 从关键节点到根节点的完整路径
3. 按分数选择: 剩余槽位按重要性分数填充

### 6.3 安全性优化

#### 深度限制

```java
private static final int MAX_TRAVERSE_DEPTH = 50;

if (depth >= MAX_TRAVERSE_DEPTH) {
    log.warn("达到最大深度限制，停止遍历");
    return;
}
```

**防止**: 环导致的无限递归和栈溢出

#### 回滚机制

```java
// 裁剪前备份
Map<String, ChainBuilderNode> backup = new HashMap<>(nodeMap);

try {
    // 执行裁剪
    pruneNodes(context);
    
    // 验证
    if (!validateAfterPruning(context)) {
        // 回滚
        nodeMap.clear();
        nodeMap.putAll(backup);
    }
} catch (Exception e) {
    // 异常时回滚
    nodeMap.clear();
    nodeMap.putAll(backup);
}
```

---

## 7. 常见问题

### Q1: 为什么需要 EXPLORE 节点?

**A**: 当进程链无法追溯到真实根节点时(父进程日志缺失),需要创建虚拟根节点 `EXPLORE_ROOT_{traceId}` 来:
1. 保证图结构的完整性
2. 为网侧桥接提供连接点
3. 标识需要进一步探索的断链

### Q2: 多traceId场景下如何保证断链节点连接到正确的EXPLORE节点?

**A**: 通过 `brokenNodeToTraceId` 映射:
```java
// 在检测到断链时记录
String traceId = extractTraceIdFromNode(brokenNode);
brokenNodeToTraceId.put(brokenGuid, traceId);

// 创建EXPLORE节点时使用
for (String brokenGuid : brokenNodes) {
    String traceId = brokenNodeToTraceId.get(brokenGuid);
    String exploreNodeId = "EXPLORE_ROOT_" + traceId;
    addEdge(exploreNodeId, brokenGuid);
}
```

### Q3: 为什么高危告警要双向遍历?

**A**: 高危告警通常是攻击的关键环节,需要:
- **向上遍历**: 追溯攻击源头(父进程链)
- **向下遍历**: 追踪攻击影响(子进程链)

这样才能获得完整的攻击链路。

### Q4: 智能裁剪会不会破坏进程链的完整性?

**A**: 不会,因为裁剪算法保证:
1. 所有根节点必须保留
2. 所有关键告警节点必须保留
3. 从关键节点到根节点的完整路径必须保留
4. 裁剪后会进行验证,失败则回滚

### Q5: MAX_TRAVERSE_DEPTH 为什么是 50?

**A**: 这是一个平衡点:
- **防止栈溢出**: 50层递归深度在JVM默认栈大小下是安全的
- **性能考虑**: 遍历50层的时间复杂度是可接受的
- **实际场景**: 真实攻击链很少超过50层,如果超过通常是环或异常数据

**影响**: 当进程链深度超过50层时,只会返回从告警节点向上50层的节点,更深的节点会被截断。

---

## 8. 代码阅读建议

### 8.1 阅读顺序

1. **入口**: `ProcessChainServiceImpl.generateProcessChains()`
2. **核心**: `ProcessChainBuilder.buildProcessChain()`
3. **遍历**: `ProcessChainBuilder.traverseUpward()`
4. **断链**: `ProcessChainBuilder.addExploreNodesForBrokenChains()`
5. **裁剪**: `ProcessChainPruner.pruneNodes()`
6. **合并**: `ProcessChainServiceImpl.mergeNetworkAndEndpointChain()`

### 8.2 关键代码位置

| 功能 | 文件 | 行号 |
|------|------|------|
| 主入口 | ProcessChainServiceImpl.java | 37-206 |
| 进程链构建 | ProcessChainBuilder.java | 71-173 |
| 向上遍历 | ProcessChainBuilder.java | 312-428 |
| 断链处理 | ProcessChainBuilder.java | 757-867 |
| 智能裁剪 | ProcessChainPruner.java | 134-211 |
| 告警选举 | AlarmElectionUtil.java | 20-58 |
| 网侧桥接 | ProcessChainServiceImpl.java | 393-497 |

### 8.3 调试技巧

1. **开启DEBUG日志**: 在 `application.yml` 中设置:
   ```yaml
   logging:
     level:
       com.security.processchain: DEBUG
   ```

2. **关键断点位置**:
   - `ProcessChainBuilder.traverseUpward()` 第312行 - 观察向上遍历过程
   - `ProcessChainBuilder.addExploreNodesForBrokenChains()` 第757行 - 观察EXPLORE节点创建
   - `ProcessChainPruner.identifyMustKeepNodes()` 第293行 - 观察裁剪逻辑

3. **日志搜索关键词**:
   - `【进程链生成】->` - 主流程日志
   - `【进程链裁剪】->` - 裁剪相关日志
   - `断链` - 断链检测日志
   - `EXPLORE_ROOT` - EXPLORE节点相关日志

---

## 9. 附录

### 9.1 常量定义

```java
// 最大遍历深度
MAX_TRAVERSE_DEPTH = 50

// 节点数量上限
MAX_NODE_COUNT = 1000

// 有效日志类型
BUILDER_LOG_TYPES = ["process", "file", "network", "domain"]
```

### 9.2 日志级别建议

- **INFO**: 关键流程节点(开始构建、完成构建、节点统计)
- **WARN**: 异常情况但不影响主流程(日志缺失、达到深度限制)
- **ERROR**: 严重错误(参数为空、构建失败)
- **DEBUG**: 详细调试信息(每个节点的处理过程)

### 9.3 性能指标参考

| 场景 | 告警数 | 日志数 | 节点数 | 耗时 |
|------|--------|--------|--------|------|
| 小规模 | 1-5 | <100 | <50 | <100ms |
| 中规模 | 5-20 | 100-500 | 50-200 | 100-500ms |
| 大规模 | 20-50 | 500-2000 | 200-1000 | 500ms-2s |
| 超大规模(裁剪) | >50 | >2000 | 1000(裁剪后) | 2-5s |

---

**文档版本**: v1.0  
**最后更新**: 2025-10-25  
**维护者**: Process Chain Team

---

这份文档涵盖了项目的核心代码实现逻辑，建议配合源码一起阅读。如有疑问，请参考代码注释或联系开发团队。

