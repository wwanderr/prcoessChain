# 进程链合法性检查详解

> **功能**：对合并后的进程链进行合法性检查和修复  
> **工具类**：`ProcessChainValidator`  
> **最后更新**：2025-11-22

---

## 📌 为什么需要合法性检查？

在合并网侧和端侧进程链后，可能出现以下问题：

1. **边指向不存在的节点**：由于数据不一致或异常，边的 source 或 target 可能不在节点列表中
2. **自环边**：节点指向自己，除了特殊场景外应删除
3. **重复边**：相同 source 和 target 的边被添加多次
4. **无效边**：source 或 target 为 null/空字符串
5. **环**：进程链中出现环（虽然在建图阶段已检测，但合并后可能引入新环）

---

## 🔧 核心功能

**自动执行以下检查和修复：**
1. ✅ 删除指向不存在节点的边
2. ✅ 删除自环边
3. ✅ 删除重复边
4. ✅ **自动检测并断开简单环**

---

### 1. 删除指向不存在节点的边 ✅

**检查规则：**
- 边为 null
- source 或 target 为 null/空字符串
- source 或 target 节点不存在于节点列表中

**示例：**
```
边：A → B
节点列表：{A, C, D}  （缺少 B）

结果：删除边 A → B
```

**日志：**
```
【合法性检查-节点不存在】删除边: A → B (target不存在)
```

---

### 2. 删除自环边 ✅

**检查规则：**
- source == target
- 虚拟节点（VIRTUAL_、EXPLORE_）的自环保留，但记录警告

**示例：**
```
边：A → A （自环）

结果：删除边 A → A
```

**特殊场景（保留）：**
```
边：VIRTUAL_ROOT_PARENT_xxx → VIRTUAL_ROOT_PARENT_xxx

结果：保留，但记录警告
```

**日志：**
```
【合法性检查-自环】删除自环边: A → A
【合法性检查-自环】检测到虚拟节点自环（保留）: VIRTUAL_ROOT_PARENT_xxx → VIRTUAL_ROOT_PARENT_xxx
```

---

### 3. 删除重复边 ✅

**检查规则：**
- 相同的 source 和 target
- 保留第一次出现的边，删除后续重复的边

**示例：**
```
边列表：
  1. A → B
  2. A → C
  3. A → B  （重复）
  4. A → B  （重复）

结果：
  1. A → B  （保留）
  2. A → C  （保留）
```

**日志：**
```
【合法性检查-重复边】删除重复边: A → B (已存在)
```

---

### 4. 简单环检测并自动断开 ✅

**检测方法：**
- 检测是否存在双向边：A → B 且 B → A
- **自动断环：根据节点优先级删除一条边**

**示例：**
```
边列表：
  A → B  （A 是告警节点）
  B → A  （双向边，形成环）

结果：保留 A → B（告警节点优先），删除 B → A
```

**断环优先级（优先保留）：**
1. 告警节点作为 source
2. 根节点作为 source
3. 桥接边（网侧 → 端侧）
4. 节点ID较小的边

**日志：**
```
【合法性检查-断环】检测到环: A ⇄ B
【合法性检查-断环】删除边: B → A
【合法性检查-断环】实际删除边: B → A
【合法性检查-断环】✅ 断开简单环，删除边数: 1
```

---

## 🛠️ 使用方法

### 自动验证和修复（推荐）

在 `ProcessChainServiceImpl.mergeNetworkAndEndpointChain()` 中自动调用：

```java
// ========== 8. 合法性检查（新增）==========
// 在计算子节点数量之前进行合法性检查，确保进程链结构正确
ProcessChainValidator.validateAndFix(allNodes, allEdges);
```

**功能：**
- ✅ 自动删除无效边、自环边、重复边
- ✅ **自动检测并断开简单环**

**断环策略：**
对于双向边 A ⇄ B，选择保留哪条边的优先级（从高到低）：

1. **告警节点作为 source**：告警节点 → 其他节点（优先保留）
2. **根节点作为 source**：根节点 → 其他节点
3. **桥接边**：网侧 → 端侧
4. **节点ID较小**：保证确定性

**示例：**
```
场景1：A 是告警节点，B 不是
  A → B  （保留）
  B → A  （删除）

场景2：A 是根节点，B 不是
  A → B  （保留）
  B → A  （删除）

场景3：A 是网侧节点，B 是端侧节点
  A → B  （保留，桥接边）
  B → A  （删除）

场景4：都是普通节点
  A → B  （如果 A < B 则保留）
  B → A  （删除）
```

---

### 手动断环（可选，一般不需要）

如果需要单独调用断环方法（通常不需要，因为 `validateAndFix` 已包含）：

```java
// 手动断开简单环
int removedCount = ProcessChainValidator.breakSimpleCycles(allEdges, allNodes);
log.info("断开环，删除边数: {}", removedCount);
```

---

## 📊 完整流程示例

### 输入（合并后的进程链）

**节点列表：**
```
{A, B, C, D}
```

**边列表（有问题）：**
```
1. A → B
2. A → C
3. B → X  （X 不存在）
4. C → C  （自环）
5. A → B  （重复）
6. D → null （无效边）
7. A → D
8. D → A  （双向边，形成环）
```

---

### 执行合法性检查

```java
ProcessChainValidator.validateAndFix(allNodes, allEdges);
```

---

### 输出（修复后的进程链）

**边列表（修复后）：**
```
1. A → B  （保留）
2. A → C  （保留）
3. A → D  （保留）
```

**删除的边：**
- `B → X`：X 节点不存在
- `C → C`：自环
- `A → B`（第2次）：重复边
- `D → null`：无效边
- `D → A`：环边（假设 A 优先级更高）

**日志输出：**
```
【合法性检查】-> ========================================
【合法性检查】-> 开始检查，节点数: 4, 边数: 8
【合法性检查】-> 有效节点ID数: 4
【合法性检查-节点不存在】删除边: B → X (target不存在)
【合法性检查-无效边】删除空target边: source=D, target=null
【合法性检查】-> ✅ 删除无效边: 2 条
【合法性检查-自环】删除自环边: C → C
【合法性检查】-> ✅ 删除自环边: 1 条
【合法性检查-重复边】删除重复边: A → B (已存在)
【合法性检查】-> ✅ 删除重复边: 1 条
【合法性检查-断环】检测到环: A ⇄ D
【合法性检查-断环】删除边: D → A
【合法性检查-断环】实际删除边: D → A
【合法性检查-断环】✅ 断开简单环，删除边数: 1
【合法性检查】-> ========================================
【合法性检查】-> 检查完成统计：
【合法性检查】->   - 删除无效边（节点不存在）: 2 条
【合法性检查】->   - 删除自环边: 1 条
【合法性检查】->   - 删除重复边: 1 条
【合法性检查】->   - 断开环（删除边）: 1 条
【合法性检查】->   - 总计删除边数: 5 条
【合法性检查】->   - 剩余边数: 3 条
【合法性检查】-> ========================================
```

---

## 🎯 设计理念

### 为什么不使用复杂的 DFS 着色法？

1. **建图阶段已检测**：`ProcessChainGraphBuilder` 已经用 `detectCycles()` 做过完整的环检测
2. **合并不易引入复杂环**：
   - 网侧数据如果有环，应该在网侧处理
   - 桥接边只是连接网侧到端侧根节点，不会引入环
   - 扩展溯源只向上扩展，不会引入环
3. **简单检测足够**：检测双向边（A → B 且 B → A）已经能覆盖大部分实际场景
4. **保守策略**：默认只报告警告，不自动删除，由人工判断更安全

### 为什么采用智能断环策略？

1. **安全可靠**：断环时考虑节点重要性（告警节点、根节点、桥接边优先保留）
2. **自动修复**：环会导致图可视化和分析问题，自动断环可以确保进程链结构正确
3. **确定性**：断环策略有明确的优先级规则，保证结果可预测
4. **可追溯**：详细的日志记录了哪条边被删除以及原因

---

## 📝 API 参考

### `validateAndFix(nodes, edges)`

**功能：** 验证并修复进程链

**参数：**
- `nodes`: `List<ProcessNode>` - 所有节点列表
- `edges`: `List<ProcessEdge>` - 所有边列表（会原地修改）

**返回值：** 无（直接修改 edges 列表）

**示例：**
```java
ProcessChainValidator.validateAndFix(allNodes, allEdges);
```

---

### `breakSimpleCycles(edges, nodes)`

**功能：** 断掉简单环（双向边）

**参数：**
- `edges`: `List<ProcessEdge>` - 边列表（会原地修改）
- `nodes`: `List<ProcessNode>` - 节点列表（用于判断节点重要性）

**返回值：** `int` - 删除的边数量

**示例：**
```java
int removedCount = ProcessChainValidator.breakSimpleCycles(allEdges, allNodes);
log.info("断开环，删除边数: {}", removedCount);
```

---

## 🔗 相关文档

- [代码阅读指南-完整流程详解](./代码阅读指南-完整流程详解.md)
- [扩展溯源逻辑详解](./扩展溯源逻辑详解.md)
- [核心算法详解汇总](./核心算法详解汇总.md)

---

**最后更新**：2025-11-22  
**维护者**：开发团队

