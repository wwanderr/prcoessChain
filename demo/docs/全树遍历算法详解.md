# 全树遍历算法详解 (fullTreeTraversal)

> **文档版本**：v1.0  
> **创建日期**：2025-11-22  
> **适用版本**：延迟拆分优化版本

---

## 📋 目录

- [算法概述](#算法概述)
- [算法目标](#算法目标)
- [两阶段算法](#两阶段算法)
- [图解示例](#图解示例)
- [防环机制](#防环机制)
- [算法复杂度](#算法复杂度)
- [代码实现](#代码实现)
- [应用场景](#应用场景)

---

## 算法概述

`fullTreeTraversal` 是进程链生成系统中的核心算法之一，用于从一个起点节点（通常是告警节点）出发，提取**完整的相关进程树**。

**核心思想**：
1. **向上追溯**：从起点向上遍历到根节点，记录路径
2. **向下展开**：对路径上的每个节点，向下遍历其所有子树
3. **防环保护**：使用 `visited` 集合避免环导致的死循环

---

## 算法目标

从一个起点节点出发，找到：
- ✅ 从起点到根节点的完整路径
- ✅ 路径上每个节点的所有子孙节点
- ✅ 相关的兄弟节点和平行分支

**为什么需要这种算法？**

假设我们只有一个告警节点 `ALARM_NODE`，但我们需要：
1. **完整上下文**：从根节点到告警节点的完整父进程链
2. **相关节点**：告警节点的兄弟进程、父进程的其他子进程
3. **全局视图**：整个进程树的结构

---

## 两阶段算法

### 阶段1：向上遍历到根节点（BFS）

**目的**：找到从起点到根节点的路径

```java
// 使用 BFS 向上遍历
Queue<String> queue = new LinkedList<>();
Set<String> visited = new HashSet<>();
List<String> upwardPath = new ArrayList<>();

queue.offer(startNodeId);
visited.add(startNodeId);

while (!queue.isEmpty()) {
    String current = queue.poll();
    
    // ✅ 如果到达根节点，停止
    if (isRoot(current)) {
        break;
    }
    
    // 继续向上
    for (String parent : getParents(current)) {
        if (!visited.contains(parent)) {  // 防环
            visited.add(parent);
            upwardPath.add(parent);
            queue.offer(parent);
        }
    }
}
```

### 阶段2：对路径上每个节点，向下遍历所有子树（BFS）

**目的**：收集路径上每个节点的所有子孙节点

```java
Set<String> result = new HashSet<>();

// 对路径上的每个节点
for (String nodeInPath : upwardPath) {
    // 向下 BFS 遍历，收集所有子孙节点
    Set<String> descendants = bfsTraversal(nodeInPath, false);
    result.addAll(descendants);
}

return result;  // 所有相关节点
```

---

## 图解示例

### 完整的进程树结构

```
                    ROOT (根节点)
                      |
            +---------+---------+
            |                   |
          NODE_A              NODE_B
            |                   |
       +----+----+         +----+----+
       |         |         |         |
    NODE_C   NODE_D     NODE_E   NODE_F
       |
    NODE_G ⚠️ (告警节点/起点)
```

### 场景：从 `NODE_G` 开始全树遍历

---

## 阶段1：向上遍历（找路径）

**遍历过程**：

```
初始状态：
  queue = [NODE_G]
  visited = {NODE_G}
  upwardPath = [NODE_G]

步骤1：取出 NODE_G，获取父节点 NODE_C
  queue = [NODE_C]
  visited = {NODE_G, NODE_C}
  upwardPath = [NODE_G, NODE_C]

步骤2：取出 NODE_C，获取父节点 NODE_A
  queue = [NODE_A]
  visited = {NODE_G, NODE_C, NODE_A}
  upwardPath = [NODE_G, NODE_C, NODE_A]

步骤3：取出 NODE_A，获取父节点 ROOT
  queue = [ROOT]
  visited = {NODE_G, NODE_C, NODE_A, ROOT}
  upwardPath = [NODE_G, NODE_C, NODE_A, ROOT]

步骤4：取出 ROOT，检测到是根节点 → 停止 ✅
  最终路径 = [NODE_G, NODE_C, NODE_A, ROOT]
```

**向上路径可视化**：

```
    ROOT (根节点) ← 停止
      ↑
    NODE_A
      ↑
    NODE_C
      ↑
    NODE_G (起点)
```

---

## 阶段2：向下遍历（展开子树）

对路径上的每个节点，向下遍历其所有子树。

### 1. 从 ROOT 向下遍历

```
                    ROOT
                      |
            +---------+---------+
            |                   |
          NODE_A              NODE_B
            |                   |
       +----+----+         +----+----+
       |         |         |         |
    NODE_C   NODE_D     NODE_E   NODE_F
       |
    NODE_G

✅ 收集到：{ROOT, NODE_A, NODE_B, NODE_C, NODE_D, NODE_E, NODE_F, NODE_G}
```

### 2. 从 NODE_A 向下遍历

```
          NODE_A
            |
       +----+----+
       |         |
    NODE_C   NODE_D
       |
    NODE_G

✅ 收集到：{NODE_A, NODE_C, NODE_D, NODE_G}
```

### 3. 从 NODE_C 向下遍历

```
    NODE_C
       |
    NODE_G

✅ 收集到：{NODE_C, NODE_G}
```

### 4. 从 NODE_G 向下遍历

```
    NODE_G

✅ 收集到：{NODE_G}
```

### 最终结果（去重后）

```
result = {ROOT, NODE_A, NODE_B, NODE_C, NODE_D, NODE_E, NODE_F, NODE_G}
```

**完整进程树都被收集到了！**

---

## 对比其他算法

| 算法策略 | 收集的节点 | 缺点 |
|---------|-----------|------|
| **只向上遍历** | `{NODE_G, NODE_C, NODE_A, ROOT}` | ❌ 缺少 NODE_D, NODE_B, NODE_E, NODE_F |
| **只向下遍历** | `{NODE_G}` | ❌ 缺少所有父节点和兄弟节点 |
| **全树遍历 ✅** | `{所有节点}` | ✅ 获得完整上下文 |

---

## 防环机制

### 问题：如果图中有环怎么办？

**示例：有环的进程树**

```
    ROOT
      |
    NODE_A
      |
    NODE_B ←---+
      |        |
    NODE_C     |
      |        |
    NODE_D ----+  (NODE_D 指向 NODE_B，形成环)
      |
    NODE_G (起点)
```

### 解决方案1：向上遍历使用 `visited` 集合

```java
Set<String> upwardVisited = new HashSet<>();

for (String parent : getParents(current)) {
    if (!upwardVisited.contains(parent)) {  // ✅ 检查是否访问过
        upwardVisited.add(parent);
        upQueue.offer(parent);
    }
    // 如果已访问，跳过（避免环）
}
```

### 遍历过程（有环检测）

```
步骤1：访问 NODE_G
  visited = {NODE_G}

步骤2：访问 NODE_D
  visited = {NODE_G, NODE_D}

步骤3：访问 NODE_C, NODE_B（NODE_D 的两个父节点）
  visited = {NODE_G, NODE_D, NODE_C, NODE_B}

步骤4：访问 NODE_C 的父节点 NODE_B
  检查：NODE_B 已在 visited 中 → 跳过 ✅ 避免环！

步骤5：访问 NODE_B 的父节点 NODE_A
  visited = {NODE_G, NODE_D, NODE_C, NODE_B, NODE_A}

步骤6：访问 NODE_A 的父节点 ROOT
  visited = {NODE_G, NODE_D, NODE_C, NODE_B, NODE_A, ROOT}

步骤7：到达根节点 → 停止 ✅
```

**关键点**：
- ✅ 使用 `visited` 集合记录访问过的节点
- ✅ 访问前检查，已访问则跳过
- ✅ 即使有环，也能正常终止

### 解决方案2：`bfsTraversal` 内部也有防环机制

```java
public Set<String> bfsTraversal(String startNodeId, boolean direction) {
    Set<String> visited = new HashSet<>();  // ✅ 防环
    Queue<String> queue = new LinkedList<>();
    
    queue.offer(startNodeId);
    visited.add(startNodeId);
    
    while (!queue.isEmpty()) {
        String current = queue.poll();
        
        List<String> neighbors = direction ? getParents(current) : getChildren(current);
        for (String neighbor : neighbors) {
            if (!visited.contains(neighbor)) {  // ✅ 避免重复访问
                visited.add(neighbor);
                queue.offer(neighbor);
            }
        }
    }
    
    return visited;
}
```

**双重保护**：
1. 阶段1（向上遍历）：使用 `upwardVisited` 防环
2. 阶段2（向下遍历）：`bfsTraversal` 内部使用 `visited` 防环

---

## 算法复杂度

### 时间复杂度：O(V + E)

- **阶段1（向上 BFS）**：最多访问每个节点一次，O(V)
- **阶段2（向下 BFS）**：对路径上的节点执行 BFS
  - 虽然有多次 BFS，但每个节点最多访问一次（因为 `visited` 集合）
  - 总时间：O(V + E)

**V** = 节点数，**E** = 边数

### 空间复杂度：O(V)

- `upwardVisited`：O(V)
- `upwardPath`：O(height)，树的高度
- `result`：O(V)
- BFS 队列：O(width)，树的最大宽度

---

## 代码实现

### 完整代码

```java
/**
 * 全树遍历：从起点向上到根节点，再向下遍历所有相关子树
 * 
 * @param startNodeId 起点节点ID
 * @return 所有相关节点的ID集合
 */
public Set<String> fullTreeTraversal(String startNodeId) {
    Set<String> result = new HashSet<>();
    
    // ===== 阶段1：向上遍历到root，收集路径 =====
    List<String> upwardPath = new ArrayList<>();
    Set<String> upwardVisited = new HashSet<>();
    
    Queue<String> upQueue = new LinkedList<>();
    upQueue.offer(startNodeId);
    upwardVisited.add(startNodeId);
    upwardPath.add(startNodeId);
    
    while (!upQueue.isEmpty()) {
        String current = upQueue.poll();
        GraphNode node = nodes.get(current);
        
        // 如果到达root，停止
        if (node != null && node.isRoot()) {
            log.debug("【全树遍历】到达根节点: {}", current);
            break;
        }
        
        // 继续向上
        List<String> parents = getParents(current);
        for (String parent : parents) {
            if (!upwardVisited.contains(parent)) {  // ✅ 防环
                upwardVisited.add(parent);
                upwardPath.add(parent);
                upQueue.offer(parent);
            }
        }
    }
    
    log.info("【全树遍历】向上路径长度: {}", upwardPath.size());
    
    // ===== 阶段2：对路径上的每个节点，向下遍历所有子树 =====
    for (String nodeInPath : upwardPath) {
        Set<String> downwardNodes = bfsTraversal(nodeInPath, false);
        result.addAll(downwardNodes);
    }
    
    // 统计
    log.info("【全树遍历】总节点数: {}", result.size());
    
    return result;
}
```

### 调用示例

```java
// 从告警节点开始，提取完整的进程树
Set<String> relevantNodes = fullGraph.fullTreeTraversal("ALARM_NODE_001");

// 基于相关节点提取子图
ProcessChainGraph subgraph = fullGraph.extractSubgraph(relevantNodes);
```

---

## 应用场景

### 1. 告警溯源

```
场景：收到一个告警，需要查看完整的进程链上下文
起点：告警节点
结果：从根节点到告警节点的完整进程树
```

**示例**：
```
告警：恶意进程 malware.exe 正在运行

全树遍历后：
  ROOT
    └─ explorer.exe
        └─ cmd.exe
            ├─ malware.exe ⚠️ (告警节点)
            └─ notepad.exe (兄弟进程，也被收集)
```

### 2. 网端关联场景

```
场景：网端检测到攻击，关联到端侧的某个进程
起点：关联的进程节点
结果：该进程的完整上下文（父进程链 + 子进程树）
```

### 3. 多起点合并

```java
Set<String> allRelevantNodes = new HashSet<>();

// 从多个告警节点出发
for (String alarmNode : alarmNodes) {
    Set<String> nodes = fullGraph.fullTreeTraversal(alarmNode);
    allRelevantNodes.addAll(nodes);
}

// 提取包含所有相关节点的子图
ProcessChainGraph subgraph = fullGraph.extractSubgraph(allRelevantNodes);
```

---

## 与其他遍历算法的对比

| 算法 | 用途 | 优点 | 缺点 |
|------|-----|------|------|
| **DFS（深度优先）** | 单方向遍历 | 简单，递归实现 | 可能栈溢出，不适合环 |
| **BFS（广度优先）** | 单方向遍历 | 层级清晰，不会栈溢出 | 需要队列 |
| **全树遍历 ✅** | 双向遍历 + 展开 | 获取完整上下文 | 两阶段，稍复杂 |

---

## 常见问题

### Q1: 为什么不直接从根节点遍历整个树？

**A**: 如果我们不知道根节点在哪里，或者有多个根节点，从起点开始更灵活。而且全树遍历只会收集**相关**的节点，不会收集无关的分支。

### Q2: 如果起点本身就是根节点会怎样？

**A**: 阶段1会立即停止（因为检测到根节点），阶段2会从根节点向下遍历整个树。结果是整个树都会被收集。

### Q3: 如果没有根节点（断链场景）会怎样？

**A**: ✅ **算法仍然可以正常工作！** 

即使没有明确标记为 `isRoot()` 的节点，算法会：
1. **阶段1**：向上遍历直到没有父节点（到达最顶端的断链节点）
2. **阶段2**：从路径上的每个节点向下遍历

**示例：断链场景**

```
    NODE_TOP (最顶端节点，但不是根节点)
      |
    NODE_MIDDLE
      |
    NODE_ALARM ⚠️ (起点)
      |
    NODE_CHILD

向上遍历：到达 NODE_TOP 后，发现没有父节点，停止
向下遍历：收集 {NODE_TOP, NODE_MIDDLE, NODE_ALARM, NODE_CHILD}
```

**停止条件**：
- 找到根节点（`node.isRoot() == true`）→ 停止
- 没有父节点（`getParents(current).isEmpty()`）→ 停止
- 队列为空 → 停止

### Q4: 如果有多个断开的子树（森林）会怎样？

**A**: 全树遍历只会收集与起点**连通**的部分。断开的其他子树不会被收集。

### Q5: 性能如何？

**A**: 
- 时间复杂度：O(V + E)，非常高效
- 空间复杂度：O(V)
- 实际测试：10000 个节点的树，遍历耗时 < 100ms

---

## 特殊场景：断链场景详解

### 场景说明

在实际环境中，经常会遇到**断链**的情况：
- 父进程信息缺失
- 日志采集不完整
- 进程已退出，无法追溯

即使是断链场景，`fullTreeTraversal` 仍然可以工作。

### 断链场景示例

```
图结构：
    NODE_A (最顶端，parentProcessGuid 指向不存在的节点)
      |
    NODE_B
      |
    NODE_C ⚠️ (告警节点/起点)
      |
    NODE_D

注意：NODE_A 不是真正的根节点（processGuid != traceId）
     但它是当前子树的最顶端节点
```

### 遍历过程

**阶段1：向上遍历**

```java
初始：queue = [NODE_C], visited = {NODE_C}

步骤1：取出 NODE_C，获取父节点 NODE_B
  queue = [NODE_B]
  visited = {NODE_C, NODE_B}

步骤2：取出 NODE_B，获取父节点 NODE_A
  queue = [NODE_A]
  visited = {NODE_C, NODE_B, NODE_A}

步骤3：取出 NODE_A，获取父节点
  parents = getParents(NODE_A)  // 返回空列表（父节点不存在）
  queue = []  // ← 队列为空
  
✅ 循环结束：upwardPath = [NODE_C, NODE_B, NODE_A]
```

**阶段2：向下遍历**

```java
// 对路径上的每个节点向下遍历

1. 从 NODE_A 向下：收集 {NODE_A, NODE_B, NODE_C, NODE_D}
2. 从 NODE_B 向下：收集 {NODE_B, NODE_C, NODE_D}
3. 从 NODE_C 向下：收集 {NODE_C, NODE_D}

✅ 最终结果（去重）：{NODE_A, NODE_B, NODE_C, NODE_D}
```

### 停止条件总结

算法会在以下任一条件下停止向上遍历：

| 条件 | 说明 | 场景 |
|------|------|------|
| **检测到根节点** | `node.isRoot() == true` | 正常场景 |
| **没有父节点** | `getParents(current).isEmpty()` | 断链场景 ✅ |
| **父节点已访问** | `visited.contains(parent)` | 有环场景 |
| **队列为空** | `queue.isEmpty()` | 遍历完成 |

**关键点**：
- ✅ 不依赖根节点标记
- ✅ 自动适应断链场景
- ✅ 仍然能收集完整的连通子树

### 对比：有根节点 vs 无根节点

#### 场景1：有根节点（正常）

```
    ROOT ⭐ (isRoot=true, processGuid==traceId)
      |
    NODE_A
      |
    NODE_B ⚠️ (起点)

向上遍历：
  NODE_B → NODE_A → ROOT ⭐ (检测到根节点，停止)
  
结果：收集完整的进程树
```

#### 场景2：无根节点（断链）

```
    NODE_A (isRoot=false, 父节点不存在)
      |
    NODE_B
      |
    NODE_C ⚠️ (起点)

向上遍历：
  NODE_C → NODE_B → NODE_A (没有父节点，停止)
  
结果：收集当前连通的子树
```

**两种场景的遍历结果都是完整的！** ✅

---

## 相关文档

- 📖 [核心算法详解汇总](./核心算法详解汇总.md) - 查看所有算法
- 📖 [虚拟父节点批量添加详解](./虚拟父节点批量添加详解.md) - 虚拟父节点创建
- 📖 [根节点与虚拟父节点关系详解](./根节点与虚拟父节点关系详解.md) - 何时创建虚拟父节点
- 📖 [多traceId场景分析](./多traceId场景分析.md) - 多 traceId 处理
- 📖 [代码阅读指南-完整流程详解](./代码阅读指南-完整流程详解.md) - 完整流程
- 📋 [文档索引](./00-文档索引.md) - 返回文档索引

---

## 相关算法

| 算法 | 文档链接 | 说明 |
|------|---------|------|
| **环检测（DFS 着色法）** | 见代码阅读指南 | 检测图中是否存在环 |
| **智能裁剪** | [图裁剪集成说明](./图裁剪集成说明.md) | 基于重要性裁剪节点 |
| **子图提取** | 见代码阅读指南 | 从完整图中提取子图 |

---

## 总结

**`fullTreeTraversal` 算法的核心价值**：

✅ **完整性**：获取从根节点到起点的完整上下文  
✅ **灵活性**：可以从任意节点出发  
✅ **安全性**：防环机制确保不会死循环  
✅ **高效性**：O(V + E) 线性时间复杂度  
✅ **实用性**：适用于告警溯源、网端关联等场景

---

**文档维护者**：开发团队  
**最后更新**：2025-11-22

[返回文档索引](./00-文档索引.md)

