# 建图方案 - 关键映射同步修复

## 问题描述

在新的建图方案（ProcessChainGraph）中，关键映射信息在 `ProcessChainGraph` 和 `ProcessChainResult` 中构建，但**没有同步到 `ProcessChainBuilder` 的实例变量**，导致外部通过 `builder.getTraceIdToRootNodeMap()` 无法获取正确的映射。

### 症状

```java
ProcessChainBuilder builder = new ProcessChainBuilder();
IncidentProcessChain endpointChain = builder.buildIncidentChain(...);

// ❌ 问题：这里返回空映射
Map<String, String> traceIdToRootNodeMap = builder.getTraceIdToRootNodeMap();
System.out.println(traceIdToRootNodeMap.size());  // 输出: 0
```

但是在 `buildIncidentChain` 内部，`result.getTraceIdToRootNodeMap()` 是有值的。

---

## 根本原因

### 数据流

```
1. ProcessChainGraph.identifyRootNodes()
   → 在图中构建 traceIdToRootNodeMap
   
2. ProcessChainBuilder.convertGraphToResult()
   → 将图中的映射复制到 result
   → result.setTraceIdToRootNodeMap(graph.getTraceIdToRootNodeMap())
   
3. ProcessChainBuilder.buildProcessChain()
   → 返回 result
   → ❌ 但没有同步到 this.traceIdToRootNodeMap

4. ProcessChainBuilder.buildIncidentChain()
   → 调用 buildProcessChain()
   → ❌ this.traceIdToRootNodeMap 仍然为空
   → 外部调用 getTraceIdToRootNodeMap() 返回空映射
```

### 问题本质

在旧的实现中，`traceIdToRootNodeMap` 是在 `buildBidirectionalChain()` 和 `buildUpwardChain()` 中直接写入 `this.traceIdToRootNodeMap` 的：

```java
// 旧实现（直接写入实例变量）
this.traceIdToRootNodeMap.put(alarm.getTraceId(), processGuid);
```

在新的建图方案中，映射是在 `ProcessChainGraph` 中构建的，需要**显式同步**回 `ProcessChainBuilder`：

```java
// 新实现（需要显式同步）
this.traceIdToRootNodeMap = result.getTraceIdToRootNodeMap();
```

---

## 解决方案

### 修复1：buildProcessChain() 末尾同步

**位置**：`ProcessChainBuilder.java` 第237-251行

```java
// ===== 阶段7：转换为输出格式 =====
ProcessChainResult result = convertGraphToResult(subgraph, traceIds);

// ✅ 关键修复：将图中的关键映射同步到 ProcessChainBuilder 的实例变量
// 这样外部可以通过 getter 方法获取这些映射
this.traceIdToRootNodeMap = result.getTraceIdToRootNodeMap();
this.brokenNodeToTraceId = result.getBrokenNodeToTraceId();
this.rootNodes = result.getRootNodes();
this.brokenNodes = result.getBrokenNodes();

log.info("进程链构建完成: 节点数={}, 边数={}, 根节点数={}, 断裂节点数={}", 
        result.getNodes().size(), result.getEdges().size(), 
        result.getRootNodes().size(), result.getBrokenNodes().size());

log.info("关键映射同步完成: traceIdToRootNodeMap={}, brokenNodeToTraceId={}, rootNodes={}, brokenNodes={}", 
        this.traceIdToRootNodeMap.size(), this.brokenNodeToTraceId.size(), 
        this.rootNodes.size(), this.brokenNodes.size());

return result;
```

### 修复2：buildIncidentChain() 开始时确认同步

**位置**：`ProcessChainBuilder.java` 第1240-1250行

```java
// 构建内部结果
ProcessChainResult result = buildProcessChain(alarms, logs, traceIds, associatedEventIds, startLogEventIds);

// ✅ 同步 traceIdToRootNodeMap（确保在没有断链节点时也能获取）
// buildProcessChain 内部已经同步过，这里再次确认
if (this.traceIdToRootNodeMap == null || this.traceIdToRootNodeMap.isEmpty()) {
    this.traceIdToRootNodeMap = result.getTraceIdToRootNodeMap();
    log.info("【进程链生成】-> 从 result 同步 traceIdToRootNodeMap: {}", this.traceIdToRootNodeMap);
}

// 转换为最终的 IncidentProcessChain
IncidentProcessChain incidentChain = new IncidentProcessChain();
```

### 修复3：addExploreNodesForBrokenChains() 后更新同步

**位置**：`ProcessChainBuilder.java` 第1295-1305行

```java
// 添加 Explore 节点（如果有断链）
if (result.getBrokenNodes() != null && !result.getBrokenNodes().isEmpty()) {
    addExploreNodesForBrokenChains(finalNodes, finalEdges, 
            result.getBrokenNodes(), result.getRootNodes(), 
            traceIds, result.getTraceIdToRootNodeMap(), 
            result.getBrokenNodeToTraceId());
    
    // ✅ 关键修复：将更新后的映射同步回 ProcessChainBuilder 的成员变量
    // 因为 addExploreNodesForBrokenChains() 会更新 result 中的 traceIdToRootNodeMap
    this.traceIdToRootNodeMap = result.getTraceIdToRootNodeMap();
    this.brokenNodeToTraceId = result.getBrokenNodeToTraceId();
    
    log.info("【进程链生成】-> Explore节点添加后，映射更新: traceIdToRootNodeMap={}", 
            this.traceIdToRootNodeMap);
}
```

---

## 同步的关键信息

| 信息 | 类型 | 用途 | 同步位置 |
|-----|------|------|---------|
| **traceIdToRootNodeMap** | `Map<String, String>` | 网端桥接（victim → 端侧根节点） | ✅ 3处 |
| **brokenNodeToTraceId** | `Map<String, String>` | 断链节点到traceId映射 | ✅ 2处 |
| **rootNodes** | `Set<String>` | 根节点集合 | ✅ 1处 |
| **brokenNodes** | `Set<String>` | 断链节点集合 | ✅ 1处 |

### traceIdToRootNodeMap 的三次同步

1. **buildProcessChain() 末尾**（第242行）
   - 从 `ProcessChainGraph` 同步基础映射
   - 包含真实根节点的映射

2. **buildIncidentChain() 开始**（第1241-1248行）
   - 确认性同步（兜底）
   - 防止 buildProcessChain 同步失败

3. **addExploreNodesForBrokenChains() 后**（第1300-1301行）
   - 更新性同步
   - 包含新增的 EXPLORE 虚拟根节点映射

### 为什么需要三次同步？

```
场景1：有真实根节点，无断链
  → buildProcessChain() 同步 {E3E5C129C46B2111 -> E3E5C129C46B2111}
  → buildIncidentChain() 确认同步（已有值，跳过）
  → 无断链节点，不执行第3次同步
  ✅ 最终：{E3E5C129C46B2111 -> E3E5C129C46B2111}

场景2：无真实根节点，有断链
  → buildProcessChain() 同步 {}（空映射）
  → buildIncidentChain() 确认同步（空，但标记为已同步）
  → addExploreNodesForBrokenChains() 更新映射，添加 {traceId -> EXPLORE_ROOT_traceId}
  → 第3次同步更新实例变量
  ✅ 最终：{traceId -> EXPLORE_ROOT_traceId}

场景3：既有真实根节点，又有断链（多traceId场景）
  → buildProcessChain() 同步 {traceId1 -> rootNode1}
  → buildIncidentChain() 确认同步（已有值，跳过）
  → addExploreNodesForBrokenChains() 添加 {traceId2 -> EXPLORE_ROOT_traceId2}
  → 第3次同步更新实例变量
  ✅ 最终：{traceId1 -> rootNode1, traceId2 -> EXPLORE_ROOT_traceId2}
```

---

## 验证方法

### 1. 日志验证

查看构建日志，确认映射已同步：

```
【建图完成】节点数=10, 根节点=1, 断链节点=0
【子图提取】相关节点总数=10
【实体过滤完成】节点数=8
进程链构建完成: 节点数=8, 边数=7, 根节点数=1, 断裂节点数=0
关键映射同步完成: traceIdToRootNodeMap=1, brokenNodeToTraceId=0, rootNodes=1, brokenNodes=0  ← ✅
【进程链生成】-> 从 result 同步 traceIdToRootNodeMap: {E3E5C129C46B2111=E3E5C129C46B2111}  ← ✅
```

### 2. 代码验证

```java
ProcessChainBuilder builder = new ProcessChainBuilder();
IncidentProcessChain endpointChain = builder.buildIncidentChain(
    alarms, logs, traceIds, associatedEventIds, startLogEventIds,
    nodeMapper, edgeMapper
);

// ✅ 现在可以正确获取映射
Map<String, String> traceIdToRootNodeMap = builder.getTraceIdToRootNodeMap();
System.out.println("映射数量: " + traceIdToRootNodeMap.size());  // 应该 > 0
System.out.println("映射内容: " + traceIdToRootNodeMap);
// 输出示例: {E3E5C129C46B2111=E3E5C129C46B2111}
```

### 3. 桥接边验证

```java
// 在 ProcessChainServiceImpl 中
Map<String, String> traceIdToRootNodeMap = builder.getTraceIdToRootNodeMap();

if (traceIdToRootNodeMap != null && !traceIdToRootNodeMap.isEmpty()) {
    log.info("【进程链生成】-> traceId到根节点映射数: {}", traceIdToRootNodeMap.size());
    log.info("【进程链生成】-> traceId映射详情: {}", traceIdToRootNodeMap);
    
    // ✅ 现在可以正确创建桥接边
    BridgeResult bridgeResult = createBridgeEdges(
        networkNodes, networkEdges, hostToTraceId, traceIdToRootNodeMap
    );
}
```

---

## 影响范围

### ✅ 已修复的问题

1. **网端桥接失败**
   - 症状：victim节点无法连接到端侧根节点
   - 原因：`traceIdToRootNodeMap` 为空
   - 修复：正确同步映射

2. **EXPLORE 节点映射丢失**
   - 症状：断链节点创建了 EXPLORE 节点，但映射没有返回
   - 原因：`addExploreNodesForBrokenChains()` 更新了映射，但没有同步
   - 修复：在 Explore 节点添加后同步

3. **多 traceId 场景不完整**
   - 症状：只能看到部分 traceId 的根节点映射
   - 原因：映射没有完整同步
   - 修复：三次同步确保完整性

### ⚠️ 无影响的场景

- **端侧进程链构建**：内部使用 `result` 对象，不受影响
- **节点和边的生成**：正常工作
- **实体过滤和裁剪**：正常工作

---

## 测试建议

### 单元测试

```java
@Test
public void testTraceIdToRootNodeMapSync() {
    // 准备数据
    List<RawAlarm> alarms = createTestAlarms();
    List<RawLog> logs = createTestLogs();
    Set<String> traceIds = Set.of("E3E5C129C46B2111");
    
    // 构建进程链
    ProcessChainBuilder builder = new ProcessChainBuilder();
    IncidentProcessChain result = builder.buildIncidentChain(
        alarms, logs, traceIds, null, null,
        IncidentConverters.NODE_MAPPER, IncidentConverters.EDGE_MAPPER
    );
    
    // 验证：映射已正确同步
    Map<String, String> mapping = builder.getTraceIdToRootNodeMap();
    
    assertNotNull("映射不应为null", mapping);
    assertFalse("映射不应为空", mapping.isEmpty());
    assertTrue("应包含traceId映射", mapping.containsKey("E3E5C129C46B2111"));
    assertEquals("映射值应正确", "E3E5C129C46B2111", mapping.get("E3E5C129C46B2111"));
}
```

### 集成测试

```java
@Test
public void testNetworkEndpointBridging() {
    // 准备网侧和端侧数据
    IpMappingRelation relation = createTestRelation();
    
    // 执行网端合并
    IncidentProcessChain result = service.buildProcessChain(relation);
    
    // 验证：桥接边已创建
    List<ProcessEdge> bridgeEdges = result.getEdges().stream()
        .filter(edge -> "桥接".equals(edge.getVal()))
        .collect(Collectors.toList());
    
    assertFalse("应该有桥接边", bridgeEdges.isEmpty());
    
    // 验证：victim 节点连接到端侧根节点
    for (ProcessEdge edge : bridgeEdges) {
        assertTrue("target 应该是根节点", 
            result.getNodes().stream()
                .anyMatch(node -> node.getNodeId().equals(edge.getTarget()) 
                    && Boolean.TRUE.equals(node.getChainNode().getIsRoot())));
    }
}
```

---

## 总结

### 修复内容

1. ✅ 在 `buildProcessChain()` 末尾同步 4 个关键映射
2. ✅ 在 `buildIncidentChain()` 开始时确认同步（兜底）
3. ✅ 在 `addExploreNodesForBrokenChains()` 后更新同步

### 核心变更

- `ProcessChainBuilder.java`：+27行，3个位置修改
- 新增详细日志输出，便于排查问题
- 无破坏性变更，向后兼容

### 预期效果

- ✅ `builder.getTraceIdToRootNodeMap()` 返回正确的映射
- ✅ 网端桥接边正常创建
- ✅ EXPLORE 节点映射完整
- ✅ 多 traceId 场景完全支持

---

**修复时间**：2025-05-26
**修复文件**：`ProcessChainBuilder.java`
**测试状态**：✅ 无编译错误，待集成测试验证


