# 进程链系统 - 核心算法详解汇总

> **本文档汇总了所有核心算法的详细图解和实现原理**  
> 最后更新：2025-11-22

---

## 📚 算法列表

本系统包含多个核心算法，每个算法都有详细的图解文档。以下是完整的算法列表和快速导航：

---

## 1. 全树遍历算法 ⭐⭐⭐⭐⭐

**算法名称**：`fullTreeTraversal`

**功能**：从任意节点出发，收集整个连通子树的所有节点

**详细文档**：[全树遍历算法详解](./全树遍历算法详解.md)

### 核心特点

- ✅ 两阶段遍历（向上到根 + 向下到叶）
- ✅ 防环机制（`visited` 集合）
- ✅ 支持断链场景（没有根节点也能工作）
- ✅ 包含所有分支（兄弟节点、侄节点等）

### 适用场景

```
场景1：有根节点
    ROOT
      |
    NODE_A
      |
    NODE_B ⚠️ (起点)
      |
    NODE_C

结果：收集 {ROOT, NODE_A, NODE_B, NODE_C}

场景2：断链（无根节点）
    NODE_A (最顶端)
      |
    NODE_B ⚠️ (起点)
      |
    NODE_C

结果：收集 {NODE_A, NODE_B, NODE_C}
```

### 关键代码

```java
Set<String> connectedNodes = fullGraph.fullTreeTraversal(startNode);
```

---

## 2. 虚拟父节点批量添加算法 ⭐⭐⭐⭐⭐

**算法名称**：`createVirtualParentsForSubgraph`

**功能**：为缺失父节点的节点批量创建虚拟父节点，并建立边关系

**详细文档**：[虚拟父节点批量添加详解](./虚拟父节点批量添加详解.md)

### 核心特点

- ✅ 两阶段处理（收集 + 批量添加）
- ✅ 避免重复创建（多个子节点共享一个虚拟父节点）
- ✅ 支持普通节点和特殊根节点
- ✅ 从日志或告警中提取父进程信息

### 适用场景

```
场景1：普通节点缺失父节点
    NODE_A (parentGuid = PARENT_X, 但 PARENT_X 不存在)
      |
    NODE_B

操作：创建虚拟父节点 PARENT_X

结果：
    PARENT_X ⭐ (虚拟父节点)
      |
    NODE_A
      |
    NODE_B

场景2：多个子节点共享一个虚拟父节点
    NODE_A (parentGuid = PARENT_SHARED)
    NODE_B (parentGuid = PARENT_SHARED)
    NODE_C (parentGuid = PARENT_SHARED)

操作：只创建一个 PARENT_SHARED

结果：
    PARENT_SHARED ⭐ (虚拟父节点)
       ├─→ NODE_A
       ├─→ NODE_B
       └─→ NODE_C
```

### 关键代码

```java
createVirtualParentsForSubgraph(subgraph, traceIds);
```

---

## 3. 多 traceId 场景处理 ⭐⭐⭐⭐⭐

**功能**：处理多个 traceId 场景下的子图提取和网端桥接

**详细文档**：[多traceId场景分析](./多traceId场景分析.md)

### 核心特点

- ✅ 确保每个 traceId 的子图都被提取
- ✅ 支持部分 traceId 有网端关联的场景
- ✅ 自动补充未覆盖的 traceId 的起点
- ✅ 保证网端桥接能找到所有根节点

### 适用场景

```
场景：多个 traceId，部分有网端关联

数据：
  Tree 1 (traceId_1): 告警1 ✅ 有网端关联
  Tree 2 (traceId_2): 告警2 ✅ 有网端关联
  Tree 3 (traceId_3): 告警3 ❌ 无网端关联

问题：如果只使用网端关联的告警作为起点，Tree 3 会被遗漏

解决：
  步骤1：添加网端关联的告警（告警1, 告警2）
  步骤2：补充未覆盖的 traceId（告警3）
  
结果：所有三棵树都被提取 ✅
```

### 关键代码

```java
// 步骤1：添加网端关联的告警
for (RawAlarm alarm : alarms) {
    if (associatedEventIds.contains(alarm.getEventId())) {
        startNodes.add(alarm.getProcessGuid());
        coveredTraceIds.add(alarm.getTraceId());
    }
}

// 步骤2：补充未覆盖的 traceId
Set<String> uncoveredTraceIds = new HashSet<>(traceIds);
uncoveredTraceIds.removeAll(coveredTraceIds);

for (String uncoveredTraceId : uncoveredTraceIds) {
    // 为每个未覆盖的 traceId 找一个告警作为起点
    ...
}
```

---

## 4. DFS 环检测算法（着色法）⭐⭐⭐⭐☆

**算法名称**：`detectCycles` + `detectCyclesDFS`

**功能**：使用 DFS 着色法检测图中的环

**详细文档**：[代码阅读指南-完整流程详解](./代码阅读指南-完整流程详解.md) → 阶段2 → 环检测

### 核心特点

- ✅ 三色标记（WHITE, GRAY, BLACK）
- ✅ DFS 遍历
- ✅ 检测所有环（包括自环）
- ✅ 记录环路径

### 算法原理

```
节点状态：
  - WHITE (0): 未访问
  - GRAY (1):  正在访问（在当前 DFS 路径中）
  - BLACK (2): 已完成访问

环检测规则：
  如果访问到一个 GRAY 节点 → 发现环 ✅
```

### 示例

```
图结构：
    A → B → C → D
        ↑       ↓
        └───────┘

DFS 遍历：
  访问 A (WHITE → GRAY)
  访问 B (WHITE → GRAY)
  访问 C (WHITE → GRAY)
  访问 D (WHITE → GRAY)
  访问 B (GRAY!) → 发现环：B → C → D → B ✅
```

### 关键代码

```java
List<List<String>> cycles = subgraph.detectCycles();
```

---

## 5. 图裁剪算法（智能裁剪）⭐⭐⭐⭐☆

**算法名称**：`pruneGraph` + `ProcessChainPruner.pruneNodes`

**功能**：根据节点重要性智能裁剪图，保留关键节点和路径

**详细文档**：[图裁剪集成说明](./图裁剪集成说明.md)

### 核心特点

- ✅ 强制保留：根节点、告警节点、网端关联节点
- ✅ 级联保留：从关键节点到根节点的完整路径
- ✅ 选择性保留：按重要性选择其他节点
- ✅ 保证进程链完整性

### 裁剪策略

```
裁剪前（假设超过节点数限制）：
    ROOT
      |
    NODE_A
      |
    NODE_B (告警节点) ⚠️
      |
    NODE_C
      |
    NODE_D

裁剪后：
    ROOT ✅ (强制保留：根节点)
      |
    NODE_A ✅ (级联保留：到根节点的路径)
      |
    NODE_B ✅ (强制保留：告警节点)
      |
    NODE_C ❌ (裁剪：非关键节点)
```

### 关键代码

```java
if (subgraph.getNodeCount() > MAX_NODE_COUNT) {
    pruneGraph(subgraph);
}
```

---

## 6. 实体提取算法 ⭐⭐⭐⭐☆

**算法名称**：`EntityExtractor.extractEntitiesFromGraph`

**功能**：从进程节点中提取文件、域名、网络、注册表等实体节点

**详细文档**：[代码阅读指南-完整流程详解](./代码阅读指南-完整流程详解.md) → 阶段6

### 核心特点

- ✅ 支持多种实体类型（file, domain, network, registry）
- ✅ 优先使用日志，日志不存在时使用告警
- ✅ 建立"父进程 → 子进程 → 实体"的三层结构
- ✅ 去重和合并

### 实体类型判断

```
日志类型：
  - logType = "file" → 文件实体
  - logType = "domain" → 域名实体
  - logType = "network" → 网络实体
  - logType = "registry" → 注册表实体

告警类型（字段判断）：
  - fileMd5 + targetFilename 存在 → 文件实体
  - requestDomain 存在 → 域名实体
  - destAddress 存在 → 网络实体
  - targetObject 存在 → 注册表实体
```

### 关键代码

```java
EntityExtractor.extractEntitiesFromGraph(subgraph);
```

---

## 7. 虚拟父节点 parentProcessGuid 调整算法 ⭐⭐⭐⭐☆

**算法名称**：`adjustVirtualParentLinks`

**功能**：调整虚拟父节点的 `parentProcessGuid`，指向真实根节点或 EXPLORE 节点

**详细文档**：[延迟拆分优化-完整分析](./延迟拆分优化-完整分析.md)

### 核心特点

- ✅ 虚拟父节点初始 `parentProcessGuid = null`
- ✅ 如果子节点是根节点，指向根节点
- ✅ 如果子节点是断链节点，指向 EXPLORE 节点
- ✅ 保证虚拟父节点能正确桥接

### 调整逻辑

```
场景1：子节点是根节点
    VIRTUAL_PARENT (parentGuid = null)
      |
    ROOT_NODE (isRoot = true)

调整：
    VIRTUAL_PARENT (parentGuid = ROOT_NODE) ✅
      |
    ROOT_NODE

场景2：子节点是断链节点
    VIRTUAL_PARENT (parentGuid = null)
      |
    BROKEN_NODE (isBroken = true)

调整：
    VIRTUAL_PARENT (parentGuid = EXPLORE_xxx) ✅
      |
    BROKEN_NODE
```

### 关键代码

```java
adjustVirtualParentLinks(subgraph);
```

---

## 8. 根节点识别算法 ⭐⭐⭐⭐⭐

**算法名称**：`identifyRootNodes`

**功能**：识别图中的根节点和断链节点，区分普通根节点和特殊根节点

**详细文档**：
- [根节点与虚拟父节点关系详解](./根节点与虚拟父节点关系详解.md) ⭐⭐⭐⭐⭐ 重点推荐
- [代码阅读指南-完整流程详解](./代码阅读指南-完整流程详解.md) → 阶段2

### 核心特点

- ✅ 规则1：真正的根节点（`processGuid == traceId`）
- ✅ 规则2：虚拟根父节点（以 `VIRTUAL_ROOT_PARENT_` 开头）
- ✅ 规则3：断链节点（入度为0，有 `parentProcessGuid`，但父节点不存在）
- ✅ 区分普通根节点和特殊根节点
- ✅ 建立 `traceId → rootNodeId` 映射

### 识别规则

```
规则1：真正的根节点
  if (processGuid == traceId) {
      标记为根节点 ✅
  }

规则2：虚拟根父节点（只针对特殊根节点）
  if (nodeId.startsWith("VIRTUAL_ROOT_PARENT_")) {
      标记为根节点 ✅
      替换原根节点映射（虚拟父节点才是真正的根）
      将原子根节点的 isRoot 改为 false
  }

规则3：断链节点
  if (入度 == 0 && 有 parentGuid && 父节点不存在) {
      标记为断链节点 ✅
  }
```

### 特殊根节点 vs 普通根节点

| 类型 | 条件 | 是否创建虚拟父节点 |
|------|------|-------------------|
| 普通根节点 | `processGuid == traceId`<br/>`parentProcessGuid != processGuid` | ❌ 否 |
| 特殊根节点 | `processGuid == parentProcessGuid == traceId` | ✅ 是 |

**详细说明**：参见 [根节点与虚拟父节点关系详解](./根节点与虚拟父节点关系详解.md)

### 关键代码

```java
subgraph.identifyRootNodes(traceIds);
```

---

## 9. 扩展溯源算法 ⭐⭐⭐⭐⭐

**算法名称**：`performExtension` + `extendFromNode` + `buildExtensionChain`

**功能**：从已识别的根节点向上查询父节点，最多扩展2层，获得更完整的攻击上下文

**详细文档**：[扩展溯源逻辑详解](./扩展溯源逻辑详解.md) ⭐⭐⭐⭐⭐

### 核心特点

- ✅ 智能跳过（Explore节点、虚拟根父节点、断链节点）
- ✅ 最多扩展2层（父节点、祖父节点）
- ✅ 只在同 traceId 内扩展
- ✅ 自动更新 isRoot 标记

### 跳过条件

```
条件1：Explore 虚拟节点
  nodeId.startsWith("EXPLORE_")
  原因：系统创建的虚拟节点，无实际父进程

条件2：虚拟根父节点
  nodeId.startsWith("VIRTUAL_ROOT_PARENT_")
  原因：parentProcessGuid 固定为 null，无法扩展
  
条件3：断链节点
  node.isBroken == true
  原因：父节点日志缺失，无法继续追溯
```

### 扩展流程

```
场景：普通根节点扩展成功

扩展前：
  根节点A (isRoot=true, parentGuid=PARENT_B)
    |
  子节点C

扩展后：
  祖父节点D (新Root, isRoot=true, extensionDepth=2)
    |
  父节点B (extensionDepth=1)
    |
  根节点A (isRoot=false, 不再是根)
    |
  子节点C

映射更新：
  扩展前：traceIdToRootMap = {T1 -> A}
  扩展后：traceIdToRootMap = {T1 -> D}
```

### 虚拟根父节点为何不扩展？

```
虚拟根父节点特性：
  - 从子进程日志的 parentXXX 字段构造
  - parentProcessGuid 固定为 null（无祖父进程信息）
  - 本身就是扩展的边界

扩展判断：
  if (parentProcessGuid == null) {
      return originalRootId;  // ❌ 无法扩展
  }
```

### 关键代码

```java
Map<String, String> updatedMap = ProcessChainExtensionUtil.performExtension(
        traceIdToRootMap, hostToTraceId, allNodes, allEdges, 
        esQueryService, maxDepth);
```

---

## 10. 根节点与虚拟父节点关系 ⭐⭐⭐⭐⭐

**专题**：普通根节点 vs 特殊根节点

**功能**：理解何时创建虚拟父节点，为什么需要虚拟父节点

**详细文档**：[根节点与虚拟父节点关系详解](./根节点与虚拟父节点关系详解.md) ⭐⭐⭐⭐⭐

### 核心问题

**当 `processGuid == traceId` 时，会为它创建虚拟父节点吗？**

**答案**：分两种情况

### 情况1：普通根节点（不创建虚拟父节点）❌

**条件**：
- `processGuid == traceId` ✅
- `parentProcessGuid != processGuid` ✅

**示例**：
```
Chrome 浏览器进程：
  processGuid = "chrome_12345"
  traceId = "chrome_12345"
  parentProcessGuid = "explorer_67890"  ← 父进程是 explorer，但不在采集范围

结果：
  chrome_12345 ⭐ (根节点)
    |
  chrome_renderer

不创建虚拟父节点 ❌
```

### 情况2：特殊根节点（创建虚拟父节点）✅

**条件**：
- `processGuid == parentProcessGuid == traceId` ✅（三者相等）

**示例**：
```
系统进程：
  processGuid = "system_00001"
  traceId = "system_00001"
  parentProcessGuid = "system_00001"  ← 自引用（系统进程没有父进程）

结果：
  VIRTUAL_ROOT_PARENT_xxx ⭐⭐ (虚拟根父节点，用于网端桥接)
    |
  system_00001 ⭐ (子根节点)
    |
  lsass

创建虚拟父节点 ✅
用于避免自环和网端桥接 ✅
```

### 为什么需要虚拟父节点？

```
网端桥接场景：

没有虚拟父节点（❌ 错误）：
  STORY_NODE (网侧)
    |
    ↓ (桥接)
  ROOT_001 (processGuid == parentProcessGuid)  ← 自环！❌
    ↓ (自环)
  ROOT_001

有虚拟父节点（✅ 正确）：
  STORY_NODE (网侧)
    |
    ↓ (桥接)
  VIRTUAL_ROOT_PARENT_xxx ⭐ (虚拟根父节点)
    |
  ROOT_001 (子根节点)
    |
  CHILD_A

优点：
  ✅ 避免自环
  ✅ 网端可以正确桥接
  ✅ 进程链完整
```

---

## 11. 进程链合法性检查 ⭐⭐⭐⭐⭐

**算法名称**：`ProcessChainValidator.validateAndFix`

**功能**：对合并后的进程链进行合法性检查和修复

**详细文档**：[进程链合法性检查详解](./进程链合法性检查详解.md) ⭐⭐⭐⭐⭐

### 核心特点

- ✅ 删除指向不存在节点的边
- ✅ 删除自环边（除了虚拟节点）
- ✅ 删除重复边
- ✅ 删除无效边（null/空节点）
- ✅ 简单环检测（双向边）

### 检查项目

```
1. 无效边检查
   - 边为 null
   - source 或 target 为 null/空字符串
   - source 或 target 节点不存在

2. 自环边检查
   - source == target
   - 虚拟节点的自环保留（记录警告）

3. 重复边检查
   - 相同 source 和 target
   - 保留第一次出现的边

4. 简单环检测
   - 检测双向边：A → B 且 B → A
   - 默认只报告警告，不自动删除
```

### 使用场景

```
场景：合并网侧和端侧进程链后

输入（有问题的边）：
  1. A → B
  2. B → X  （X 不存在）
  3. C → C  （自环）
  4. A → B  （重复）
  5. A → D
  6. D → A  （双向边，形成环）

执行：
  ProcessChainValidator.validateAndFix(allNodes, allEdges);

输出（修复后）：
  1. A → B  （保留）
  2. A → D  （保留）
  3. D → A  （保留，但记录环警告）

删除：
  - B → X：节点不存在
  - C → C：自环
  - A → B（第2次）：重复边
```

### 为什么不用复杂的环检测？

```
原因：
  1. 建图阶段已检测：ProcessChainGraphBuilder 已做过完整环检测
  2. 合并不易引入复杂环：
     - 网侧数据有环应该在网侧处理
     - 桥接边不会引入环
     - 扩展溯源只向上扩展，不会引入环
  3. 简单检测足够：检测双向边已覆盖大部分场景
  4. 保守策略：默认只报告，不自动删除更安全
```

### 关键代码

```java
// 自动验证和修复
ProcessChainValidator.validateAndFix(allNodes, allEdges);

// 可选：手动断环
int removedCount = ProcessChainValidator.breakSimpleCycles(allEdges, allNodes);
```

---

## 算法之间的关系

```
┌─────────────────────────────────────────────────┐
│ 进程链构建流程                                   │
└─────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────┐
│ 阶段1：建图 (ProcessChainGraphBuilder)          │
│  - 添加节点                                      │
│  - 建立边                                        │
│  - 环检测 (DFS 着色法) ⭐                       │
└─────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────┐
│ 阶段2：子图提取                                  │
│  - 确定起点节点                                  │
│  - 全树遍历算法 ⭐                              │
│  - 多 traceId 场景处理 ⭐                       │
└─────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────┐
│ 阶段3：虚拟父节点创建                            │
│  - 虚拟父节点批量添加算法 ⭐                    │
│  - 根节点识别算法 ⭐                            │
│  - 虚拟父节点 parentGuid 调整 ⭐                │
└─────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────┐
│ 阶段4：图裁剪（如果需要）                        │
│  - 图裁剪算法 ⭐                                │
└─────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────┐
│ 阶段5：实体提取                                  │
│  - 实体提取算法 ⭐                              │
└─────────────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────┐
│ 阶段6：输出转换                                  │
└─────────────────────────────────────────────────┘
```

---

## 快速查找

### 按场景查找算法

| 场景 | 算法 |
|------|------|
| 从告警节点收集完整进程树 | [全树遍历算法](./全树遍历算法详解.md) |
| 父进程信息缺失 | [虚拟父节点批量添加](./虚拟父节点批量添加详解.md) |
| 理解根节点和虚拟父节点 | [根节点与虚拟父节点关系详解](./根节点与虚拟父节点关系详解.md) ⭐ |
| 多个 traceId | [多traceId场景分析](./多traceId场景分析.md) |
| 节点数过多 | [图裁剪算法](./图裁剪集成说明.md) |
| 检测环 | [DFS 环检测](./代码阅读指南-完整流程详解.md) |
| 提取文件/域名等实体 | [实体提取算法](./代码阅读指南-完整流程详解.md) |
| 扩展溯源（查询父节点） | [扩展溯源逻辑详解](./扩展溯源逻辑详解.md) ⭐ |
| 合法性检查和修复 | [进程链合法性检查详解](./进程链合法性检查详解.md) ⭐ |

### 按问题查找算法

| 问题 | 算法 |
|------|------|
| 子图不完整 | [全树遍历算法](./全树遍历算法详解.md) 或 [多traceId场景分析](./多traceId场景分析.md) |
| 虚拟父节点未创建 | [虚拟父节点批量添加](./虚拟父节点批量添加详解.md) |
| 何时创建虚拟父节点？ | [根节点与虚拟父节点关系详解](./根节点与虚拟父节点关系详解.md) ⭐ |
| 普通根节点 vs 特殊根节点？ | [根节点与虚拟父节点关系详解](./根节点与虚拟父节点关系详解.md) ⭐ |
| 网端桥接失败 | [多traceId场景分析](./多traceId场景分析.md) 或 [根节点与虚拟父节点关系详解](./根节点与虚拟父节点关系详解.md) |
| 进程链断链 | [虚拟父节点批量添加](./虚拟父节点批量添加详解.md) |
| 图中有环 | [DFS 环检测](./代码阅读指南-完整流程详解.md) 或 [进程链合法性检查详解](./进程链合法性检查详解.md) ⭐ |
| 扩展溯源如何工作？ | [扩展溯源逻辑详解](./扩展溯源逻辑详解.md) ⭐ |
| 虚拟根父节点为何不扩展？ | [扩展溯源逻辑详解](./扩展溯源逻辑详解.md) ⭐ |
| 边指向不存在的节点？ | [进程链合法性检查详解](./进程链合法性检查详解.md) ⭐ |
| 重复边或自环？ | [进程链合法性检查详解](./进程链合法性检查详解.md) ⭐ |

---

## 学习建议

### 新手入门

1. 先阅读 [代码阅读指南-完整流程详解](./代码阅读指南-完整流程详解.md)，了解整体流程
2. 重点理解 [全树遍历算法](./全树遍历算法详解.md)（最核心）
3. 理解 [虚拟父节点批量添加](./虚拟父节点批量添加详解.md)（解决断链问题）

### 进阶学习

1. 学习 [多traceId场景分析](./多traceId场景分析.md)（复杂场景）
2. 理解 [图裁剪算法](./图裁剪集成说明.md)（性能优化）
3. 掌握各种边缘情况的处理

### 专家路径

1. 完成所有算法的学习
2. 理解算法之间的相互作用
3. 能够优化和扩展现有算法

---

## 相关文档

- 📖 [代码阅读指南-完整流程详解](./代码阅读指南-完整流程详解.md)
- 📖 [延迟拆分优化-完整分析](./延迟拆分优化-完整分析.md)
- 📖 [延迟拆分优化-实施方案](./延迟拆分优化-实施方案.md)
- 📋 [文档索引](./00-文档索引.md)

---

**最后更新**：2025-11-22  
**维护者**：开发团队

