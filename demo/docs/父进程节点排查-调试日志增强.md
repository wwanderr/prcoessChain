# 父进程节点排查 - 调试日志增强

**日期**：2025-05-26  
**问题**：父进程节点没有被抽取出来  
**修改文件**：`ProcessChainGraphBuilder.java`

---

## 问题描述

用户反馈：父进程节点没有在最终的图中出现。

### 预期行为

对于 file 类型的日志，应该拆分出3个节点：
```
父进程节点 (parentProcessGuid)
    ↓
子进程节点 (processGuid) 
    ↓
实体节点 (processGuid_FILE_hash)
```

### 实际情况

只看到子进程节点和实体节点，父进程节点缺失。

---

## 父进程节点处理流程

### 流程图

```
1. LogNodeSplitter.splitEntityLog(rawLog)
   ├─ 创建子进程节点 (processGuid)
   ├─ 创建父进程节点 (parentProcessGuid)  ← 虚拟节点
   └─ 创建实体节点 (processGuid_FILE_hash)

2. ProcessChainGraphBuilder.buildGraph()
   ├─ 添加子进程节点到图
   ├─ 处理父进程节点
   │  ├─ 如果是虚拟节点 → 暂存到 virtualParents
   │  └─ 如果不是虚拟节点 → 直接添加到图
   └─ 添加实体节点到图

3. 阶段2.5：处理虚拟父节点
   ├─ 遍历 virtualParents
   ├─ 如果图中没有该节点 → 添加虚拟父节点
   └─ 如果图中已有该节点 → 跳过（被真实节点替代）
```

---

## 可能的问题

### 问题1：父进程节点没有被创建

**原因**：
- `parentProcessGuid` 为空或null
- `splitEntityLog()` 的第116-124行没有执行

**检查**：
```java
// LogNodeSplitter.java 第116行
String parentGuid = rawLog.getParentProcessGuid();
if (parentGuid != null && !parentGuid.isEmpty()) {  // ← 这个条件可能为false
    GraphNode parentNode = createVirtualParentNode(rawLog);
    result.setParentNode(parentNode);
    // ...
}
```

**验证**：
查看日志中是否有：
```
【节点拆分】file: E3E7C129C46B2111 → E3E5C129C46B2111 → E3E5C129C46B2111_FILE_xxx
              ↑父进程                ↑子进程              ↑实体节点
```

### 问题2：父进程节点被识别为真实节点

**原因**：
- `parentNode.isVirtual()` 返回 false
- 父节点被直接添加到图，而不是暂存

**检查**：
```
【建图-父节点】添加真实父节点: parentId=E3E7C129C46B2111, isVirtual=false
```

### 问题3：父进程节点ID与子进程ID相同

**原因**：
- `parentProcessGuid == processGuid`（自环）
- 父节点和子节点的ID相同，父节点被子节点覆盖

**检查**：
```
parentGuid = E3E5C129C46B2111
childGuid = E3E5C129C46B2111  ← 相同！
```

### 问题4：父进程节点被真实节点替代

**原因**：
- 图中已经有该ID的真实节点（来自告警或其他日志）
- 虚拟父节点被跳过

**检查**：
```
【建图】虚拟父节点被真实节点替代: parentId=E3E7C129C46B2111
```

### 问题5：父进程节点在遍历时丢失

**原因**：
- 父节点被添加到图，但在子图提取时没有被包含
- `fullTreeTraversal()` 只向下遍历，没有向上到父节点

**检查**：
```
【建图】节点总数=15 (包含父节点)
【全树遍历】总节点数=12 (不包含父节点)
```

---

## 新增的调试日志

### 1. 父节点处理阶段

**位置**：`ProcessChainGraphBuilder.java` 第101-120行

```java
if (splitResult.getParentNode() != null) {
    GraphNode parentNode = splitResult.getParentNode();
    String parentId = parentNode.getNodeId();
    
    if (parentNode.isVirtual()) {
        // 虚拟父节点：暂存，后续合并
        if (!virtualParents.containsKey(parentId)) {
            virtualParents.put(parentId, parentNode);
            log.debug("【建图-父节点】暂存虚拟父节点: parentId={}, isVirtual={}", 
                    parentId, parentNode.isVirtual());
        }
    } else if (!graph.hasNode(parentId)) {
        // 真实父节点：直接添加
        graph.addNode(parentNode);
        log.debug("【建图-父节点】添加真实父节点: parentId={}, isVirtual={}", 
                parentId, parentNode.isVirtual());
    } else {
        log.debug("【建图-父节点】父节点已存在，跳过: parentId={}", parentId);
    }
}
```

**日志输出**：
```
【建图-父节点】暂存虚拟父节点: parentId=E3E7C129C46B2111, isVirtual=true
或
【建图-父节点】添加真实父节点: parentId=E3E7C129C46B2111, isVirtual=false
或
【建图-父节点】父节点已存在，跳过: parentId=E3E7C129C46B2111
```

### 2. 虚拟父节点处理统计

**位置**：`ProcessChainGraphBuilder.java` 第142-163行

```java
log.info("【建图-阶段2.5】处理虚拟父节点: 暂存数量={}", virtualParents.size());
int addedVirtualParentCount = 0;
int replacedVirtualParentCount = 0;

for (Map.Entry<String, GraphNode> entry : virtualParents.entrySet()) {
    String parentId = entry.getKey();
    GraphNode virtualParent = entry.getValue();
    
    if (!graph.hasNode(parentId)) {
        // 添加虚拟父节点
        graph.addNode(virtualParent);
        addedVirtualParentCount++;
        log.debug("【建图】添加虚拟父节点: parentId={}, nodeType={}", 
                parentId, virtualParent.getNodeType());
    } else {
        // 被真实节点替代
        replacedVirtualParentCount++;
        log.debug("【建图】虚拟父节点被真实节点替代: parentId={}", parentId);
    }
}

log.info("【建图-阶段2.5】虚拟父节点处理完成: 添加={}, 替代={}", 
        addedVirtualParentCount, replacedVirtualParentCount);
```

**日志输出**：
```
【建图-阶段2.5】处理虚拟父节点: 暂存数量=5
【建图】添加虚拟父节点: parentId=PARENT_1, nodeType=process
【建图】虚拟父节点被真实节点替代: parentId=E3E7C129C46B2111
【建图-阶段2.5】虚拟父节点处理完成: 添加=4, 替代=1
```

---

## 排查步骤

### 步骤1：检查父进程节点是否被创建

查看 LogNodeSplitter 的日志：
```
搜索：【节点拆分】file:
```

**正常输出**：
```
【节点拆分】file: E3E7C129C46B2111 → E3E5C129C46B2111 → E3E5C129C46B2111_FILE_xxx
              ↑父进程              ↑子进程              ↑实体节点
```

**异常输出**：
```
【节点拆分】file: (empty) → E3E5C129C46B2111 → E3E5C129C46B2111_FILE_xxx
              ↑父进程为空
```

### 步骤2：检查父节点如何被处理

```
搜索：【建图-父节点】
```

**情况A：被暂存**
```
【建图-父节点】暂存虚拟父节点: parentId=E3E7C129C46B2111, isVirtual=true
```
→ 进入步骤3

**情况B：直接添加**
```
【建图-父节点】添加真实父节点: parentId=E3E7C129C46B2111, isVirtual=false
```
→ 父节点应该在图中

**情况C：跳过**
```
【建图-父节点】父节点已存在，跳过: parentId=E3E7C129C46B2111
```
→ 图中已有该节点

### 步骤3：检查虚拟父节点处理

```
搜索：【建图-阶段2.5】
```

**正常输出**：
```
【建图-阶段2.5】处理虚拟父节点: 暂存数量=5
【建图】添加虚拟父节点: parentId=xxx, nodeType=process
【建图-阶段2.5】虚拟父节点处理完成: 添加=5, 替代=0
```

**异常输出（被替代）**：
```
【建图-阶段2.5】处理虚拟父节点: 暂存数量=5
【建图】虚拟父节点被真实节点替代: parentId=E3E7C129C46B2111
【建图-阶段2.5】虚拟父节点处理完成: 添加=4, 替代=1
```

### 步骤4：检查最终图的节点

```
搜索：【建图】日志节点添加完成
```

查看节点总数和进程节点数，确认父节点是否被包含。

---

## 代码规范：避免使用 `log` 作为变量名

### ❌ 错误示例

```java
for (RawLog log : logs) {
    log.info("处理日志: {}", log.getProcessGuid());
             ↑ log.info 与 变量log 冲突
}
```

### ✅ 正确示例

```java
for (RawLog rawLog : logs) {
    log.info("处理日志: {}", rawLog.getProcessGuid());
             ↑ log.info (日志方法) 与 rawLog (变量) 不冲突
}
```

### 已修改的地方

1. `ProcessChainGraphBuilder.java` 第71行
   ```java
   for (RawLog rawLog : logs) {  // ✅ 从 log 改为 rawLog
   ```

2. `ProcessChainGraphBuilder.java` 第278行和291行
   ```java
   for (RawLog rawLog : newLogs) {  // ✅ 从 log 改为 rawLog
   ```

---

## 常见场景分析

### 场景1：自环（parentGuid == processGuid）

```
日志：
  processGuid: E3E5C129C46B2111
  parentProcessGuid: E3E5C129C46B2111  ← 自环

结果：
  父节点ID = 子节点ID，父节点被子节点覆盖
```

**解决**：
- 自环场景下不应该创建父节点
- 或者父节点应该是更上层的节点

### 场景2：告警节点与父节点ID相同

```
告警：
  processGuid: E3E7C129C46B2111
  
日志：
  processGuid: E3E5C129C46B2111  ← 子节点
  parentProcessGuid: E3E7C129C46B2111  ← 父节点

结果：
  告警节点已存在，虚拟父节点被跳过
```

**预期**：
- 这是正常的，告警节点就是父节点
- 虚拟父节点被真实节点（告警）替代

### 场景3：正常父子关系

```
日志：
  processGuid: CHILD_123
  parentProcessGuid: PARENT_456

结果：
  父节点 (PARENT_456) 和 子节点 (CHILD_123) 都应该存在
```

---

## 总结

### 添加的调试日志

| 位置 | 日志 | 作用 |
|-----|------|------|
| 父节点处理 | 【建图-父节点】暂存/添加/跳过 | 追踪父节点的处理方式 |
| 阶段2.5开始 | 【建图-阶段2.5】处理虚拟父节点 | 统计暂存数量 |
| 阶段2.5处理 | 【建图】添加/替代虚拟父节点 | 追踪每个父节点的最终处理 |
| 阶段2.5结束 | 【建图-阶段2.5】处理完成 | 统计添加和替代数量 |

### 代码规范

✅ **已修复**：将变量名从 `log` 改为 `rawLog`，避免与 `log.info()` 等日志方法冲突

### 下一步

请运行代码并提供以下日志：
1. `【节点拆分】file:` - 查看父子关系
2. `【建图-父节点】` - 查看父节点如何被处理
3. `【建图-阶段2.5】` - 查看虚拟父节点的最终处理
4. `【建图】日志节点添加完成` - 查看最终节点统计

---

**修改时间**：2025-05-26  
**修改文件**：`ProcessChainGraphBuilder.java`  
**代码变更**：+30行（调试日志 + 变量重命名）  
**测试状态**：✅ 无编译错误



