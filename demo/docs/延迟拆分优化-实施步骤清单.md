# 延迟拆分优化 - 详细实施步骤清单

## 一、修改前的准备工作

### 1.1 备份当前代码
- [ ] 创建 Git 分支：`git checkout -b feature/lazy-virtual-parent-creation`
- [ ] 确认当前代码可编译运行

### 1.2 确认修改范围

**核心修改文件**（4个）：
1. `ProcessChainGraphBuilder.java` - 删除虚拟父节点创建逻辑
2. `ProcessChainBuilder.java` - 新增父进程拆分阶段
3. `EntityExtractor.java` - 新增告警支持
4. `IncidentConverters.java` - 调整告警的实体提取

**辅助修改**：
- 删除无用的方法（`calculateParentProcessGuidHash` 等）

---

## 二、详细修改步骤

### 步骤1：修改 ProcessChainGraphBuilder.java

#### 1.1 删除虚拟父节点的暂存逻辑（阶段2）

**位置**：第125-205行（阶段2：添加日志节点）

**修改前**：
```java
// 阶段2：添加日志节点（只构建进程链，不拆分实体）
if (logs != null) {
    Map<String, GraphNode> virtualParents = new HashMap<>();  // ❌ 删除
    
    for (RawLog rawLog : logs) {
        // ... 创建子进程节点
        
        // 2. 处理父进程节点（如果有）
        if (parentGuid != null && !parentGuid.isEmpty()) {
            // ... 检测根节点
            
            // 创建或暂存虚拟父节点  ❌ 删除这一整段
            if (!graph.hasNode(actualParentNodeId) && !virtualParents.containsKey(actualParentNodeId)) {
                GraphNode virtualParent = createVirtualParentNode(rawLog, actualParentNodeId);
                virtualParents.put(actualParentNodeId, virtualParent);
                log.debug("【建图-父节点】暂存虚拟父节点: parentId={}, isRoot={}, isSpecial={}", 
                        actualParentNodeId, isRootNode, isSpecialRootNode);
            }
            
            // 创建边：父 → 子
            log.debug("【建图-阶段2】创建边: {} → {} (父→子)", actualParentNodeId, childGuid);
            graph.addEdge(actualParentNodeId, childGuid);
        }
    }
    
    // 阶段2.5：处理虚拟父节点  ❌ 删除整个阶段2.5
    log.info("【建图-阶段2.5】处理虚拟父节点: 暂存数量={}", virtualParents.size());
    // ...
}
```

**修改后**：
```java
// 阶段2：添加日志节点（只构建进程链，不拆分实体）
if (logs != null) {
    // ✅ 删除 virtualParents
    
    for (RawLog rawLog : logs) {
        // ... 创建子进程节点（保持不变）
        
        // 2. 处理父进程节点（如果有）
        if (parentGuid != null && !parentGuid.isEmpty()) {
            // ... 检测根节点（保持不变）
            
            // ✅ 删除虚拟父节点创建逻辑
            
            // ✅ 保留：创建边（即使父节点不存在）
            log.debug("【建图-阶段2】创建边: {} → {} (父→子)", actualParentNodeId, childGuid);
            graph.addEdge(actualParentNodeId, childGuid);
        }
    }
    
    // ✅ 删除阶段2.5：处理虚拟父节点
}
```

#### 1.2 删除 createVirtualParentNode 方法

**位置**：第359行

**删除方法**：
```java
// ❌ 删除整个方法
private GraphNode createVirtualParentNode(RawLog rawLog, String actualParentNodeId) {
    // ...
}
```

#### 1.3 删除 hash 计算方法

**位置**：第434行

**删除方法**：
```java
// ❌ 删除
private String calculateParentProcessGuidHash(RawLog rawLog) {
    // ...
}
```

#### 1.4 删除建图阶段的 identifyRootNodes 调用

**位置**：第288行

**修改前**：
```java
// 阶段4：图分析
graph.identifyRootNodes(traceIds != null ? traceIds : Collections.emptySet());  // ❌ 删除
```

**修改后**：
```java
// 阶段4：图分析（移到子图提取后）
// ✅ 删除此处的调用
```

---

### 步骤2：修改 ProcessChainBuilder.java

#### 2.1 新增父进程拆分阶段

**位置**：在 `buildProcessChain()` 方法中，子图提取后（约第277行后）

**新增代码**：
```java
// ===== 阶段3：提取子图 =====
ProcessChainGraph subgraph = fullGraph.extractSubgraph(relevantNodes);
log.info("【子图提取完成】进程节点数={}", subgraph.getNodeCount());

// ===== 阶段3.5：父进程拆分（延迟创建虚拟父节点）✅ 新增 =====
log.info("【父进程拆分】开始为子图节点创建虚拟父节点...");
createVirtualParentsForSubgraph(subgraph, traceIds);
log.info("【父进程拆分完成】子图节点总数={}", subgraph.getNodeCount());

// ===== 阶段3.6：图分析（完整）✅ 新增 =====
log.info("【图分析】开始识别根节点和断链节点...");
subgraph.identifyRootNodes(traceIds != null ? traceIds : Collections.emptySet());
log.info("【图分析完成】");

// ===== 阶段4：裁剪（如果需要）=====
// ...
```

#### 2.2 新增 createVirtualParentsForSubgraph 方法

**位置**：在 `ProcessChainBuilder` 类中新增方法

**完整代码**：
```java
/**
 * 为子图节点创建虚拟父节点（延迟拆分）
 * 
 * 流程：
 * 1. 遍历子图的所有节点（只处理真实节点，跳过虚拟节点）
 * 2. 检查其父节点是否存在
 * 3. 如果不存在，从日志/告警中提取父进程信息，创建虚拟父节点
 * 4. 批量添加虚拟父节点到子图
 * 
 * 关键点：
 * - 虚拟父节点的 parentProcessGuid 永远是 null
 * - 批量创建，避免重复
 * - 优先从日志提取，没有日志时从告警提取
 * 
 * @param subgraph 子图
 * @param traceIds traceId集合
 */
private void createVirtualParentsForSubgraph(ProcessChainGraph subgraph, Set<String> traceIds) {
    Map<String, GraphNode> virtualParentsToAdd = new HashMap<>();
    int createdCount = 0;
    
    // 遍历子图的所有节点
    for (GraphNode node : subgraph.getAllNodes()) {
        // ✅ 跳过虚拟节点（重要！）
        if (node.isVirtual()) {
            continue;
        }
        
        String nodeId = node.getNodeId();
        String parentGuid = node.getParentProcessGuid();
        
        // 如果没有父节点信息，跳过
        if (parentGuid == null || parentGuid.isEmpty()) {
            continue;
        }
        
        // 如果父节点已经存在（真实节点），跳过
        if (subgraph.hasNode(parentGuid)) {
            log.debug("【父进程拆分】父节点已存在: childId={}, parentId={}", nodeId, parentGuid);
            continue;
        }
        
        // 如果虚拟父节点已经在待添加列表中，跳过
        if (virtualParentsToAdd.containsKey(parentGuid)) {
            continue;
        }
        
        // 优先从日志中提取父进程信息
        List<RawLog> logs = node.getLogs();
        if (logs != null && !logs.isEmpty()) {
            GraphNode virtualParent = createVirtualParentNodeFromLog(logs.get(0), parentGuid);
            virtualParentsToAdd.put(parentGuid, virtualParent);
            createdCount++;
            log.debug("【父进程拆分】从日志创建虚拟父节点: parentId={}, childId={}", 
                    parentGuid, nodeId);
            continue;
        }
        
        // ✅ 新增：没有日志时，从告警中提取父进程信息
        List<RawAlarm> alarms = node.getAlarms();
        if (alarms != null && !alarms.isEmpty()) {
            GraphNode virtualParent = createVirtualParentNodeFromAlarm(alarms.get(0), parentGuid);
            virtualParentsToAdd.put(parentGuid, virtualParent);
            createdCount++;
            log.debug("【父进程拆分】从告警创建虚拟父节点: parentId={}, childId={}", 
                    parentGuid, nodeId);
        }
    }
    
    // 批量添加虚拟父节点到图中
    for (GraphNode virtualParent : virtualParentsToAdd.values()) {
        subgraph.addNode(virtualParent);
    }
    
    log.info("【父进程拆分】创建虚拟父节点数={}", createdCount);
}

/**
 * 从日志创建虚拟父节点
 * 
 * 关键：虚拟父节点的 parentProcessGuid 永远是 null
 */
private GraphNode createVirtualParentNodeFromLog(RawLog rawLog, String parentGuid) {
    GraphNode parentNode = new GraphNode();
    
    parentNode.setNodeId(parentGuid);
    parentNode.setProcessGuid(parentGuid);
    parentNode.setParentProcessGuid(null);  // ✅ 永远是 null（未知）
    parentNode.setVirtual(true);
    parentNode.setNodeType("process");
    
    // 从日志中提取父进程信息
    parentNode.setTraceId(rawLog.getTraceId());
    parentNode.setHostAddress(rawLog.getHostAddress());
    
    // 从 rawLog 的 parent* 字段中提取（如果有）
    // 注意：这些字段可能为 null
    
    return parentNode;
}

/**
 * 从告警创建虚拟父节点
 * 
 * 关键：虚拟父节点的 parentProcessGuid 永远是 null
 */
private GraphNode createVirtualParentNodeFromAlarm(RawAlarm alarm, String parentGuid) {
    GraphNode parentNode = new GraphNode();
    
    parentNode.setNodeId(parentGuid);
    parentNode.setProcessGuid(parentGuid);
    parentNode.setParentProcessGuid(null);  // ✅ 永远是 null（未知）
    parentNode.setVirtual(true);
    parentNode.setNodeType("process");
    
    // 从告警中提取父进程信息
    parentNode.setTraceId(alarm.getTraceId());
    parentNode.setHostAddress(alarm.getHostAddress());
    
    // 从 alarm 的 parent* 字段中提取（如果有）
    // 注意：这些字段可能为 null
    
    return parentNode;
}
```

---

### 步骤3：修改 EntityExtractor.java（新增告警支持）

#### 3.1 修改 extractEntitiesFromGraph 方法

**位置**：第51行

**修改前**：
```java
public static void extractEntitiesFromGraph(ProcessChainGraph graph) {
    // ...
    for (GraphNode node : graph.getAllNodes()) {
        // 只处理进程节点
        if (!isProcessNode(node)) {
            continue;
        }
        
        String processGuid = node.getNodeId();
        List<RawLog> logs = node.getLogs();
        
        if (logs == null || logs.isEmpty()) {
            continue;  // ❌ 没有日志就跳过
        }
        
        // 从日志中提取实体
        for (RawLog rawLog : logs) {
            // ...
        }
    }
}
```

**修改后**：
```java
public static void extractEntitiesFromGraph(ProcessChainGraph graph) {
    // ...
    for (GraphNode node : graph.getAllNodes()) {
        // 只处理进程节点
        if (!isProcessNode(node)) {
            continue;
        }
        
        String processGuid = node.getNodeId();
        
        // ✅ 优先从日志中提取实体
        List<RawLog> logs = node.getLogs();
        if (logs != null && !logs.isEmpty()) {
            for (RawLog rawLog : logs) {
                String logType = rawLog.getLogType();
                if (ENTITY_LOG_TYPES.contains(logType)) {
                    // 创建实体节点
                    extractEntityFromLog(rawLog, processGuid, graph, entityNodesToAdd, edgesToAdd);
                }
            }
            continue;  // ✅ 节点级优先级：有日志就不处理告警
        }
        
        // ✅ 新增：没有日志时，从告警中提取实体
        List<RawAlarm> alarms = node.getAlarms();
        if (alarms != null && !alarms.isEmpty()) {
            for (RawAlarm alarm : alarms) {
                String entityType = determineEntityTypeFromAlarm(alarm);
                if (isEntityType(entityType)) {
                    // 创建实体节点
                    extractEntityFromAlarm(alarm, entityType, processGuid, graph, entityNodesToAdd, edgesToAdd);
                }
            }
        }
    }
}
```

#### 3.2 新增告警实体判断方法

**位置**：新增方法

**代码**：
```java
/**
 * 判断告警的实体类型（根据字段，不是logType）
 * 
 * 规则：
 * - file: fileMd5 + targetFilename 存在，且 targetFilename != image
 * - domain: requestDomain 存在
 * - network: destAddress 存在，且 != hostAddress
 * - registry: targetObject 存在
 * - process: 其他情况
 */
private static String determineEntityTypeFromAlarm(RawAlarm alarm) {
    // 1. 文件实体
    if (alarm.getFileMd5() != null && !alarm.getFileMd5().isEmpty() &&
        alarm.getTargetFilename() != null && !alarm.getTargetFilename().isEmpty() &&
        !alarm.getTargetFilename().equals(alarm.getImage())) {
        return "file";
    }
    
    // 2. 域名实体
    if (alarm.getRequestDomain() != null && !alarm.getRequestDomain().isEmpty()) {
        return "domain";
    }
    
    // 3. 网络实体（排除本机地址）
    if (alarm.getDestAddress() != null && !alarm.getDestAddress().isEmpty() &&
        !alarm.getDestAddress().equals(alarm.getHostAddress())) {
        return "network";
    }
    
    // 4. 注册表实体
    if (alarm.getTargetObject() != null && !alarm.getTargetObject().isEmpty()) {
        return "registry";
    }
    
    // 5. 其他：进程创建
    return "process";
}

/**
 * 判断是否是实体类型
 */
private static boolean isEntityType(String entityType) {
    return "file".equals(entityType) || 
           "domain".equals(entityType) || 
           "network".equals(entityType) || 
           "registry".equals(entityType);
}
```

#### 3.3 新增从告警提取实体的方法

**位置**：新增方法

**代码**：
```java
/**
 * 从告警中提取实体节点
 */
private static void extractEntityFromAlarm(
        RawAlarm alarm, 
        String entityType, 
        String processGuid, 
        ProcessChainGraph graph,
        List<GraphNode> entityNodesToAdd,
        List<EdgePair> edgesToAdd) {
    
    if ("file".equals(entityType)) {
        GraphNode fileEntity = createFileEntityNodeFromAlarm(alarm, processGuid);
        if (fileEntity != null) {
            entityNodesToAdd.add(fileEntity);
            edgesToAdd.add(new EdgePair(processGuid, fileEntity.getNodeId()));
        }
    }
    else if ("domain".equals(entityType)) {
        GraphNode domainEntity = createDomainEntityNodeFromAlarm(alarm, processGuid);
        if (domainEntity != null) {
            entityNodesToAdd.add(domainEntity);
            edgesToAdd.add(new EdgePair(processGuid, domainEntity.getNodeId()));
        }
    }
    else if ("network".equals(entityType)) {
        GraphNode networkEntity = createNetworkEntityNodeFromAlarm(alarm, processGuid);
        if (networkEntity != null) {
            entityNodesToAdd.add(networkEntity);
            edgesToAdd.add(new EdgePair(processGuid, networkEntity.getNodeId()));
        }
    }
    else if ("registry".equals(entityType)) {
        GraphNode registryEntity = createRegistryEntityNodeFromAlarm(alarm, processGuid);
        if (registryEntity != null) {
            entityNodesToAdd.add(registryEntity);
            edgesToAdd.add(new EdgePair(processGuid, registryEntity.getNodeId()));
        }
    }
}

/**
 * 从告警创建文件实体节点
 */
private static GraphNode createFileEntityNodeFromAlarm(RawAlarm alarm, String processGuid) {
    String targetFilename = alarm.getTargetFilename();
    String fileMd5 = alarm.getFileMd5();
    
    if (targetFilename == null || targetFilename.isEmpty()) {
        return null;
    }
    
    GraphNode fileNode = new GraphNode();
    
    // 生成实体节点ID
    String entityId = generateFileEntityId(processGuid, targetFilename, fileMd5);
    fileNode.setNodeId(entityId);
    fileNode.setProcessGuid(processGuid);
    fileNode.setNodeType("file");
    fileNode.setVirtual(false);
    
    // 添加告警到节点
    fileNode.addAlarm(alarm);
    
    return fileNode;
}

/**
 * 从告警创建域名实体节点
 */
private static GraphNode createDomainEntityNodeFromAlarm(RawAlarm alarm, String processGuid) {
    String requestDomain = alarm.getRequestDomain();
    
    if (requestDomain == null || requestDomain.isEmpty()) {
        return null;
    }
    
    GraphNode domainNode = new GraphNode();
    
    // 生成实体节点ID
    String entityId = generateDomainEntityId(processGuid, requestDomain);
    domainNode.setNodeId(entityId);
    domainNode.setProcessGuid(processGuid);
    domainNode.setNodeType("domain");
    domainNode.setVirtual(false);
    
    // 添加告警到节点
    domainNode.addAlarm(alarm);
    
    return domainNode;
}

/**
 * 从告警创建网络实体节点
 */
private static GraphNode createNetworkEntityNodeFromAlarm(RawAlarm alarm, String processGuid) {
    String destAddress = alarm.getDestAddress();
    
    if (destAddress == null || destAddress.isEmpty() ||
        destAddress.equals(alarm.getHostAddress())) {
        return null;
    }
    
    GraphNode networkNode = new GraphNode();
    
    // 生成实体节点ID
    String entityId = generateNetworkEntityId(processGuid, destAddress);
    networkNode.setNodeId(entityId);
    networkNode.setProcessGuid(processGuid);
    networkNode.setNodeType("network");
    networkNode.setVirtual(false);
    
    // 添加告警到节点
    networkNode.addAlarm(alarm);
    
    return networkNode;
}

/**
 * 从告警创建注册表实体节点
 */
private static GraphNode createRegistryEntityNodeFromAlarm(RawAlarm alarm, String processGuid) {
    String targetObject = alarm.getTargetObject();
    
    if (targetObject == null || targetObject.isEmpty()) {
        return null;
    }
    
    GraphNode registryNode = new GraphNode();
    
    // 生成实体节点ID
    String entityId = generateRegistryEntityId(processGuid, targetObject);
    registryNode.setNodeId(entityId);
    registryNode.setProcessGuid(processGuid);
    registryNode.setNodeType("registry");
    registryNode.setVirtual(false);
    
    // 添加告警到节点
    registryNode.addAlarm(alarm);
    
    return registryNode;
}
```

---

## 三、验证清单

### 3.1 编译验证
- [ ] 代码无编译错误
- [ ] 所有import正确

### 3.2 单元测试验证

**测试场景**：

| 场景 | 测试内容 | 预期结果 |
|------|---------|---------|
| 1. 告警+日志 | 正常构建进程链 | 与优化前一致 |
| 2. 纯日志 | 无告警场景 | 与优化前一致 |
| 3. 纯告警 | 无日志，只有告警 | ✅ 能正确抽取父子进程和实体 |
| 4. 特殊根节点 | processGuid==parentGuid==traceId | 正确创建虚拟父节点 |
| 5. 断链节点 | 缺失父节点 | 正确标记为断链 |
| 6. 虚拟父节点 | 虚拟父节点的parentGuid | ✅ 为null |
| 7. 批量创建 | 不重复创建虚拟父节点 | ✅ HashMap自动去重 |
| 8. 真实替换虚拟 | 真实父节点存在 | ✅ 不创建虚拟节点 |

### 3.3 性能测试

**测试数据**：
- 10,000条日志
- 100个告警
- 5个traceId

**测试指标**：
- 建图后节点数：应该减少约50%
- 内存占用：应该减少约50%
- 执行时间：应该减少约25%

---

## 四、实施顺序

### 阶段1：核心修改（必须）
1. ✅ 修改 ProcessChainGraphBuilder.java
2. ✅ 修改 ProcessChainBuilder.java
3. ✅ 编译验证

### 阶段2：功能增强（必须）
4. ✅ 修改 EntityExtractor.java（新增告警支持）
5. ✅ 编译验证

### 阶段3：测试验证（必须）
6. ✅ 单元测试
7. ✅ 性能测试
8. ✅ 对比验证

### 阶段4：文档更新（必须）
9. ✅ 更新代码阅读指南
10. ✅ 提交代码

---

## 五、风险控制

### 5.1 回滚方案
- 保留 Git 分支
- 记录所有修改点
- 如有问题，立即回滚

### 5.2 灰度发布
- 先在测试环境验证
- 再在生产环境发布

---

## 六、预期收益

### 6.1 性能提升
- ✅ 内存占用：-50%
- ✅ 建图速度：+50%
- ✅ 总体速度：+25%

### 6.2 功能增强
- ✅ 支持从告警抽取父子进程
- ✅ 支持从告警抽取实体
- ✅ 合并优先级（日志 > 告警）

### 6.3 代码质量
- ✅ 删除80行
- ✅ 新增270行
- ✅ 逻辑更清晰

---

## 七、开始实施

确认所有步骤无误后，开始修改代码：
- [ ] 步骤1：修改 ProcessChainGraphBuilder.java
- [ ] 步骤2：修改 ProcessChainBuilder.java
- [ ] 步骤3：修改 EntityExtractor.java
- [ ] 步骤4：编译验证
- [ ] 步骤5：测试验证
- [ ] 步骤6：文档更新




