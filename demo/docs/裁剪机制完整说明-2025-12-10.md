# 裁剪机制完整说明

> **更新时间**: 2025-12-10  
> **更新内容**: 补充智能裁剪内容，修复强制裁剪单链逻辑

---

## 📋 更新内容

### 1. 文档更新
- **文件**: `demo/docs/02-核心算法实现详解.md`
- **新增**: 第4章 - 智能裁剪算法（图裁剪）
- **完善**: 第5章 - 强制裁剪算法（兜底机制）
- **新增**: 第5.5节 - 单链模式与无根节点场景修复

### 2. 代码修复
- **文件**: `demo/src/main/java/com/security/processchain/util/ForcePruner.java`
- **方法**: `selectByGuidOrder`（591-693行）
- **修复**: 向上追溯断链节点，只添加单链上的实体

---

## 🎯 裁剪机制概述

### 两层裁剪机制

```
进程链生成流程:
  ↓
阶段6: 智能裁剪（图裁剪）
  触发条件: 节点数 > 400
  策略: 基于重要性评分
  ↓
阶段7: 实体提取
  从进程节点提取实体
  ↓
阶段7.5: 强制裁剪（兜底机制）
  触发条件: 节点数 > 100
  策略: 单链模式 + 确定性算法
  目标: 裁剪到20个节点
```

---

## 📊 智能裁剪（图裁剪）

### 核心特点
- **触发时机**: 实体提取之前
- **触发条件**: 节点数 > 400
- **裁剪策略**: 基于重要性评分
- **保护机制**: 告警节点、网端关联节点永远保留

### 重要性评分规则

| 类型 | 分数变化 | 说明 |
|------|---------|------|
| 基础分 | 100 | 所有节点起始分 |
| 告警节点 | +50 | 优先保留 |
| 网端关联 | +100 | 最高优先级 |
| 断链节点 | +30 | 用于桥接 |
| 根节点 | +20 | 树的起点 |
| 子节点数 | +5/个 | 最多+50 |
| 深度惩罚 | -10/层 | 越深越不重要 |
| 叶子节点 | -20 | 末端节点 |

### 裁剪效果
```
裁剪前: 500个节点
裁剪后: 400个节点
保留: 告警节点(10) + 网端关联(5) + 高分节点(385)
移除: 低分节点(100)
```

---

## 🔧 强制裁剪（兜底机制）

### 核心特点
- **触发时机**: 实体过滤之后
- **触发条件**: 节点数 > 100
- **目标**: 裁剪到20个节点
- **策略**: 单链模式 + 确定性算法

### 为什么需要强制裁剪？
```
场景: 智能裁剪后保留了30个进程节点
      每个进程节点平均有50个实体子节点
      
实体提取后: 30 × 50 = 1500个实体节点
总节点数: 30 + 1500 = 1530个节点  ❌ 爆炸！

强制裁剪: 裁剪到20个节点  ✅ 可控
```

### 单链模式
**定义**: 从起点到终点，全程不分叉

**示例**:
```
多分支（不是单链）:
         ROOT
          |
        NODE_A
       /  |  \
    NODE_B NODE_C NODE_D
    
单链:
    ROOT
     |
   NODE_A
     |
   NODE_B
```

---

## 🐛 无根节点场景的Bug修复

### 问题场景
```
数据结构:
  - PPP10001 (断链节点) -> AAA10001（4个实体）
  - PPP10002 (断链节点) -> AAA10002（11个实体）
  - PPP10003 (断链节点) -> AAA10003（0个实体）
  
配额: 20个节点
```

### 修复前的问题
```java
// 只向下DFS，丢失断链节点
1. 选择第一个进程节点（AAA10001）
2. 向下DFS（没有子进程，只有1个节点）
3. 添加所有实体（包括其他链的实体）

结果:
  - AAA10001（1个进程）
  - AAA10001的4个实体
  - AAA10002的11个实体 ❌ (不应该保留)
  - 其他实体 ❌
  - 丢失了PPP10001 ❌ (断链节点)
  
问题:
  ❌ 无法桥接网端（缺少断链节点）
  ❌ 包含了其他链的实体（破坏单链）
```

### 修复方案
```java
// ✅ 向上追溯 + 只添加单链上的实体
1. 选择第一个进程节点（AAA10001）
2. ✅ 向上追溯到断链节点（找到PPP10001）
3. 反转链条（[PPP10001, AAA10001]）
4. 向下DFS（无子进程）
5. ✅ 只添加单链上进程节点的直接子实体

结果:
  - PPP10001（断链节点）✅
  - AAA10001（告警节点）✅
  - AAA10001的4个实体 ✅
  总计: 6个节点

效果:
  ✅ 可以桥接网端（有断链节点）
  ✅ 形成完整单链（无分叉）
  ✅ 不包含其他链的节点
```

### 核心改动

#### 改动1: 向上追溯
```java
// 修复前: 只向下DFS
result.add(firstProcessNode);
dfsSelectProcessNodes(firstProcessNode, graph, excludeNodes, result, quota);

// 修复后: 先向上追溯，再向下DFS
List<String> upwardChain = traceToRootProcessOnly(firstProcessNode, graph);
Collections.reverse(upwardChain);  // 反转，让根节点在前
for (String nodeId : upwardChain) {
    result.add(nodeId);
}
dfsSelectProcessNodes(firstProcessNode, graph, excludeNodes, result, quota);
```

#### 改动2: 只添加单链上的实体
```java
// 修复前: 添加所有实体
for (GraphNode node : group.getNodes()) {
    if (node.getNodeType() != NodeType.PROCESS) {
        entities.add(node.getNodeId());
    }
}

// 修复后: 只添加单链上进程节点的直接子实体
for (String processNodeId : result) {  // 只遍历已选中的进程节点
    GraphNode processNode = graph.getNode(processNodeId);
    if (processNode != null && processNode.getNodeType() == NodeType.PROCESS) {
        for (String childId : graph.getChildren(processNodeId)) {
            GraphNode childNode = graph.getNode(childId);
            if (childNode != null && childNode.getNodeType() != NodeType.PROCESS) {
                directChildEntities.add(childId);
            }
        }
    }
}
```

---

## ✅ 验证方法

### 测试数据
```json
{
  "nodes": [
    "PPP10001 -> AAA10001 (4个实体)",
    "PPP10002 -> AAA10002 (11个实体)",
    "PPP10003 -> AAA10003 (0个实体)",
    "EXPLORE_ROOT -> PPP10001/PPP10002/PPP10003"
  ],
  "total": 25
}
```

### 预期结果
```
强制裁剪（阈值20）:
  保留节点:
    - PPP10001 ✅
    - AAA10001 ✅
    - AAA10001_REGISTRY_50b14c02 ✅
    - AAA10001_REGISTRY_9e148fd2 ✅
    - AAA10001_REGISTRY_5eca3b05 ✅
    - AAA10001_NETWORK_7b2d620a ✅
  总计: 6个节点
  
桥接:
  - 网侧: 150.12.11.2 -> 60.60.1.1
  - 端侧: EXPLORE_ROOT -> PPP10001 -> AAA10001 -> 实体
  - 桥接边: 60.60.1.1 -> EXPLORE_ROOT ✅
```

---

## 📚 相关文档

1. **核心算法文档**: `demo/docs/02-核心算法实现详解.md`
   - 第4章: 智能裁剪算法（图裁剪）
   - 第5章: 强制裁剪算法（兜底机制）
   - 第5.5节: 单链模式与无根节点场景修复

2. **修复说明**: `demo/docs/强制裁剪单链修复说明.md`
   - 详细的修复前后对比
   - 完整的代码示例

3. **代码实现**: `demo/src/main/java/com/security/processchain/util/ForcePruner.java`
   - `selectByGuidOrder` 方法（591-693行）

---

## 🎉 总结

### 文档完善
✅ 补充了智能裁剪（图裁剪）的完整说明  
✅ 完善了强制裁剪的触发时机和策略  
✅ 新增了单链模式的详细解释  
✅ 记录了无根节点场景的Bug修复过程

### 代码修复
✅ 修复了 `selectByGuidOrder` 方法  
✅ 向上追溯断链节点，确保可以桥接  
✅ 只添加单链上的实体，避免树杈  
✅ 保持确定性，结果可复现

### 效果验证
✅ 保留断链节点，可以创建虚拟根节点  
✅ 形成完整单链，没有分叉  
✅ 可以正确桥接网端和端侧  
✅ 节点数量可控，符合配额要求

