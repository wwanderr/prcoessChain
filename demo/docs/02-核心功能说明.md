# 核心功能说明

本文档介绍 Process Chain Generator 的核心功能和实现原理。

---

## 📋 目录

1. [进程链构建](#1-进程链构建)
2. [断链处理（Explore节点）](#2-断链处理explore节点)
3. [智能裁剪](#3-智能裁剪)
4. [网端端侧合并](#4-网端端侧合并)
5. [告警选举](#5-告警选举)
6. [多IP多traceId支持](#6-多ip多traceid支持)

---

## 1. 进程链构建

### 1.1 概述

进程链构建是将原始告警（RawAlarm）和日志（RawLog）数据转换为可视化的进程执行链。

### 1.2 核心流程

```
原始数据 (RawAlarm + RawLog)
    ↓
告警选举 (选出最严重的告警组)
    ↓
进程链构建 (双向/向上遍历)
    ↓
断链检测和修复
    ↓
智能裁剪
    ↓
最终进程链 (IncidentProcessChain)
```

### 1.3 根节点识别

**识别规则**:
```java
// 根节点必须同时满足两个条件
1. processGuid == traceId
2. parentProcessGuid == null
```

**示例**:
```
告警: { traceId: "T001", processGuid: "T001", parentProcessGuid: null }
→ 这是根节点 ✅

告警: { traceId: "T001", processGuid: "NODE_001", parentProcessGuid: "T001" }
→ 这不是根节点，是子节点 ❌
```

### 1.4 遍历策略

根据告警等级决定遍历策略：

| 告警等级 | 遍历策略 | 包含子节点 | 用途 |
|---------|---------|-----------|------|
| **高危** | 双向遍历（↑↓） | ✅ 是 | 完整攻击路径分析 |
| **中危** | 向上遍历（↑） | ❌ 否 | 溯源到根节点 |
| **低危** | 向上遍历（↑） | ❌ 否 | 轻量级分析 |

**代码逻辑**:
```java
if (isHighSeverity(severity)) {
    // 高危：双向遍历
    buildBidirectionalChain(alarm, logs);
} else {
    // 中低危：向上遍历
    buildUpwardChain(alarm, logs);
}
```

### 1.5 节点类型

支持5种节点类型：

| 类型 | logType | 说明 | 示例 |
|------|---------|------|------|
| 进程 | `process` | 进程创建/结束 | `cmd.exe` |
| 文件 | `file` | 文件创建/修改/删除 | `malware.dll` |
| 网络 | `network` | 网络连接 | `192.168.1.100:443` |
| 域名 | `domain` | 域名解析 | `evil.com` |
| 注册表 | `registry` | 注册表操作 | `HKEY_LOCAL_MACHINE\...` |

---

## 2. 断链处理（Explore节点）

### 2.1 什么是断链？

**断链** = 找不到根节点的进程链

**场景**:
```
场景1：日志不完整
  [缺失根节点] ← NODE_MIDDLE ← NODE_CHILD
  
场景2：父节点不存在
  NODE_MIDDLE (parentProcessGuid: "MISSING_PARENT")
```

### 2.2 Explore虚拟根节点

当检测到断链时，自动创建虚拟根节点：

**单个断链**:
```
EXPLORE_ROOT (虚拟根节点, isRoot=true)
  └── BROKEN_NODE_1
      └── CHILD_1
```

**多个断链**:
```
EXPLORE_ROOT (统一的虚拟根节点)
  ├── BROKEN_NODE_1 (断链分支1)
  │   └── CHILD_1_1
  ├── BROKEN_NODE_2 (断链分支2)
  │   └── CHILD_2_1
  └── BROKEN_NODE_3 (断链分支3)
```

### 2.3 混合场景处理

**场景**: 多个traceId，部分有根节点，部分是断链

```
traceId=T001: [T001(真实根)] → [CHILD_1] → [CHILD_2]  ✅
traceId=T002: [EXPLORE_ROOT] → [BROKEN_NODE]          ✅

结果：2个根节点（1个真实 + 1个Explore）
```

**核心逻辑**:
```java
// 重要：只要有断链，就创建Explore
// 即使已经有真实根节点
if (brokenNodes != null && !brokenNodes.isEmpty()) {
    createExploreRootNode();  // 创建虚拟根节点
    connectBrokenNodesToExplore();  // 连接所有断链
}
```

---

## 3. 智能裁剪

### 3.1 为什么需要裁剪？

**问题**: 进程链节点过多（>400），前端渲染慢，数据传输大

**目标**: 
- 保留关键攻击路径
- 删除冗余节点
- 确保数据完整性

### 3.2 裁剪触发条件

```java
if (nodeCount > MAX_NODE_COUNT) {
    pruneNodes();  // 触发裁剪
}

// 默认阈值
MAX_NODE_COUNT = 400
MAX_TRAVERSE_DEPTH = 50
```

### 3.3 智能级联裁剪策略

**4步裁剪流程**:

#### 第1步：识别必须保留的节点
```
必须保留节点 (Must-Keep Nodes):
  1. 所有根节点
  2. 所有断链节点
  3. 所有网端关联告警节点（associatedEventIds）
  4. 所有高危/中危告警节点
```

#### 第2步：级联保留完整路径
```
从每个必须保留的节点开始，向上追溯到根节点
保留整条路径上的所有节点
```

**示例**:
```
原始链: ROOT → A → B → C → D → [ALARM_NODE] → E → F

必须保留: ROOT, ALARM_NODE
级联保留: ROOT → A → B → C → D → ALARM_NODE (完整路径)
可裁剪: E, F
```

#### 第3步：按分数选择剩余节点
```
如果还有剩余槽位，按节点重要性分数排序选择：

分数 = 告警分数 + 网端关联分数 + 子节点数分数
```

**节点评分细则**:

| 节点类型 | 基础分 | 额外加分 |
|---------|-------|---------|
| 根节点 | 1000 | - |
| 断链节点 | 900 | - |
| 网端关联告警 | 500 | +威胁等级分 |
| 高危告警 | 300 | - |
| 中危告警 | 200 | - |
| 低危告警 | 100 | - |
| 普通节点 | 10 | +子节点数×5 |

#### 第4步：验证和回滚
```
裁剪后验证:
  ✅ 所有根节点都存在
  ✅ 数据完整性（nodeMap不为空）
  ✅ 断链节点正确标记

如果验证失败 → 自动回滚到原始数据
```

### 3.4 安全机制

**3层安全保障**:

1. **备份机制**: 裁剪前备份原始数据
2. **验证机制**: 裁剪后验证数据完整性
3. **回滚机制**: 异常或验证失败时自动恢复

```java
// 伪代码
try {
    backup = createBackup(nodeMap, edges);
    pruneNodes();
    
    if (!validateAfterPruning()) {
        rollback(backup);  // 验证失败，回滚
    }
} catch (Exception e) {
    rollback(backup);  // 异常，回滚
}
```

---

## 4. 网端端侧合并

### 4.1 概述

**目标**: 合并网络侧攻击路径和端点侧详细进程链

```
网络侧 (Network Side):
  攻击者IP → 跳板机1 → 跳板机2 → 目标主机

端点侧 (Endpoint Side):
  目标主机内部的详细进程执行链
```

### 4.2 合并流程

```
Step 1: 准备网络侧数据
  - 网络侧节点 (List<ProcessNode>)
  - 网络侧边 (List<ProcessEdge>)

Step 2: 准备端点侧数据
  - IP映射关系 (IpMappingRelation)
    - alarmIps: Map<IP, EventId>
    - ipAndAssociation: Map<IP, Boolean>

Step 3: 构建端点侧进程链
  - 为每个IP构建进程链
  - 标记网端关联节点

Step 4: 合并
  - 找到根节点（IP关联的节点）
  - 将端点侧链连接到网络侧对应节点
```

### 4.3 IP映射关系

```java
IpMappingRelation {
    // IP → EventId 映射
    alarmIps: {
        "192.168.1.100": "EVENT_001",
        "192.168.1.101": "EVENT_002"
    },
    
    // IP → 是否网端关联
    ipAndAssociation: {
        "192.168.1.100": true,   // 有网端关联
        "192.168.1.101": false   // 无网端关联
    }
}
```

### 4.4 关联节点标记

网端关联的节点会被特殊标记：

```java
ProcessNode {
    nodeId: "ROOT_NODE",
    chainNode: {
        isNetworkAssociated: true,  // ✅ 网端关联标记
        associatedEventId: "EVENT_001"
    }
}
```

---

## 5. 告警选举

### 5.1 为什么需要告警选举？

**场景**: 一个主机可能产生多个告警组，需要选出最严重的组

```
IP: 192.168.1.100
  告警组1 (traceId: T001): 3个中危告警
  告警组2 (traceId: T002): 1个高危 + 2个中危
  告警组3 (traceId: T003): 5个低危告警

选举结果: 告警组2（威胁最严重）
```

### 5.2 选举算法

**多维度评分**:

```
告警组分数 = 高危数量×100 + 中危数量×50 + 低危数量×10
```

**比较规则**:
```
1. 比较高危告警数量（越多越严重）
2. 如果高危数量相同，比较中危告警数量
3. 如果中危数量相同，比较低危告警数量
4. 如果告警数量完全相同，比较告警总数
5. 如果总数相同，选择时间最早的组
```

### 5.3 代码示例

```java
// 计算告警组的威胁统计
ThreatStatistics stats = {
    highCount: 1,     // 高危数量
    mediumCount: 2,   // 中危数量
    lowCount: 0,      // 低危数量
    totalCount: 3     // 总数
}

// 比较两个告警组
int score = compareThreatStatistics(stats1, stats2);
// score > 0: stats1 更严重
// score < 0: stats2 更严重
// score = 0: 相同严重度
```

---

## 6. 多IP多traceId支持

### 6.1 单IP vs 多IP

**单IP场景**:
```
IP: 192.168.1.100
  traceId: T001
  进程链: [ROOT] → [CHILD_1] → [CHILD_2]
```

**多IP场景**:
```
IP1: 192.168.1.100
  traceId: T001
  进程链1: [T001] → [CHILD_1_1]

IP2: 192.168.1.101
  traceId: T002
  进程链2: [T002] → [CHILD_2_1]

IP3: 192.168.1.102
  traceId: T003
  进程链3: [T003] → [CHILD_3_1]
```

### 6.2 数据结构适配

**IncidentProcessChain 支持多值**:

```java
// 修改前（单个traceId）
{
    "traceId": "T001",
    "hostAddress": "192.168.1.100"
}

// 修改后（多个traceId）
{
    "traceIds": ["T001", "T002", "T003"],
    "hostAddresses": ["192.168.1.100", "192.168.1.101", "192.168.1.102"]
}
```

### 6.3 根节点识别优化

**原逻辑（错误）**:
```java
// 只用第一个traceId
if (processGuid == firstTraceId) {
    // 是根节点
}
// ❌ 问题：其他traceId的根节点被误判为断链
```

**新逻辑（正确）**:
```java
// 使用所有traceIds
if (traceIds.contains(processGuid)) {
    // 是根节点 ✅
}
```

### 6.4 根节点统计

```java
// 多个traceId，每个都应该有1个根节点
traceIds: [T001, T002, T003]
根节点数量: 3

// 验证
assertEquals(3, rootCount);
```

---

## 📊 性能指标

### 典型场景性能

| 场景 | 节点数 | 处理时间 | 内存占用 |
|------|-------|---------|---------|
| 小规模 | <50 | <100ms | <50MB |
| 中规模 | 50-200 | <500ms | <100MB |
| 大规模 | 200-400 | <2s | <500MB |
| 超大规模（裁剪前） | >400 | <3s | <1GB |
| 超大规模（裁剪后） | 400 | <3s | <800MB |

---

## 🔗 相关文档

- [快速开始](01-快速开始.md) - 5分钟上手
- [API文档](03-API文档.md) - 接口详情
- [项目详细说明](../项目详细说明文档.md) - 完整设计
- [测试指南](guides/测试指南.md) - 测试方法

---

**最后更新**: 2025-10-22


