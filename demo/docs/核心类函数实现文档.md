# 核心类函数实现文档

本文档详细说明项目中主要类的每个函数的实现逻辑，便于代码理解和维护。

---

## 目录

1. [ProcessChainServiceImpl - 进程链服务实现](#1-processchainserviceimpl)
2. [ProcessChainBuilder - 进程链构建器](#2-processchainbuilder)
3. [OptimizedESQueryService - 优化ES查询服务](#3-optimizedesqueryservice)
4. [AlarmElectionUtil - 告警选举工具](#4-alarmelectionutil)
5. [IncidentConverters - 事件转换器](#5-incidentconverters)
6. [TimeUtil - 时间工具类](#6-timeutil)
7. [NodeType - 节点类型枚举](#7-nodetype-枚举)

---

## 1. ProcessChainServiceImpl

**文件路径**: `src/main/java/com/security/processchain/service/impl/ProcessChainServiceImpl.java`

**职责**: 进程链服务的核心实现类，负责协调各个组件完成进程链的生成

### 1.1 generateProcessChains()

**功能**: 为多个IP批量生成进程链并合并

**核心步骤**:

```java
public IncidentProcessChain generateProcessChains(IpMappingRelation ipMappingRelation)
```

**执行流程**:

1. **参数校验**
   - 检查 `ipMappingRelation` 是否为空
   - 检查 IP 列表是否为空

2. **阶段1: 批量查询告警**
   ```java
   // 使用 MultiSearchRequest 批量查询所有 IP 的告警
   Map<String, List<RawAlarm>> allAlarmsMap = esQueryService.batchQueryEDRAlarms(ips);
   ```
   - 一次性查询所有 IP 的告警数据
   - 减少网络往返次数，提升性能

3. **阶段2: 告警选举**
   ```java
   for (String ip : ips) {
       // 检查是否有网端关联
       boolean hasAssociation = ipMappingRelation.hasAssociation(ip);
       String associatedEventId = ipMappingRelation.getAssociatedEventId(ip);
       
       // 选择告警（优先网端关联，否则选举）
       RawAlarm selectedAlarm = selectAlarm(alarms, associatedEventId, hasAssociation);
       
       // 收集选中的告警
       allSelectedAlarms.add(selectedAlarm);
       
       // 建立 host -> traceId 映射
       hostToTraceId.put(selectedAlarm.getHostAddress(), selectedAlarm.getTraceId());
   }
   ```
   - 为每个 IP 选择最相关的告警
   - 如果有网端关联，优先选择关联告警
   - 否则使用选举算法选择威胁等级最高的告警组

4. **阶段3: 批量查询日志**
   ```java
   // 使用 host->traceId 映射批量查询日志
   allLogs = esQueryService.batchQueryRawLogs(hostToTraceId);
   ```
   - 每个 host 查询其对应 traceId 的日志
   - 使用 MultiSearchRequest 批量执行

5. **阶段4: 构建进程链**
   ```java
   ProcessChainBuilder builder = new ProcessChainBuilder();
   IncidentProcessChain incidentChain = builder.buildIncidentChain(
       allSelectedAlarms, allLogs, firstTraceId, null,
       IncidentConverters.NODE_MAPPER, IncidentConverters.EDGE_MAPPER
   );
   ```
   - 直接构建最终的 `IncidentProcessChain` 对象
   - 使用转换器将内部节点/边转换为最终模型

**性能优化点**:
- 批量查询减少 ES 查询次数
- 使用 MultiSearchRequest 并行查询
- 一次性处理所有 IP 的数据

---

### 1.2 generateProcessChainForIp()

**功能**: 为单个IP生成进程链

**核心步骤**:

```java
public IncidentProcessChain generateProcessChainForIp(String ip, String associatedEventId, boolean hasAssociation)
```

**执行流程**:

1. **查询告警**
   ```java
   List<RawAlarm> alarms = esQueryService.queryEDRAlarms(ip);
   ```

2. **选择告警**
   ```java
   RawAlarm selectedAlarm = selectAlarm(alarms, associatedEventId, hasAssociation);
   ```

3. **查询日志**
   ```java
   List<RawLog> logs = queryLogsForAlarm(selectedAlarm);
   ```
   - 查询告警对应的 traceId 的日志
   - 时间窗口为告警时间 + 24小时

4. **构建进程链**
   ```java
   IncidentProcessChain incidentChain = builder.buildIncidentChain(
       Arrays.asList(selectedAlarm), logs, selectedAlarm.getTraceId(), associatedEventId,
       IncidentConverters.NODE_MAPPER, IncidentConverters.EDGE_MAPPER
   );
   ```

5. **设置基本信息**
   ```java
   incidentChain.setTraceId(selectedAlarm.getTraceId());
   incidentChain.setHostAddress(selectedAlarm.getHostAddress());
   ```

---

### 1.3 selectAlarm()

**功能**: 选择最合适的告警

**选择策略**:

```java
private RawAlarm selectAlarm(List<RawAlarm> alarms, String associatedEventId, boolean hasAssociation)
```

**决策流程**:

```
1. 有网端关联且指定了 eventId？
   ├─ YES → 查找匹配的告警
   │         ├─ 找到 → 返回该告警
   │         └─ 未找到 → 降级到选举算法
   └─ NO → 使用选举算法

2. 选举算法：
   ├─ 按 traceId 分组
   ├─ 使用 AlarmElectionUtil.electAlarm() 选举
   │  └─ 选择威胁等级最高的组
   └─ 返回选中组的第一个告警
```

---

### 1.4 queryLogsForAlarm()

**功能**: 查询告警相关的日志

**执行流程**:

```java
private List<RawLog> queryLogsForAlarm(RawAlarm alarm)
```

1. **计算时间窗口**
   ```java
   String timeStart = alarm.getStartTime();
   String timeEnd = calculateEndTime(timeStart);  // +24小时
   ```

2. **定义关注的日志类型**
   ```java
   List<String> logTypes = ProcessChainConstants.LogType.ALL_MONITORED_TYPES;
   // ["进程创建", "进程结束", "文件创建", "文件修改", "文件删除",
   //  "网络连接", "域名解析", "注册表操作"]
   ```

3. **查询ES**
   ```java
   return esQueryService.queryRawLogs(
       alarm.getTraceId(),
       alarm.getHostAddress(),
       timeStart,
       timeEnd,
       logTypes
   );
   ```

---

### 1.5 mergeNetworkAndEndpointChain()

**功能**: 合并网侧和端侧的进程链

**执行流程**:

```java
public IncidentProcessChain mergeNetworkAndEndpointChain(
    List<ProcessChainBuilder.ProcessNode> networkNodes,
    List<ProcessChainBuilder.ProcessEdge> networkEdges,
    ProcessChainBuilder.ProcessChainResult endpointChainResult)
```

1. **收集所有节点和边**
   ```java
   List<ProcessChainBuilder.ProcessNode> allNodes = new ArrayList<>();
   List<ProcessChainBuilder.ProcessEdge> allEdges = new ArrayList<>();
   
   // 添加网侧节点（storyNode）
   allNodes.addAll(networkNodes);
   
   // 添加端侧节点（chainNode）
   allNodes.addAll(endpointChainResult.getNodes());
   
   // 添加网侧边
   allEdges.addAll(networkEdges);
   
   // 添加端侧边
   allEdges.addAll(endpointChainResult.getEdges());
   ```

2. **转换为最终模型**
   ```java
   for (ProcessChainBuilder.ProcessNode node : allNodes) {
       finalNodes.add(IncidentConverters.NODE_MAPPER.toIncidentNode(node));
   }
   
   for (ProcessChainBuilder.ProcessEdge edge : allEdges) {
       finalEdges.add(IncidentConverters.EDGE_MAPPER.toIncidentEdge(edge));
   }
   ```

3. **设置到结果对象**
   ```java
   mergedChain.setNodes(finalNodes);
   mergedChain.setEdges(finalEdges);
   ```

---

## 2. ProcessChainBuilder

**文件路径**: `src/main/java/com/security/processchain/service/ProcessChainBuilder.java`

**职责**: 根据告警和日志构建进程链的核心算法实现

### 2.1 buildProcessChain()

**功能**: 构建进程链（返回内部结构）

**核心步骤**:

```java
public ProcessChainResult buildProcessChain(List<RawAlarm> alarms, List<RawLog> logs, 
                                            String traceId, String associatedEventId)
```

**执行流程**:

1. **日志索引**
   ```java
   // 按 processGuid 索引（查找进程的日志）
   Map<String, List<RawLog>> logsByProcessGuid = indexLogsByProcessGuid(logs);
   
   // 按 parentProcessGuid 索引（查找子进程）
   Map<String, List<RawLog>> logsByParentProcessGuid = indexLogsByParentProcessGuid(logs);
   ```
   - 建立快速查找索引
   - 避免每次遍历所有日志

2. **遍历告警，构建进程树**
   ```java
   for (RawAlarm alarm : alarms) {
       String severity = alarm.getThreatSeverity();
       
       if (isHighThreat(severity)) {
           // 高危告警：双向遍历（向上找父进程，向下找子进程）
           buildBidirectionalChain(alarm, logsByProcessGuid, logsByParentProcessGuid, traceId);
       } else {
           // 中低危告警：只向上遍历
           buildUpwardChain(alarm, logsByProcessGuid, traceId);
       }
   }
   ```

3. **节点裁剪（如果超过限制）**
   ```java
   if (nodeMap.size() > MAX_NODE_COUNT) {
       pruneNodes();  // 保留重要节点，移除不重要的
   }
   ```

4. **返回结果**
   ```java
   ProcessChainResult result = new ProcessChainResult();
   result.setNodes(new ArrayList<>(nodeMap.values()));
   result.setEdges(edges);
   result.setRootNodes(new HashSet<>(rootNodes));      // 根节点集合
   result.setBrokenNodes(new HashSet<>(brokenNodes));  // 断裂节点集合
   return result;
   ```

**重要说明**:
- **节点合并**是自动完成的：在 `addAlarmNode()` 和 `addLogNode()` 中，通过 `nodeMap.get(processGuid)` 检查节点是否已存在
- 如果节点已存在，直接向其添加告警/日志；如果不存在，则创建新节点
- 这种设计保证了相同 `processGuid` 的告警和日志会被自动合并到同一个节点中

**根节点判断标准**:
- **根节点的 `processGuid` 等于 `traceId`**（这是识别根节点的核心标准）
- 在构建过程中，每个 IP/traceId 都应该找到自己的根节点
- 根节点标记：`ChainNode.isRoot = true`

**断裂节点处理**:
- **断链判断**：当前节点的 `parentProcessGuid` 在原始日志（`logsByProcessGuid`）中不存在
- **一条单链只能有一次断链**：发现断链后立即停止向上追溯
- 断裂节点标记：`ChainNode.isBroken = true`
- 系统会自动为断裂节点添加 `explore` 节点（占位节点），表示链条在此处中断

---

### 2.2 buildBidirectionalChain()

**功能**: 双向遍历构建进程链（高危告警使用）

**算法流程**:

```java
private void buildBidirectionalChain(RawAlarm alarm, 
                                    Map<String, List<RawLog>> logsByProcessGuid,
                                    Map<String, List<RawLog>> logsByParentProcessGuid,
                                    String traceId)
```

**执行步骤**:

```
1. 添加告警节点
   ↓
2. 向上遍历（找父进程链）
   processGuid → parentProcessGuid → parentParentProcessGuid → ...
   ├─ 深度限制: MAX_TRAVERSE_DEPTH (50)
   ├─ 环检测: 防止死循环
   └─ 到达根节点（parentProcessGuid为空）停止
   ↓
3. 向下遍历（找子进程树）
   processGuid → childProcesses → grandchildProcesses → ...
   ├─ 深度限制: MAX_TRAVERSE_DEPTH (50)
   ├─ 环检测: 防止死循环
   └─ 叶子节点停止
```

**关键逻辑**:

```java
// 向上遍历
private void traverseUpward(String currentProcessGuid, ..., int depth) {
    // 1. 检查深度限制
    if (depth >= MAX_TRAVERSE_DEPTH) return;
    
    // 2. 检查环
    if (visitedNodesInPath.contains(currentProcessGuid)) return;
    
    // 3. 添加到访问集合
    visitedNodesInPath.add(currentProcessGuid);
    
    // 4. 查找当前进程的日志
    List<RawLog> currentLogs = logsByProcessGuid.get(currentProcessGuid);
    
    // 5. 创建节点并添加日志
    ProcessNode node = getOrCreateNode(currentProcessGuid, traceId);
    node.addLogs(currentLogs);
    
    // 6. 如果是根节点，标记
    if (parentProcessGuid == null || parentProcessGuid.isEmpty()) {
        rootNodes.add(currentProcessGuid);
        foundRootNode = true;
        return;
    }
    
    // 7. 添加边：parent -> current
    addEdge(parentProcessGuid, currentProcessGuid);
    
    // 8. 递归向上遍历父进程
    traverseUpward(parentProcessGuid, ..., depth + 1);
}
```

---

### 2.3 buildUpwardChain()

**功能**: 向上遍历构建进程链（中低危告警使用）

**与 buildBidirectionalChain 的区别**:
- 只向上找父进程链
- 不向下查找子进程
- 性能更好，适合中低危告警

---

### 2.4 mergeNodes()

**功能**: 合并相同 processGuid 的节点

**合并逻辑**:

```java
private void mergeNodes() {
    // 遍历所有节点
    for (ProcessNode node : nodeMap.values()) {
        // 1. 合并告警列表（去重）
        Set<String> eventIds = new HashSet<>();
        List<RawAlarm> mergedAlarms = new ArrayList<>();
        for (RawAlarm alarm : node.getAlarms()) {
            if (eventIds.add(alarm.getEventId())) {
                mergedAlarms.add(alarm);
            }
        }
        
        // 2. 合并日志列表（去重）
        Set<String> logIds = new HashSet<>();
        List<RawLog> mergedLogs = new ArrayList<>();
        for (RawLog log : node.getLogs()) {
            String logId = generateLogId(log);
            if (logIds.add(logId)) {
                mergedLogs.add(log);
            }
        }
        
        // 3. 更新节点
        node.setAlarms(mergedAlarms);
        node.setLogs(mergedLogs);
    }
}
```

---

### 2.5 pruneNodes()

**功能**: 裁剪节点（当节点数超过限制时）

**裁剪策略**:

```java
private void pruneNodes() {
    // 1. 计算每个节点的重要性分数
    Map<String, Integer> nodeScores = new HashMap<>();
    for (ProcessNode node : nodeMap.values()) {
        int score = calculateNodeImportance(node);
        nodeScores.put(node.getProcessGuid(), score);
    }
    
    // 2. 按分数排序
    List<Map.Entry<String, Integer>> sortedNodes = new ArrayList<>(nodeScores.entrySet());
    sortedNodes.sort((a, b) -> b.getValue().compareTo(a.getValue()));
    
    // 3. 保留前 MAX_NODE_COUNT 个节点
    Set<String> nodesToKeep = new HashSet<>();
    for (int i = 0; i < Math.min(MAX_NODE_COUNT, sortedNodes.size()); i++) {
        nodesToKeep.add(sortedNodes.get(i).getKey());
    }
    
    // 4. 移除不重要的节点
    nodeMap.keySet().retainAll(nodesToKeep);
    
    // 5. 清理无效的边
    edges.removeIf(edge -> 
        !nodeMap.containsKey(edge.getSource()) || 
        !nodeMap.containsKey(edge.getTarget())
    );
}
```

**重要性评分算法**:

```java
private int calculateNodeImportance(ProcessNode node) {
    int score = 0;
    
    // 1. 告警节点 +100 分
    if (node.getAlarms() != null && !node.getAlarms().isEmpty()) {
        score += 100;
        
        // 高危告警 +50 分
        for (RawAlarm alarm : node.getAlarms()) {
            if (isHighThreat(alarm.getThreatSeverity())) {
                score += 50;
            }
        }
    }
    
    // 2. 根节点 +30 分
    if (rootNodes.contains(node.getProcessGuid())) {
        score += 30;
    }
    
    // 3. 网端关联 +50 分
    if (associatedEventIds.contains(node.getEventId())) {
        score += 50;
    }
    
    // 4. 子节点数量（每个 +5 分，最多 +50 分）
    int childCount = countChildren(node.getProcessGuid());
    score += Math.min(childCount * 5, 50);
    
    // 5. 日志数量（每个 +1 分，最多 +20 分）
    if (node.getLogs() != null) {
        score += Math.min(node.getLogs().size(), 20);
    }
    
    return score;
}
```

---

### 2.6 buildIncidentChain()

**功能**: 直接构建最终的 IncidentProcessChain（便捷方法）

```java
public IncidentProcessChain buildIncidentChain(
    List<RawAlarm> alarms, List<RawLog> logs, String traceId, String associatedEventId,
    NodeMapper nodeMapper, EdgeMapper edgeMapper)
```

**执行流程**:

```java
// 1. 构建内部结构
ProcessChainResult result = buildProcessChain(alarms, logs, traceId, associatedEventId);

// 2. 获取根节点和断裂节点集合
Set<String> rootNodeGuids = result.getRootNodes();
Set<String> brokenNodeGuids = result.getBrokenNodes();

// 3. 转换节点为最终模型
List<ProcessNode> finalNodes = new ArrayList<>();
for (ProcessChainBuilder.ProcessNode node : result.getNodes()) {
    // 判断当前节点是否是根节点或断裂节点
    boolean isRoot = rootNodeGuids.contains(node.getProcessGuid());
    boolean isBroken = brokenNodeGuids.contains(node.getProcessGuid());
    
    // 转换节点
    ProcessNode finalNode = nodeMapper.toIncidentNode(node);
    
    // 设置 isRoot 和 isBroken 标记
    if (finalNode.getChainNode() != null) {
        finalNode.getChainNode().setIsRoot(isRoot);
        finalNode.getChainNode().setIsBroken(isBroken);
    }
    
    finalNodes.add(finalNode);
}

// 4. 转换边
List<ProcessEdge> finalEdges = new ArrayList<>();
for (ProcessChainBuilder.ProcessEdge edge : result.getEdges()) {
    finalEdges.add(edgeMapper.toIncidentEdge(edge));
}

// 5. 为断裂节点添加 explore 节点
if (!brokenNodeGuids.isEmpty()) {
    addExploreNodesForBrokenChains(finalNodes, finalEdges, brokenNodeGuids, rootNodeGuids);
}

// 6. 设置到结果对象
chain.setNodes(finalNodes);
chain.setEdges(finalEdges);

return chain;
```

**关键处理**:
- **根节点标记**: 根据 `result.getRootNodes()` 自动标记 `isRoot=true`
- **断裂节点标记**: 根据 `result.getBrokenNodes()` 自动标记 `isBroken=true`
- **Explore 节点**: 为每个断裂节点自动创建一个 `explore` 占位节点

---

### 2.7 addExploreNodesForBrokenChains()

**功能**: 为断裂的进程链添加 explore 占位节点

```java
private void addExploreNodesForBrokenChains(
    List<ProcessNode> finalNodes, List<ProcessEdge> finalEdges,
    Set<String> brokenNodes, Set<String> rootNodes)
```

**为什么需要 Explore 节点？**

当向上遍历进程链时，如果遇到以下情况：
- 当前节点的 `parentProcessGuid` 在原始日志（`logsByProcessGuid`）中不存在
- 即：父进程不在采集到的日志数据中

这说明进程链在此处"断裂"了（可能是日志采集不完整、时间窗口限制等原因）。

**断链后的处理**：
1. 将当前节点标记为 `isBroken=true`
2. **立即停止向上追溯**（一条单链只能有一次断链）
3. 创建一个 `explore` 类型的占位节点
4. 添加一条边：`explore节点 → 断裂节点`

**执行逻辑**:

```java
for (String brokenNodeGuid : brokenNodes) {
    // 1. 创建 explore 节点
    String exploreNodeId = "explore_" + brokenNodeGuid;
    ProcessNode exploreNode = new ProcessNode();
    exploreNode.setNodeId(exploreNodeId);
    exploreNode.setIsChainNode(true);
    exploreNode.setLogType(NodeType.EXPLORE);  // 节点类型为 EXPLORE
    
    ChainNode exploreChainNode = new ChainNode();
    exploreChainNode.setIsRoot(false);
    exploreChainNode.setIsBroken(false);
    exploreChainNode.setIsAlarm(false);
    exploreNode.setChainNode(exploreChainNode);
    
    // 2. 添加 explore 节点
    finalNodes.add(exploreNode);
    
    // 3. 创建边：explore → 断裂节点
    ProcessEdge exploreEdge = new ProcessEdge();
    exploreEdge.setSource(exploreNodeId);
    exploreEdge.setTarget(brokenNodeGuid);
    exploreEdge.setVal("1");
    finalEdges.add(exploreEdge);
}
```

**示例场景**:

```
场景：进程链向上遍历到 process_123，但找不到其父进程的日志

原始链（断裂）:
  [process_123] ----X----  （父进程找不到）

添加 explore 节点后:
  [explore_process_123] → [process_123] → [子进程...]
   (占位节点，标识链断裂)   (isBroken=true)
```

---

## 3. OptimizedESQueryService

**文件路径**: `src/main/java/com/security/processchain/service/OptimizedESQueryService.java`

**职责**: 优化的 Elasticsearch 查询服务，使用批量查询减少网络开销

### 3.1 batchQueryEDRAlarms()

**功能**: 批量查询多个 IP 的 EDR 告警

**性能优化**:

```java
public Map<String, List<RawAlarm>> batchQueryEDRAlarms(List<String> hostAddresses)
```

**执行流程**:

1. **创建 MultiSearchRequest**
   ```java
   MultiSearchRequest multiSearchRequest = new MultiSearchRequest();
   ```

2. **为每个 IP 创建查询请求**
   ```java
   for (String hostAddress : hostAddresses) {
       SearchRequest searchRequest = new SearchRequest(alarmIndex);
       SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
       
       // 使用 filter 查询（不计算评分，可缓存）
       BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
       boolQuery.filter(QueryBuilders.termQuery("hostAddress", hostAddress));
       boolQuery.filter(QueryBuilders.termQuery("alarmSource", "EDR"));
       
       searchSourceBuilder.query(boolQuery);
       searchSourceBuilder.size(maxQuerySize);
       searchRequest.source(searchSourceBuilder);
       
       multiSearchRequest.add(searchRequest);
   }
   ```

3. **一次性执行所有查询**
   ```java
   MultiSearchResponse multiSearchResponse = esClient.msearch(multiSearchRequest, RequestOptions.DEFAULT);
   ```
   - 减少网络往返次数
   - ES 内部并行处理

4. **处理结果**
   ```java
   MultiSearchResponse.Item[] responses = multiSearchResponse.getResponses();
   for (int i = 0; i < responses.length; i++) {
       String hostAddress = hostAddresses.get(i);
       MultiSearchResponse.Item item = responses[i];
       
       if (item.isFailure()) {
           log.error("查询失败 [{}]: {}", hostAddress, item.getFailureMessage());
           resultMap.put(hostAddress, new ArrayList<>());
           continue;
       }
       
       SearchResponse searchResponse = item.getResponse();
       List<RawAlarm> alarms = DataConverter.convertToAlarmList(extractHits(searchResponse));
       resultMap.put(hostAddress, alarms);
   }
   ```

**性能对比**:
- **优化前**: N 个 IP = N 次查询 = N 次网络往返
- **优化后**: N 个 IP = 1 次查询 = 1 次网络往返

---

### 3.2 batchQueryRawLogs() - 方法1

**功能**: 批量查询日志（使用 host->traceId 映射）

```java
public List<RawLog> batchQueryRawLogs(Map<String, String> hostToTraceId)
```

**适用场景**: 每个 host 对应一个 traceId

**执行流程**:

1. **为每个映射创建查询**
   ```java
   for (Map.Entry<String, String> entry : hostToTraceId.entrySet()) {
       String hostAddress = entry.getKey();
       String traceId = entry.getValue();
       
       // 构建查询：traceId + hostAddress
       BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
       boolQuery.filter(QueryBuilders.termQuery("traceId", traceId));
       boolQuery.filter(QueryBuilders.termQuery("hostAddress", hostAddress));
       
       multiSearchRequest.add(searchRequest);
   }
   ```

2. **批量执行并收集结果**
   ```java
   MultiSearchResponse multiSearchResponse = esClient.msearch(multiSearchRequest, RequestOptions.DEFAULT);
   
   for (MultiSearchResponse.Item item : responses) {
       List<RawLog> logs = DataConverter.convertToLogList(extractHits(item.getResponse()));
       allLogs.addAll(logs);
   }
   ```

---

### 3.3 batchQueryRawLogs() - 方法2

**功能**: 批量查询日志（支持时间和类型过滤）

```java
public Map<String, List<RawLog>> batchQueryRawLogs(
    List<String> traceIds, String hostAddress,
    String timeStart, String timeEnd, List<String> logTypes)
```

**适用场景**: 查询特定时间范围和日志类型的数据

**查询条件**:

```java
BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
boolQuery.filter(QueryBuilders.termQuery("traceId", traceId));
boolQuery.filter(QueryBuilders.termQuery("hostAddress", hostAddress));

// 时间范围过滤
if (timeStart != null && timeEnd != null) {
    boolQuery.filter(QueryBuilders.rangeQuery("startTime")
        .gte(timeStart)
        .lte(timeEnd));
}

// 日志类型过滤
if (logTypes != null && !logTypes.isEmpty()) {
    boolQuery.filter(QueryBuilders.termsQuery("logType", logTypes));
}
```

---

### 3.4 性能优化技巧

**1. 使用 filter 而非 must**
```java
// ❌ 错误（计算评分，慢）
BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
boolQuery.must(QueryBuilders.termQuery("hostAddress", hostAddress));

// ✅ 正确（不计算评分，快，可缓存）
BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
boolQuery.filter(QueryBuilders.termQuery("hostAddress", hostAddress));
```

**2. 合理设置查询大小**
```java
searchSourceBuilder.size(maxQuerySize);  // 默认 10000
```

**3. 使用 MultiSearchRequest 批量查询**
```java
// ❌ 错误
for (String ip : ips) {
    SearchResponse response = esClient.search(request, RequestOptions.DEFAULT);
}

// ✅ 正确
MultiSearchRequest multiRequest = new MultiSearchRequest();
for (String ip : ips) {
    multiRequest.add(request);
}
MultiSearchResponse response = esClient.msearch(multiRequest, RequestOptions.DEFAULT);
```

---

## 4. AlarmElectionUtil

**文件路径**: `src/main/java/com/security/processchain/util/AlarmElectionUtil.java`

**职责**: 告警选举算法实现

### 4.1 electAlarm()

**功能**: 从多个告警组中选举出最佳 traceId

```java
public static String electAlarm(Map<String, List<RawAlarm>> alarmGroups)
```

**选举算法**:

```java
// 1. 过滤空组
Map<String, List<RawAlarm>> validGroups = filterEmptyGroups(alarmGroups);

// 2. 只有一个组？直接返回
if (validGroups.size() == 1) {
    return validGroups.keySet().iterator().next();
}

// 3. 计算每个组的威胁统计
Map<String, ThreatStatistics> groupStats = new HashMap<>();
for (Map.Entry<String, List<RawAlarm>> entry : validGroups.entrySet()) {
    ThreatStatistics stats = calculateThreatStatistics(entry.getValue());
    groupStats.put(entry.getKey(), stats);
}

// 4. 选举最优组
String bestGroupKey = null;
ThreatStatistics bestStats = null;

for (Map.Entry<String, ThreatStatistics> entry : groupStats.entrySet()) {
    if (bestStats == null || compareThreatStatistics(entry.getValue(), bestStats) > 0) {
        bestStats = entry.getValue();
        bestGroupKey = entry.getKey();
    }
}

return bestGroupKey;
```

---

### 4.2 calculateThreatStatistics()

**功能**: 计算告警组的威胁等级统计

```java
private static ThreatStatistics calculateThreatStatistics(List<RawAlarm> alarms)
```

**统计逻辑**:

```java
ThreatStatistics stats = new ThreatStatistics();

for (RawAlarm alarm : alarms) {
    String severity = alarm.getThreatSeverity();
    
    if ("HIGH".equalsIgnoreCase(severity) || "高".equals(severity)) {
        stats.highCount++;
    } else if ("MEDIUM".equalsIgnoreCase(severity) || "中".equals(severity)) {
        stats.mediumCount++;
    } else if ("LOW".equalsIgnoreCase(severity) || "低".equals(severity)) {
        stats.lowCount++;
    }
}

return stats;
```

**ThreatStatistics 数据结构**:

```java
private static class ThreatStatistics {
    int highCount = 0;    // 高危数量
    int mediumCount = 0;  // 中危数量
    int lowCount = 0;     // 低危数量
}
```

---

### 4.3 compareThreatStatistics()

**功能**: 比较两个威胁统计（决定哪个组更重要）

```java
private static int compareThreatStatistics(ThreatStatistics stats1, ThreatStatistics stats2)
```

**比较策略**（优先级递减）:

```java
// 1. 第一优先级: 比较高危数量
if (stats1.highCount != stats2.highCount) {
    return stats1.highCount - stats2.highCount;  // 高危越多越重要
}

// 2. 第二优先级: 比较中危数量
if (stats1.mediumCount != stats2.mediumCount) {
    return stats1.mediumCount - stats2.mediumCount;
}

// 3. 第三优先级: 比较低危数量
if (stats1.lowCount != stats2.lowCount) {
    return stats1.lowCount - stats2.lowCount;
}

// 4. 完全相同
return 0;
```

**返回值含义**:
- `> 0`: stats1 更重要
- `< 0`: stats2 更重要
- `= 0`: 平局

**示例**:

```
组A: 高危=3, 中危=2, 低危=1
组B: 高危=2, 中危=5, 低危=3

比较: 高危 3 vs 2 → 组A 胜出（高危数量更多）

组C: 高危=3, 中危=2, 低危=1
组D: 高危=3, 中危=4, 低危=0

比较: 高危 3 vs 3（平局）→ 中危 2 vs 4 → 组D 胜出
```

---

## 5. IncidentConverters

**文件路径**: `src/main/java/com/security/processchain/service/IncidentConverters.java`

**职责**: 提供从 Builder 内部节点/边到最终模型的转换逻辑

### 5.1 NODE_MAPPER

**功能**: 将 `ProcessChainBuilder.ProcessNode` 转换为 `com.security.processchain.model.ProcessNode`

```java
public static final NodeMapper NODE_MAPPER = builderNode -> {
    ProcessNode finalNode = new ProcessNode();
    finalNode.setNodeId(builderNode.getProcessGuid());
    finalNode.setIsChainNode(true);

    ChainNode chainNode = new ChainNode();

    // 1. 获取告警和日志
    List<RawAlarm> alarms = builderNode.getAlarms();
    List<RawLog> logs = builderNode.getLogs();

    // 2. 判断是否为告警节点
    boolean isAlarm = alarms != null && !alarms.isEmpty();
    chainNode.setIsAlarm(isAlarm);

    // 3. 判断是否为根节点
    boolean isRoot = builderNode.getParentProcessGuid() == null || 
                     builderNode.getParentProcessGuid().trim().isEmpty();
    chainNode.setIsRoot(isRoot);
    chainNode.setIsBroken(false);

    // 4. 如果是告警节点，填充告警信息
    if (isAlarm) {
        RawAlarm latestAlarm = getLatestAlarm(alarms);
        if (latestAlarm != null) {
            AlarmNodeInfo alarmInfo = convertToAlarmNodeInfo(latestAlarm);
            chainNode.setAlarmNodeInfo(alarmInfo);
            finalNode.setNodeThreatSeverity(mapToThreatSeverity(latestAlarm.getThreatSeverity()));
        }
    }

    // 5. 填充日志信息
    if (logs != null && !logs.isEmpty()) {
        RawLog latestLog = getLatestLog(logs);
        if (latestLog != null && latestLog.getLogType() != null) {
            finalNode.setLogType(mapToNodeType(latestLog.getLogType()));
            chainNode.setProcessEntity(convertToProcessEntity(latestLog));
            chainNode.setEntity(convertToEntity(latestLog, latestLog.getLogType()));
        }
    } else if (isAlarm && alarms != null && !alarms.isEmpty()) {
        // 如果没有日志但有告警，从告警中获取 logType
        RawAlarm firstAlarm = alarms.get(0);
        if (firstAlarm != null && firstAlarm.getLogType() != null) {
            finalNode.setLogType(mapToNodeType(firstAlarm.getLogType()));
        }
    }

    finalNode.setChainNode(chainNode);
    finalNode.setStoryNode(null);
    return finalNode;
};
```

**转换流程图**:

```
ProcessChainBuilder.ProcessNode
  ├─ processGuid → nodeId
  ├─ alarms → ChainNode.isAlarm, ChainNode.alarmNodeInfo
  ├─ logs → ChainNode.processEntity, ChainNode.entity
  ├─ parentProcessGuid → ChainNode.isRoot
  └─ 返回 → com.security.processchain.model.ProcessNode
```

---

### 5.2 EDGE_MAPPER

**功能**: 将 `ProcessChainBuilder.ProcessEdge` 转换为 `com.security.processchain.model.ProcessEdge`

```java
public static final EdgeMapper EDGE_MAPPER = builderEdge -> {
    ProcessEdge finalEdge = new ProcessEdge();
    finalEdge.setSource(builderEdge.getSource());
    finalEdge.setTarget(builderEdge.getTarget());
    finalEdge.setVal(builderEdge.getVal());
    return finalEdge;
};
```

---

### 5.3 辅助转换方法

#### getLatestAlarm()
```java
/**
 * 选择时间最近的告警
 */
private static RawAlarm getLatestAlarm(List<RawAlarm> alarms) {
    RawAlarm latest = null;
    for (RawAlarm alarm : alarms) {
        if (alarm == null) continue;
        if (latest == null || 
            (alarm.getStartTime() != null && 
             alarm.getStartTime().compareTo(latest.getStartTime()) > 0)) {
            latest = alarm;
        }
    }
    return latest;
}
```

#### getLatestLog()
```java
/**
 * 选择时间最近的日志
 */
private static RawLog getLatestLog(List<RawLog> logs) {
    // 实现同 getLatestAlarm()
}
```

#### convertToAlarmNodeInfo()
```java
/**
 * 将原始告警转换为 AlarmNodeInfo
 */
private static AlarmNodeInfo convertToAlarmNodeInfo(RawAlarm alarm) {
    AlarmNodeInfo alarmInfo = new AlarmNodeInfo();
    alarmInfo.setAlarmName(alarm.getAlarmName());
    alarmInfo.setThreatSeverity(mapToThreatSeverity(alarm.getThreatSeverity()));
    
    // 从 otherFields 中获取其他告警信息
    if (alarm.getOtherFields() != null) {
        Map<String, Object> fields = alarm.getOtherFields();
        alarmInfo.setDvcAction(getString(fields, "dvcAction"));
        alarmInfo.setAlarmDescription(getString(fields, "alarmDescription"));
        alarmInfo.setAlarmSource(getString(fields, "alarmSource"));
        alarmInfo.setAlarmResults(getString(fields, "alarmResults"));
    }
    
    return alarmInfo;
}
```

#### mapToThreatSeverity()
```java
/**
 * 将字符串威胁等级映射为枚举（支持中文/英文）
 */
private static ThreatSeverity mapToThreatSeverity(String severity) {
    if (severity == null) return ThreatSeverity.UNKNOWN;
    
    String s = severity.trim();
    if ("高".equals(s) || "HIGH".equalsIgnoreCase(s)) {
        return ThreatSeverity.HIGH;
    }
    if ("中".equals(s) || "MEDIUM".equalsIgnoreCase(s)) {
        return ThreatSeverity.MEDIUM;
    }
    if ("低".equals(s) || "LOW".equalsIgnoreCase(s)) {
        return ThreatSeverity.LOW;
    }
    return ThreatSeverity.UNKNOWN;
}
```

#### mapToNodeType()
```java
/**
 * 将字符串 logType 映射为 NodeType 枚举
 */
private static NodeType mapToNodeType(String logType) {
    if (logType == null) return NodeType.UNKNOWN;
    
    String t = logType.trim().toLowerCase();
    switch (t) {
        case "process": return NodeType.PROCESS;
        case "file": return NodeType.FILE;
        case "network": return NodeType.NETWORK;
        case "domain": return NodeType.DOMAIN;
        default: return NodeType.UNKNOWN;
    }
}
```

---

## 6. TimeUtil

**文件路径**: `src/main/java/com/security/processchain/util/TimeUtil.java`

**职责**: 时间处理工具类（线程安全）

### 6.1 线程安全设计

```java
// ✅ 线程安全（DateTimeFormatter 是不可变的）
private static final DateTimeFormatter DATE_TIME_FORMATTER = 
    DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
```

### 6.2 addHours()

**功能**: 在指定时间上增加小时数

```java
public static String addHours(String timeStr, int hours)
```

**实现**:

```java
public static String addHours(String timeStr, int hours) {
    if (timeStr == null || timeStr.trim().isEmpty()) {
        log.warn("时间字符串为空，无法增加小时");
        return timeStr;
    }
    
    try {
        // 1. 解析时间字符串
        LocalDateTime dateTime = LocalDateTime.parse(timeStr, DATE_TIME_FORMATTER);
        
        // 2. 增加小时数
        LocalDateTime result = dateTime.plusHours(hours);
        
        // 3. 格式化返回
        return result.format(DATE_TIME_FORMATTER);
    } catch (DateTimeParseException e) {
        log.warn("时间字符串解析失败: {}, 错误: {}", timeStr, e.getMessage());
        return timeStr;
    }
}
```

**使用示例**:

```java
String startTime = "2024-01-15 10:30:00";
String endTime = TimeUtil.addHours(startTime, 24);
// endTime = "2024-01-16 10:30:00"
```

---

### 6.3 getTimeBefore10Minutes()

**功能**: 计算时间前10分钟

```java
public static String getTimeBefore10Minutes(String timeStr) {
    LocalDateTime dateTime = LocalDateTime.parse(timeStr, DATE_TIME_FORMATTER);
    LocalDateTime result = dateTime.minusMinutes(10);
    return result.format(DATE_TIME_FORMATTER);
}
```

---

### 6.4 getTimeAfter10Minutes()

**功能**: 计算时间后10分钟

```java
public static String getTimeAfter10Minutes(String timeStr) {
    LocalDateTime dateTime = LocalDateTime.parse(timeStr, DATE_TIME_FORMATTER);
    LocalDateTime result = dateTime.plusMinutes(10);
    return result.format(DATE_TIME_FORMATTER);
}
```

---

### 6.5 isSameDay()

**功能**: 检查两个时间是否是同一天

```java
public static boolean isSameDay(String time1, String time2) {
    LocalDateTime dateTime1 = LocalDateTime.parse(time1, DATE_TIME_FORMATTER);
    LocalDateTime dateTime2 = LocalDateTime.parse(time2, DATE_TIME_FORMATTER);
    
    return dateTime1.toLocalDate().equals(dateTime2.toLocalDate());
}
```

**示例**:

```java
isSameDay("2024-01-15 10:30:00", "2024-01-15 23:59:59");  // true
isSameDay("2024-01-15 23:59:59", "2024-01-16 00:00:01");  // false
```

---

### 6.6 isValidTimeFormat()

**功能**: 验证时间字符串格式是否正确

```java
public static boolean isValidTimeFormat(String timeStr) {
    try {
        LocalDateTime.parse(timeStr, DATE_TIME_FORMATTER);
        return true;
    } catch (DateTimeParseException e) {
        return false;
    }
}
```

---

### 6.7 getCurrentTimeString()

**功能**: 获取当前时间的格式化字符串

```java
public static String getCurrentTimeString() {
    return LocalDateTime.now().format(DATE_TIME_FORMATTER);
}
```

---

## 7. NodeType 枚举

**文件路径**: `src/main/java/com/security/processchain/service/NodeType.java`

**职责**: 定义进程链中节点的类型

### 枚举值说明

```java
public enum NodeType {
    PROCESS,   // 进程节点
    FILE,      // 文件节点
    NETWORK,   // 网络节点
    DOMAIN,    // 域名节点
    EXPLORE,   // 探索节点（用于断裂链的占位节点）
    UNKNOWN    // 未知类型
}
```

| 枚举值 | 说明 | 使用场景 |
|--------|------|----------|
| `PROCESS` | 进程节点 | 进程创建、进程结束等日志 |
| `FILE` | 文件节点 | 文件创建、修改、删除等操作 |
| `NETWORK` | 网络节点 | 网络连接相关操作 |
| `DOMAIN` | 域名节点 | 域名解析相关操作 |
| `EXPLORE` | 探索节点 | **断裂链的占位节点**，表示无法继续向上追溯 |
| `UNKNOWN` | 未知类型 | 无法识别的日志类型 |

### EXPLORE 节点详解

**使用场景**:
当进程链向上遍历时，如果遇到以下情况会自动创建 `EXPLORE` 节点：

```
条件：
1. 找不到父节点的日志数据
2. 当前节点的 processGuid ≠ traceId（不是根节点）

结果：
1. 当前节点标记为 isBroken=true
2. 创建一个 EXPLORE 类型的占位节点
3. 添加边：explore节点 → 断裂节点
```

**实际应用示例**:

```
场景1：完整的进程链
  [root_process]  ← isRoot=true, processGuid=traceId
      ↓
  [parent_process]
      ↓
  [child_process]  ← 告警节点

场景2：断裂的进程链
  [explore_parent] ← NodeType.EXPLORE（占位节点）
      ↓
  [parent_process] ← isBroken=true（找不到更上层的父进程）
      ↓
  [child_process]  ← 告警节点
```

**前端展示建议**:
- `EXPLORE` 节点可以用特殊图标标识（如虚线框、问号图标）
- 提示用户：此处进程链向上追溯中断，可能是日志缺失或时间窗口限制

---

## 附录：关键数据流图

### 批量生成进程链的数据流

```
IpMappingRelation (输入)
  │
  ├─→ 提取 IP 列表 → ["192.168.1.1", "192.168.1.2", ...]
  │
  ├─→ 批量查询告警 → OptimizedESQueryService.batchQueryEDRAlarms()
  │     └─→ MultiSearchRequest → ES → Map<String, List<RawAlarm>>
  │
  ├─→ 告警选举 (for each IP)
  │     ├─→ 有网端关联？→ 优先选择关联告警
  │     └─→ 无网端关联？→ AlarmElectionUtil.electAlarm()
  │           └─→ 选择威胁等级最高的组
  │
  ├─→ 建立映射 → Map<String, String> hostToTraceId
  │     └─→ {"192.168.1.1": "trace-001", "192.168.1.2": "trace-002", ...}
  │
  ├─→ 批量查询日志 → OptimizedESQueryService.batchQueryRawLogs(hostToTraceId)
  │     └─→ MultiSearchRequest → ES → List<RawLog> (所有日志)
  │
  ├─→ 构建进程链 → ProcessChainBuilder.buildIncidentChain()
  │     ├─→ 日志索引 (按 processGuid, parentProcessGuid)
  │     ├─→ 遍历告警 (双向/向上遍历)
  │     ├─→ 合并节点
  │     ├─→ 裁剪节点 (如超过限制)
  │     └─→ 转换为最终模型 (使用 NodeMapper, EdgeMapper)
  │
  └─→ IncidentProcessChain (输出)
       ├─→ nodes: List<ProcessNode>
       └─→ edges: List<ProcessEdge>
```

---

## 附录：性能优化总结

### 1. ES 查询优化

| 优化项 | 优化前 | 优化后 | 性能提升 |
|--------|--------|--------|----------|
| 告警查询 | N次串行查询 | 1次 MultiSearchRequest | N倍 |
| 日志查询 | N次串行查询 | 1次 MultiSearchRequest | N倍 |
| 查询条件 | must (计算评分) | filter (不计算评分，可缓存) | 2-3倍 |

### 2. 算法优化

| 优化项 | 说明 |
|--------|------|
| 日志索引 | 提前建立 processGuid 和 parentProcessGuid 索引，避免重复遍历 |
| 节点合并 | 合并相同 processGuid 的节点，减少冗余 |
| 节点裁剪 | 按重要性评分裁剪，保留关键节点 |
| 深度限制 | 限制遍历深度为 50，防止死循环 |
| 环检测 | 使用 visitedNodesInPath 检测环，避免无限递归 |

### 3. 线程安全优化

| 组件 | 优化前 | 优化后 |
|------|--------|--------|
| TimeUtil | SimpleDateFormat (非线程安全) | DateTimeFormatter (线程安全) |
| 性能影响 | 需要同步或每次创建 | 无需同步，可复用 |

---

## 结语

本文档详细说明了项目核心类的每个函数的实现逻辑。建议在阅读代码时：

1. **先理解整体流程**：从 `ProcessChainServiceImpl.generateProcessChains()` 开始
2. **深入算法细节**：重点关注 `ProcessChainBuilder` 的遍历算法
3. **学习优化技巧**：关注 `OptimizedESQueryService` 的批量查询实现
4. **掌握转换逻辑**：理解 `IncidentConverters` 的节点转换过程

如有疑问，可参考代码注释或联系维护人员。


