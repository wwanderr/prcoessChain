# 无告警场景紧急排查

## 🚨 问题描述

**用户反馈**：
> 之前的代码，我去掉了关于alarms为空的判定往下走，但是生成不了进程链

**症状**：
- 去掉了 `alarms == null || alarms.isEmpty()` 的判定
- 代码继续执行，但最终返回空的进程链

---

## 🎯 根本原因

**即使去掉判定，如果 `startNodes` 为空，也不会生成进程链！**

```java
// 阶段2：确定起点节点
Set<String> startNodes = new HashSet<>();

// 如果 alarms 为空
if (alarms != null && !alarms.isEmpty()) {
    // 跳过（无告警）
}
// 如果 startLogEventIds 为空或找不到节点
else if (startLogEventIds != null && !startLogEventIds.isEmpty()) {
    // 可能找不到节点，startNodes 仍为空
}

// 如果 startNodes 为空
for (String startNode : startNodes) {  // ❌ 不会执行
    // 遍历逻辑
}

// 结果：relevantNodes 为空，返回空进程链
```

---

## 🔍 排查清单

### 检查1：logs 参数是否为空？

**搜索日志**：`【无告警场景】日志总数=`

**结果**：
- ✅ 如果 > 0，继续下一步
- ❌ 如果 = 0，**问题在这里**！

**原因**：
- ES 查询失败
- traceId 或 hostAddress 不正确
- ES 中没有数据

**解决方案**：
```java
// 在 ProcessChainServiceImpl 中
List<RawLog> logs = esQueryService.queryLogsByTraceIds(traceIds, hostAddresses, ...);
log.info("【日志查询】查询到的日志数: {}", logs != null ? logs.size() : 0);

// 检查：
// 1. traceIds 是否正确
// 2. hostAddresses 是否正确
// 3. ES 索引是否有数据
```

### 检查2：eventId 是否匹配？

**搜索日志**：`【无告警场景】匹配的日志数`

**结果**：
- ✅ 如果 = startLogEventIds.size()，继续下一步
- ❌ 如果 = 0，**问题在这里**！

**原因**：
- eventId 大小写不一致
- eventId 有空格
- eventId 本身不对

**解决方案**：
```java
// 在 ProcessChainServiceImpl 中收集 startLogEventIds 时
Set<String> startLogEventIds = new HashSet<>();
if (ipMappingRelation.getLogs() != null) {
    for (String eventId : ipMappingRelation.getLogs().values()) {
        if (eventId != null && !eventId.trim().isEmpty()) {
            startLogEventIds.add(eventId.trim());  // ✅ trim 去除空格
            log.info("【收集起点eventId】{}", eventId);
        }
    }
}

// 在日志中也 trim
for (RawLog rawLog : logs) {
    String logEventId = rawLog.getEventId();
    if (logEventId != null) {
        logEventId = logEventId.trim();  // ✅ 统一处理
    }
    // 比较
}
```

### 检查3：processGuid 是否在图中？

**搜索日志**：`【无告警场景】processGuid [XXX] 在图中不存在`

**结果**：
- ✅ 如果没有这个警告，继续下一步
- ❌ 如果有，**问题在这里**！

**原因**：
- 该 processGuid 的日志在建图时被跳过
- processGuid 为 null

**解决方案**：
```java
// 检查建图逻辑
ProcessChainGraph fullGraph = graphBuilder.buildGraph(alarms, logs, traceIds);
log.info("【建图完成】节点数={}", fullGraph.getNodeCount());

// 打印所有节点
for (String nodeId : fullGraph.getNodeIds()) {
    log.debug("【图中节点】{}", nodeId);
}

// 对比：startLogEventIds 对应的 processGuid 是否在图中
```

### 检查4：startLogEventIds 是否为空？

**搜索日志**：`【进程链生成】-> startLogEventIds:`

**结果**：
- ✅ 如果不为空，继续下一步
- ❌ 如果为空，**问题在这里**！

**原因**：
- `IpMappingRelation.logs` 为 null
- 网端关联时没有设置 eventId

**解决方案**：
```java
// 在网端关联时
IpMappingRelation relation = new IpMappingRelation();

// ✅ 必须设置 logs 映射
Map<String, String> ipToEventId = new HashMap<>();
ipToEventId.put(victimIP, eventId);  // 受害者IP → 关联的日志eventId
relation.setLogs(ipToEventId);

log.info("【网端关联】设置起点eventId: IP={}, eventId={}", victimIP, eventId);
```

---

## 💡 临时解决方案

如果您**暂时找不到问题**，可以使用**兜底方案**：

### 方案1：使用根节点作为起点

```java
// 修改 ProcessChainBuilder.buildProcessChain()

if (startNodes.isEmpty()) {
    // ✅ 兜底：使用根节点
    startNodes.addAll(fullGraph.getRootNodes());
    log.warn("【兜底方案】startNodes为空，使用根节点作为起点: {}", startNodes.size());
}
```

**优点**：一定能生成进程链（如果有根节点）
**缺点**：可能包含不相关的进程

### 方案2：使用所有告警级别节点作为起点

```java
if (startNodes.isEmpty()) {
    // ✅ 使用所有含告警的节点
    startNodes.addAll(fullGraph.getAlarmNodes());
    log.warn("【兜底方案】startNodes为空，使用告警节点作为起点: {}", startNodes.size());
}
```

**优点**：聚焦在有问题的节点
**缺点**：无告警场景不适用

### 方案3：使用所有节点（最激进）

```java
if (startNodes.isEmpty() && fullGraph.getNodeCount() > 0) {
    // ⚠️ 最后手段：使用所有节点
    Set<String> allNodes = new HashSet<>(fullGraph.getNodeIds());
    
    // 限制数量，避免过大
    int maxNodes = 10;
    int count = 0;
    for (String nodeId : allNodes) {
        startNodes.add(nodeId);
        count++;
        if (count >= maxNodes) break;
    }
    
    log.warn("【兜底方案】startNodes为空，随机选择{}个节点作为起点", startNodes.size());
}
```

**优点**：一定有输出
**缺点**：不精准，性能差

---

## ✅ 推荐步骤

### 第1步：添加临时日志

在 `buildProcessChain()` 中添加：

```java
// 阶段2结束后
log.info("【起点节点】共 {} 个起点", startNodes.size());

// ✅ 添加：如果为空，打印详细信息
if (startNodes.isEmpty()) {
    log.error("【紧急排查】startNodes 为空，无法生成进程链！");
    log.error("  - alarms数量: {}", alarms != null ? alarms.size() : 0);
    log.error("  - logs数量: {}", logs != null ? logs.size() : 0);
    log.error("  - startLogEventIds数量: {}", startLogEventIds != null ? startLogEventIds.size() : 0);
    log.error("  - startLogEventIds内容: {}", startLogEventIds);
    log.error("  - 图节点数: {}", fullGraph.getNodeCount());
    log.error("  - 根节点数: {}", fullGraph.getRootNodes().size());
    
    // ⚠️ 临时兜底
    if (!fullGraph.getRootNodes().isEmpty()) {
        startNodes.addAll(fullGraph.getRootNodes());
        log.warn("【兜底方案】使用根节点作为起点: {}", startNodes);
    }
}
```

### 第2步：重新编译运行

```bash
cd demo
mvn clean compile -DskipTests
```

### 第3步：查看日志

运行后，如果看到：
```
【紧急排查】startNodes 为空，无法生成进程链！
  - alarms数量: 0
  - logs数量: 100
  - startLogEventIds数量: 1
  - startLogEventIds内容: [EVENT_001]
  - 图节点数: 100
  - 根节点数: 1
```

根据这些信息，可以判断：
- logs 不为空 ✅
- startLogEventIds 不为空 ✅
- 图节点数 > 0 ✅
- **但 startNodes 为空** ❌

说明：eventId 匹配或 processGuid 查找出了问题。

### 第4步：对比 eventId

手动打印：

```java
// 在匹配 eventId 的循环中
for (RawLog rawLog : logs) {
    String logEventId = rawLog.getEventId();
    log.info("【日志eventId】{}", logEventId);
    
    if (startLogEventIds.contains(logEventId)) {
        log.info("【匹配成功】eventId={}, processGuid={}", 
                logEventId, rawLog.getProcessGuid());
    }
}

// 对比
log.info("【期望的eventIds】{}", startLogEventIds);
```

---

## 📞 请提供信息

要帮您解决这个问题，请提供：

1. **日志输出**（包含以下关键词）：
   ```
   【进程链生成】-> 开始构建进程链
   【无告警场景】开始处理起点日志
   【无告警场景】日志总数=
   【无告警场景】匹配的日志数
   【起点节点】共 X 个起点
   ```

2. **输入参数**：
   - `startLogEventIds` 的值
   - `logs` 的数量
   - `traceIds` 的值

3. **是否添加了临时兜底方案**（方案1/2/3）

有了这些信息，我可以精确定位问题！

---

**版本**：v1.0  
**日期**：2025-11-20  
**优先级**：🚨 紧急

